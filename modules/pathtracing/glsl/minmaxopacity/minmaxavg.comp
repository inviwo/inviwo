#include "utils/structs.glsl"
#include "utils/sampler3d.glsl"

#include "utils/classification.glsl"

// input volume
uniform sampler3D volumeData;
uniform VolumeParameters volumeDataParameters;

// output volume
uniform layout(binding = 0, rgba32f)
image3D opacityData;
uniform VolumeParameters opacityDataParameters;

// TODO: change name to regionSize
uniform ivec3 cellDim;
uniform sampler2D tf;

// look at https://github.com/ResearchDaniel/Correlated-Photon-Mapping-for-Interactive-Global-Illumination-of-Time-Varying-Volumetric-Data/blob/8ce15569df62e4cc9cfcb13086dcf8a523fbbdb4/modules/importancesamplingcl/processors/minmaxuniformgrid3dimportanceclprocessor.cpp#L304
// updateTransferFunctionDifferenceData

// https://github.com/ResearchDaniel/Correlated-Photon-Mapping-for-Interactive-Global-Illumination-of-Time-Varying-Volumetric-Data/blob/8ce15569df62e4cc9cfcb13086dcf8a523fbbdb4/modules/importancesamplingcl/cl/minmaxuniformgrid3dimportance.cl#L186
// importanForRangeTF, return min max

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


vec4 calcMinMaxAvg(ivec3 pos) {

    // Enlarge the neighborhood by 1 voxel to deal with the edges of the grid cell.
    // The edges of the grid cell will be between two voxels.
    
    ivec3 startCoord = pos * cellDim-1; 
    ivec3 endCoord = clamp(startCoord + cellDim+1, ivec3(0), ivec3(volumeDataParameters.dimensions));
    
    float minOpacity = 1f;
    float maxOpacity = 0f;
    float avgOpacity = 0f;
    float sampleCount = 0f;

    for (int z = startCoord.z; z < endCoord.z; ++z) {
        for (int y = startCoord.y; y < endCoord.y; ++y) {
            for (int x = startCoord.x; x < endCoord.x; ++x) {
                
                ivec3 texCoord = ivec3(x,y,z);
                vec4 vn = getNormalizedVoxel(volumeData, volumeDataParameters, texCoord);
                float opacity = applyTF(tf, vn).a;

                minOpacity = min(minOpacity, opacity);
                maxOpacity = max(maxOpacity, opacity);



                avgOpacity += opacity;
                sampleCount += 1f;
            }
        }
    }
    // TODO: Sample edges of the grid cell instead of the neighboring voxel to create tighter bounds.
    // The code below samples the edges, but also all voxels inside. We need to divide it into loops that
    // covers the 6 edges of the grid cell.
    /*
    
    startCoord = pos * cellDim-1; 
    endCoord = clamp(startCoord + cellDim+1, ivec3(0), ivec3(volumeDataParameters.dimensions+1));

    for (int z = startCoord.z; z < endCoord.z; ++z) {
        for (int y = startCoord.y; y < endCoord.y; ++y) {
            for (int x = startCoord.x; x < endCoord.x; ++x) {
                
                vec3 texCoord = (vec3(x, y, z)) / vec3(volumeDataParameters.dimensions);
                vec4 vn = getNormalizedVoxel(volumeData, volumeDataParameters, texCoord);
                float opacity = applyTF(tf, vn).a;

                minOpacity = min(minOpacity, opacity);
                maxOpacity = max(maxOpacity, opacity);



                avgOpacity += opacity;
                sampleCount += 1f;
            }
        }
    }
    */
    avgOpacity /= sampleCount;

    return vec4(minOpacity, maxOpacity, avgOpacity, 0f);
}



void main() {
    ivec3 storePos = ivec3(gl_GlobalInvocationID.xyz);
    vec4 result = calcMinMaxAvg(storePos);

    imageStore(opacityData, storePos, result);
}
