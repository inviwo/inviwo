#include "utils/structs.glsl"
#include "utils/sampler2d.glsl"
#include "utils/sampler3d.glsl"

#include "utils/classification.glsl"
#include "utils/compositing.glsl"
#include "utils/depth.glsl"
#include "utils/gradients.glsl"
#include "utils/shading.glsl"
#include "utils/raycastgeometry.glsl"
#include "utils/raycasting.glsl"

#include "random.glsl"
#include "transmittance/transmittance.glsl"
#include "transmittance/transmittancemethods.glsl"
#include "lightestimation.glsl"
#include "util/rayminmax.glsl"
#include "uniformgrid.glsl"

// volume
uniform sampler3D volume;
uniform VolumeParameters volumeParameters;

// entry
uniform sampler2D entryColor;
uniform sampler2D entryDepth;
uniform ImageParameters entryParameters;

// exit
uniform sampler2D exitColor;
uniform sampler2D exitDepth;
uniform ImageParameters exitParameters;

// output
uniform layout(binding = 0, rgba32f)
image2D outportColor;
uniform layout(binding = 1, r32f)
image2D outportDepth;
writeonly uniform image2D outportPicking;
uniform ImageParameters outportParameters;

// Grid
uniform sampler3D minMaxOpacity;
uniform VolumeParameters minMaxOpacityParameters;
uniform ivec3 cellDim;

// Uniform properties
uniform CameraParameters camera;
uniform VolumeIndicatorParameters positionindicator;
uniform RaycastingParameters raycaster;
uniform LightParameters light;  // lighting
uniform sampler2D transferFunction;

uniform int channel;
uniform float time_ms;
uniform int iteration;
uniform int transmittanceMethod;
uniform bool partitionedTransmittance;

#define PI 3.1415

layout(local_size_x = 16, local_size_y = 16) in;

uint getHashSeed() {
    uint globalDimX = gl_WorkGroupSize.x * gl_NumWorkGroups.x;
    uint globalDimY = gl_WorkGroupSize.y * gl_NumWorkGroups.y;

    uint gid = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalDimX;
    uint hashSeed = gid + floatBitsToUint(time_ms);
    return hashSeed;
}

vec4 pathtrace(vec3 entryPoint, vec3 exitPoint, float entryDepth, float exitDepth, float rayDepth,
               inout float depth, vec4 bgColor) {

    // All coords are texture space unless specified otherwise
    vec3 ray = exitPoint - entryPoint;
    float t1 = length(ray);
    float t0 = 0.f;
    vec3 rayDir = normalize(ray);

    uint hashSeed = getHashSeed();

    vec3 cameraDir = calcCameraDir(entryPoint, exitPoint, volumeParameters.textureToWorld);

    vec3 samplePosition = entryPoint;

    float T = 0.0f;
    vec3 minMax = vec3(0.f, 1.0f, 0.0f);

    vec3 errorReturn = vec3(0);

    minMax =
        rayMinMaxAvgTest(samplePosition, rayDir, t0, t1, minMaxOpacity, minMaxOpacityParameters,
                         cellDim, volume, volumeParameters, transferFunction, errorReturn);
    // Avoid case where control extinction == upper bound (causing division by zero)
    minMax.y += 1e-6;

    //return mix(vec4(minMax, 1f), vec4(errorReturn, 1.f), 1.0);


    vec3 auxReturnTracking = vec3(0);
    float meanFreePath =
        woodcockTracking(samplePosition, rayDir, t0, t1, hashSeed, volume, volumeParameters,
                         transferFunction, minMax.y, auxReturnTracking);

    // NOTE: When using, POISSONRATIO tracking method and tf sample 0 has value 0, this creates and
    // error return value
    if (auxReturnTracking != vec3(0)) {
        //return vec4(0, auxReturnTracking.x, auxReturnTracking.x, 1.0f);
    }

    vec4 result = vec4(0.0);
    if (meanFreePath <= t1) {
        samplePosition = entryPoint + meanFreePath * rayDir;
        rayDepth = meanFreePath;
        depth = rayDepth;

        result.rgb = estimateDirectLightUniformGrid(
            volume, volumeParameters, transferFunction,
            minMaxOpacity, minMaxOpacityParameters, cellDim,
            samplePosition, cameraDir, light, hashSeed, channel, transmittanceMethod);
        result.a = 1f - T;

    } else {
        result = bgColor;
    }
    return result;
}
float calcStep(in float rayLength, in vec3 direction, in float samplingRate, in vec3 dimensions) {
    float incr = min(rayLength, rayLength / (samplingRate * length(direction * dimensions)));
    float samples = ceil(rayLength / incr);
    return rayLength / samples;
}
// Testing function to compare MinMaxOpacity validity against Volume texture data.
vec4 rayOpacityTextureTesting(vec3 entryPoint, vec3 exitPoint, int stepcount) {

    // Init values
    vec3 ray = exitPoint - entryPoint;
    float t1 = length(ray);
    vec3 rayDir = normalize(ray);
    float t0 = 0.f;
    vec4 result = vec4(0);

    vec3 cameraDir = calcCameraDir(entryPoint, exitPoint, volumeParameters.textureToWorld);
    vec3 samplePosition = entryPoint;

    // Set up grid traversal
    mat4 m = volumeParameters.textureToIndex;

    vec3 x1 = transformPoint(m, entryPoint + t0 * rayDir) + 0.5f;
    vec3 x2 = transformPoint(m, entryPoint + t1 * rayDir) + 0.5f;

    ivec3 cellCoord, cellCoordEnd, di;
    vec3 dt, deltatx;
    setupUniformGridTraversal(x1, x2, cellDim, ivec3(minMaxOpacityParameters.dimensions), cellCoord,
                              cellCoordEnd, di, dt, deltatx);

    // Begin grid traversal
    float dirLen = length(ray);
    float t = 0.f;

    bool continueTraversal = true;

    int testCount = 0;

    while (continueTraversal) {
        float tPrev = t;
        float max = getVoxel(minMaxOpacity, minMaxOpacityParameters, cellCoord).y;

        continueTraversal = stepToNextCellHit(deltatx, di, cellCoordEnd, dt, cellCoord, t);
        
        // Get parameters t such that samplePosition = entryPoint + t*rayDir correspond to the point
        // where the ray enters the opacity voxel (tEntry) and exits the opacity voxel (tExit)
        float tEntry = t0 + dirLen * tPrev;
        float tExit = t0 + dirLen * min(t1, float(t));

        // The step size in texture space
        float rayStep = calcStep(t1, rayDir, stepcount, volumeParameters.dimensions);
        float rayPosition = tEntry;
        // Uniformly step and compare through the grid cell
        while (rayPosition <= tExit) {
            // Sample positions
            samplePosition = vec3(entryPoint + rayPosition*rayDir);
            
            float sampleOpacity =
                applyTF(transferFunction,
                        getNormalizedVoxel(volume, volumeParameters, samplePosition))
                    .a;

            testCount += 1;
            // Compare to MinMaxOpacity data to Volume data
            if (max < sampleOpacity) {
                result.x += 1;
            }
            rayPosition += rayStep;
        }
    }
    // Visualize difference between erroneous and error free rays.
    if(result.x == 0) {
        result.y = 1.f;
    } else {
        result.x = 1;
    }
    //result.y = testCount - result.x;
    //result /= float(testCount);

    return result;
}

void main() {

    vec4 picking = vec4(0.0);  // The picking color of the ray
                               // The ray depth value [0, ray length], -1 means "no" depth.
    float rayDepth = 0;        // Uses the same space as rayPosition. Usually used to track
                               // the depth of the "first" hit in DVR.
    float depth = 1.0;         // The image depth, from far to near [0, 1].
                               // Will be overridden by rayDepth if != -1 and then
                               // written to outportDepth

    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    vec2 texCoord = vec2(0.5 + gl_GlobalInvocationID.xy) / outportParameters.dimensions;

    if (any(greaterThan(storePos, outportParameters.dimensions))) {
        return;
    }

    vec3 entryPoint = texture(entryColor, texCoord).xyz;
    vec3 exitPoint = texture(exitColor, texCoord).xyz;

    float entryPointDepth = texture(entryDepth, texCoord).x;
    float exitPointDepth = texture(exitDepth, texCoord).x;

    vec4 bgColor = vec4(0.f, 0.f, 0.0f, 0.0f);

    if (entryPoint == exitPoint) {
        imageStore(outportColor, storePos, bgColor);
        imageStore(outportDepth, storePos, vec4(depth, depth, depth, 255));
        imageStore(outportPicking, storePos, picking);
        return;
    }

    vec4 color =
        pathtrace(entryPoint, exitPoint, entryPointDepth, exitPointDepth, rayDepth, depth,
        bgColor);

    //vec4 color = rayOpacityTextureTesting(entryPoint, exitPoint, 4);

    vec4 colorPrev = imageLoad(outportColor, storePos);

    float w = 1.0f - 1.0f / float(iteration + 1);
    vec4 colorFinal = mix(color, colorPrev, w);

    imageStore(outportColor, storePos, colorFinal);
    imageStore(outportDepth, storePos, vec4(vec3(depth), 255));
    imageStore(outportPicking, storePos, picking);
}
