<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Assimp: Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Assimp
   &#160;<span id="projectnumber">v3.1.1 (June 2014)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="General"></a>
Overview</h1>
<p>All materials are stored in an array of aiMaterial inside the aiScene.</p>
<p>Each <a class="el" href="structai_mesh.html" title="A mesh represents a geometry or model with a single material. ">aiMesh</a> refers to one material by its index in the array. Due to the vastly diverging definitions and usages of material parameters there is no hard definition of a material structure. Instead a material is defined by a set of properties accessible by their names. Have a look at <a class="el" href="material_8h.html" title="Defines the material system of the library. ">assimp/material.h</a> to see what types of properties are defined. In this file there are also various functions defined to test for the presence of certain properties in a material and retrieve their values.</p>
<h1><a class="anchor" id="mat_tex"></a>
Textures</h1>
<p>Textures are organized in stacks, each stack being evaluated independently. The final color value from a particular texture stack is used in the shading equation. For example, the computed color value of the diffuse texture stack (aiTextureType_DIFFUSE) is multipled with the amount of incoming diffuse light to obtain the final diffuse color of a pixel.</p>
<div class="fragment"><div class="line"> Stack                               Resulting equation</div>
<div class="line"></div>
<div class="line">------------------------</div>
<div class="line">| Constant base color  |             color</div>
<div class="line">------------------------ </div>
<div class="line">| Blend operation 0    |             +</div>
<div class="line">------------------------</div>
<div class="line">| Strength factor 0    |             0.25*</div>
<div class="line">------------------------</div>
<div class="line">| Texture 0            |             texture_0</div>
<div class="line">------------------------ </div>
<div class="line">| Blend operation 1    |             *</div>
<div class="line">------------------------</div>
<div class="line">| Strength factor 1    |             1.0*</div>
<div class="line">------------------------</div>
<div class="line">| Texture 1            |             texture_1</div>
<div class="line">------------------------</div>
<div class="line">  ...                                ...</div>
</div><!-- fragment --><h1><a class="anchor" id="keys"></a>
Constants</h1>
<p>All material key constants start with 'AI_MATKEY' (it's an ugly macro for historical reasons, don't ask).</p>
<table  border="1">
<tr>
<th>Name </th><th>Data Type </th><th>Default Value </th><th>Meaning </th><th>Notes  </th></tr>
<tr>
<td><code>NAME</code> </td><td><a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated. ">aiString</a> </td><td>n/a </td><td>The name of the material, if available.  </td><td>Ignored by <code>aiProcess_RemoveRedundantMaterials</code>. Materials are considered equal even if their names are different.  </td></tr>
<tr>
<td><code>COLOR_DIFFUSE</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space. ">aiColor3D</a> </td><td>black (0,0,0) </td><td>Diffuse color of the material. This is typically scaled by the amount of incoming diffuse light (e.g. using gouraud shading)  </td><td>&mdash;  </td></tr>
<tr>
<td><code>COLOR_SPECULAR</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space. ">aiColor3D</a> </td><td>black (0,0,0) </td><td>Specular color of the material. This is typically scaled by the amount of incoming specular light (e.g. using phong shading)  </td><td>&mdash;  </td></tr>
<tr>
<td><code>COLOR_AMBIENT</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space. ">aiColor3D</a> </td><td>black (0,0,0) </td><td>Ambient color of the material. This is typically scaled by the amount of ambient light  </td><td>&mdash;  </td></tr>
<tr>
<td><code>COLOR_EMISSIVE</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space. ">aiColor3D</a> </td><td>black (0,0,0) </td><td>Emissive color of the material. This is the amount of light emitted by the object. In real time applications it will usually not affect surrounding objects, but raytracing applications may wish to treat emissive objects as light sources.  </td><td><p class="starttd">&mdash; </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>COLOR_TRANSPARENT</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space. ">aiColor3D</a> </td><td>black (0,0,0) </td><td>Defines the transparent color of the material, this is the color to be multiplied with the color of translucent light to construct the final 'destination color' for a particular position in the screen buffer. T  </td><td><p class="starttd">&mdash; </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>WIREFRAME</code> </td><td>int </td><td>false </td><td>Specifies whether wireframe rendering must be turned on for the material. 0 for false, !0 for true.  </td><td><p class="starttd">&mdash; </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TWOSIDED</code> </td><td>int </td><td>false </td><td>Specifies whether meshes using this material must be rendered without backface culling. 0 for false, !0 for true.  </td><td><p class="starttd">Some importers set this property if they don't know whether the output face oder is right. As long as it is not set, you may safely enable backface culling. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>SHADING_MODEL</code> </td><td>int </td><td>gouraud </td><td>One of the <a class="el" href="material_8h.html#a93e23e0201d6ed86fb4287e15218e4cf" title="Defines all shading models supported by the library. ">aiShadingMode</a> enumerated values. Defines the library shading model to use for (real time) rendering to approximate the original look of the material as closely as possible.  </td><td><p class="starttd">The presence of this key might indicate a more complex material. If absent, assume phong shading only if a specular exponent is given. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BLEND_FUNC</code> </td><td>int </td><td>false </td><td>One of the <a class="el" href="material_8h.html#ae1236da1ccfbf4f23bb490287a4d61ac" title="Defines alpha-blend flags. ">aiBlendMode</a> enumerated values. Defines how the final color value in the screen buffer is computed from the given color at that position and the newly computed color from the material. Simply said, alpha blending settings. </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>OPACITY</code> </td><td>float </td><td>1.0 </td><td>Defines the opacity of the material in a range between 0..1. </td><td><p class="starttd">Use this value to decide whether you have to activate alpha blending for rendering. <code>OPACITY</code> != 1 usually also implies TWOSIDED=1 to avoid cull artifacts. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>SHININESS</code> </td><td>float </td><td>0.f </td><td>Defines the shininess of a phong-shaded material. This is actually the exponent of the phong specular equation </td><td><p class="starttd"><code>SHININESS</code>=0 is equivalent to <code>SHADING_MODEL</code>=<code>aiShadingMode_Gouraud</code>. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>SHININESS_STRENGTH</code> </td><td>float </td><td>1.0 </td><td>Scales the specular color of the material. </td><td><p class="starttd">This value is kept separate from the specular color by most modelers, and so do we. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>REFRACTI</code> </td><td>float </td><td>1.0 </td><td>Defines the Index Of Refraction for the material. That's not supported by most file formats. </td><td><p class="starttd">Might be of interest for raytracing. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TEXTURE(t,n)</code> </td><td><a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated. ">aiString</a> </td><td>n/a </td><td>Defines the path to the n'th texture on the stack 't', where 'n' is any value &gt;= 0 and 't' is one of the <a class="el" href="material_8h.html#a7dd415ff703a2cc53d1c22ddbbd7dde0" title="Defines the purpose of a texture. ">aiTextureType</a> enumerated values. </td><td><p class="starttd">See the 'Textures' section above. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TEXBLEND(t,n)</code> </td><td>float </td><td>n/a </td><td>Defines the strength the n'th texture on the stack 't'. All color components (rgb) are multipled with this factor <em>before</em> any further processing is done. </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TEXOP(t,n)</code> </td><td>int </td><td>n/a </td><td>One of the <a class="el" href="material_8h.html#afcd3096d69affba13114cedfc6f9ee6b" title="Defines how the Nth texture of a specific type is combined with the result of all previous layers...">aiTextureOp</a> enumerated values. Defines the arithmetic operation to be used to combine the n'th texture on the stack 't' with the n-1'th. <code>TEXOP(t,0)</code> refers to the blend operation between the base color for this stack (e.g. <code>COLOR_DIFFUSE</code> for the diffuse stack) and the first texture. </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>MAPPING(t,n)</code> </td><td>int </td><td>n/a </td><td>Defines how the input mapping coordinates for sampling the n'th texture on the stack 't' are computed. Usually explicit UV coordinates are provided, but some model file formats might also be using basic shapes, such as spheres or cylinders, to project textures onto meshes. </td><td><p class="starttd">See the 'Textures' section below. <a class="el" href="postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410aa4ae05f45c5682ab245cf8e87986426f">aiProcess_GenUVCoords</a> can be used to let <a class="el" href="namespace_assimp.html" title="Assimp&#39;s CPP-API and all internal APIs. ">Assimp</a> compute proper UV coordinates from projective mappings. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>UVWSRC(t,n)</code> </td><td>int </td><td>n/a </td><td>Defines the UV channel to be used as input mapping coordinates for sampling the n'th texture on the stack 't'. All meshes assigned to this material share the same UV channel setup </td><td><p class="starttd">Presence of this key implies <code>MAPPING(t,n)</code> to be <a class="el" href="material_8h.html#a6186e909f1ae28133ab10f1b4635b0f9afe4af8e2f0303198ff2c51edf3039277" title="The mapping coordinates are taken from an UV channel. ">aiTextureMapping_UV</a>. See <a class="el" href="materials.html#uvwsrc">How to map UV channels to textures (MATKEY_UVWSRC)</a> for more details.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>MAPPINGMODE_U(t,n)</code> </td><td>int </td><td>n/a </td><td>Any of the <a class="el" href="material_8h.html#a6cbe56056751aa80e8dd714632a49de0" title="Defines how UV coordinates outside the [0...1] range are handled. ">aiTextureMapMode</a> enumerated values. Defines the texture wrapping mode on the x axis for sampling the n'th texture on the stack 't'. 'Wrapping' occurs whenever UVs lie outside the 0..1 range.  </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>MAPPINGMODE_V(t,n)</code> </td><td>int </td><td>n/a </td><td>Wrap mode on the v axis. See <code>MAPPINGMODE_U</code>.  </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TEXMAP_AXIS(t,n)</code> </td><td>aiVector3D </td><td>n/a </td><td>Defines the base axis to to compute the mapping coordinates for the n'th texture on the stack 't' from. This is not required for UV-mapped textures. For instance, if <code>MAPPING(t,n)</code> is <a class="el" href="material_8h.html#a6186e909f1ae28133ab10f1b4635b0f9ada83cfca5e55fc99dc89e0e94c91cdb5" title="Spherical mapping. ">aiTextureMapping_SPHERE</a>, U and V would map to longitude and latitude of a sphere around the given axis. The axis is given in local mesh space. </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TEXFLAGS(t,n)</code> </td><td>int </td><td>n/a </td><td>Defines miscellaneous flag for the n'th texture on the stack 't'. This is a bitwise combination of the <a class="el" href="material_8h.html#a6d003e078617e4e80d1313a6250b2dfd" title="Defines some mixed flags for a particular texture. ">aiTextureFlags</a> enumerated values. </td><td><p class="starttd">- </p>
<p class="endtd"></p>
</td></tr>
</table>
<h1><a class="anchor" id="cpp"></a>
C++-API</h1>
<p>Retrieving a property from a material is done using various utility functions. For C++ it's simply calling aiMaterial::Get()</p>
<div class="fragment"><div class="line">aiMaterial* mat = .....</div>
<div class="line"></div>
<div class="line"><span class="comment">// The generic way</span></div>
<div class="line">if(AI_SUCCESS != mat-&gt;Get(&lt;material-key&gt;,&lt;where-to-store&gt;)) {</div>
<div class="line">   <span class="comment">// handle epic failure here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Simple, isn't it? To get the name of a material you would use</p>
<div class="fragment"><div class="line"><a class="code" href="structai_string.html">aiString</a> name;</div>
<div class="line">mat-&gt;Get(AI_MATKEY_NAME,name);</div>
</div><!-- fragment --><p>Or for the diffuse color ('color' won't be modified if the property is not set)</p>
<div class="fragment"><div class="line"><a class="code" href="structai_color3_d.html">aiColor3D</a> color (0.f,0.f,0.f);</div>
<div class="line">mat-&gt;Get(AI_MATKEY_COLOR_DIFFUSE,color);</div>
</div><!-- fragment --><p><b>Note:</b> Get() is actually a template with explicit specializations for <a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space. ">aiColor3D</a>, aiColor4D, <a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated. ">aiString</a>, float, int and some others. Make sure that the type of the second parameter matches the expected data type of the material property (no compile-time check yet!). Don't follow this advice if you wish to encounter very strange results.</p>
<h1><a class="anchor" id="C"></a>
C-API</h1>
<p>For good old C it's slightly different. Take a look at the aiGetMaterialGet&lt;data-type&gt; functions.</p>
<div class="fragment"><div class="line">aiMaterial* mat = .....</div>
<div class="line"></div>
<div class="line">if(AI_SUCCESS != aiGetMaterialFloat(mat,&lt;material-key&gt;,&lt;where-to-store&gt;)) {</div>
<div class="line">   <span class="comment">// handle epic failure here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>To get the name of a material you would use</p>
<div class="fragment"><div class="line"><a class="code" href="structai_string.html">aiString</a> name;</div>
<div class="line">aiGetMaterialString(mat,AI_MATKEY_NAME,&amp;name);</div>
</div><!-- fragment --><p>Or for the diffuse color ('color' won't be modified if the property is not set)</p>
<div class="fragment"><div class="line"><a class="code" href="structai_color3_d.html">aiColor3D</a> color (0.f,0.f,0.f);</div>
<div class="line">aiGetMaterialColor(mat,AI_MATKEY_COLOR_DIFFUSE,&amp;color);</div>
</div><!-- fragment --><h1><a class="anchor" id="uvwsrc"></a>
How to map UV channels to textures (MATKEY_UVWSRC)</h1>
<p>The MATKEY_UVWSRC property is only present if the source format doesn't specify an explicit mapping from textures to UV channels. Many formats don't do this and assimp is not aware of a perfect rule either.</p>
<p>Your handling of UV channels needs to be flexible therefore. Our recommendation is to use logic like this to handle most cases properly:</p>
<pre class="fragment">have only one uv channel?
   assign channel 0 to all textures and break

for all textures
   have uvwsrc for this texture?
      assign channel specified in uvwsrc
   else
      assign channels in ascending order for all texture stacks, 
            i.e. diffuse1 gets channel 1, opacity0 gets channel 0.</pre><h1><a class="anchor" id="pseudo"></a>
Pseudo Code Listing</h1>
<p>For completeness, the following is a very rough pseudo-code sample showing how to evaluate <a class="el" href="namespace_assimp.html" title="Assimp&#39;s CPP-API and all internal APIs. ">Assimp</a> materials in your shading pipeline. You'll probably want to limit your handling of all those material keys to a reasonable subset suitable for your purposes (for example most 3d engines won't support highly complex multi-layer materials, but many 3d modellers do).</p>
<p>Also note that this sample is targeted at a (shader-based) rendering pipeline for real time graphics.</p>
<div class="fragment"><div class="line"><span class="comment">// ---------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Evaluate multiple textures stacked on top of each other</span></div>
<div class="line">float3 EvaluateStack(stack)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// For the &#39;diffuse&#39; stack stack.base_color would be COLOR_DIFFUSE</span></div>
<div class="line">  <span class="comment">// and TEXTURE(aiTextureType_DIFFUSE,n) the n&#39;th texture.</span></div>
<div class="line"></div>
<div class="line">  float3 base = stack.base_color;</div>
<div class="line">  <span class="keywordflow">for</span> (every texture in stack)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// assuming we have explicit &amp; pretransformed UVs for this texture</span></div>
<div class="line">    float3 color = SampleTexture(texture,uv); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// scale by texture blend factor</span></div>
<div class="line">    color *= texture.blend;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (texture.op == add)</div>
<div class="line">      base += color;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (texture.op == multiply)</div>
<div class="line">      base *= color;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// other blend ops go here</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> base;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Compute the diffuse contribution for a pixel</span></div>
<div class="line">float3 ComputeDiffuseContribution()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (shading == none)</div>
<div class="line">     <span class="keywordflow">return</span> float3(1,1,1);</div>
<div class="line"></div>
<div class="line">  float3 intensity (0,0,0);</div>
<div class="line">  <span class="keywordflow">for</span> (all lights in range)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">float</span> fac = 1.f;</div>
<div class="line">    <span class="keywordflow">if</span> (shading == gouraud)</div>
<div class="line">      fac =  lambert-term ..</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// other shading modes go here</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// handling of different types of lights, such as point or spot lights</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// and finally sum the contribution of this single light ...</span></div>
<div class="line">    intensity += light.diffuse_color * fac;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ... and combine the final incoming light with the diffuse color</span></div>
<div class="line">  <span class="keywordflow">return</span> EvaluateStack(diffuse) * intensity;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Compute the specular contribution for a pixel</span></div>
<div class="line">float3 ComputeSpecularContribution()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (shading == gouraud || specular_strength == 0 || specular_exponent == 0)</div>
<div class="line">    <span class="keywordflow">return</span> float3(0,0,0);</div>
<div class="line"></div>
<div class="line">  float3 intensity (0,0,0);</div>
<div class="line">  <span class="keywordflow">for</span> (all lights in range)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">float</span> fac = 1.f;</div>
<div class="line">    <span class="keywordflow">if</span> (shading == phong)</div>
<div class="line">      fac =  phong-term ..</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// other specular shading modes go here</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// handling of different types of lights, such as point or spot lights</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// and finally sum the specular contribution of this single light ...</span></div>
<div class="line">    intensity += light.specular_color * fac;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ... and combine the final specular light with the specular color</span></div>
<div class="line">  <span class="keywordflow">return</span> EvaluateStack(specular) * intensity * specular_strength;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Compute the ambient contribution for a pixel</span></div>
<div class="line">float3 ComputeAmbientContribution()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (shading == none)</div>
<div class="line">     <span class="keywordflow">return</span> float3(0,0,0);</div>
<div class="line"></div>
<div class="line">  float3 intensity (0,0,0);</div>
<div class="line">  <span class="keywordflow">for</span> (all lights in range)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">float</span> fac = 1.f;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handling of different types of lights, such as point or spot lights</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// and finally sum the ambient contribution of this single light ...</span></div>
<div class="line">    intensity += light.ambient_color * fac;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ... and combine the final ambient light with the ambient color</span></div>
<div class="line">  <span class="keywordflow">return</span> EvaluateStack(ambient) * intensity;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Compute the final color value for a pixel</span></div>
<div class="line"><span class="comment">// @param prev Previous color at that position in the framebuffer</span></div>
<div class="line">float4 PimpMyPixel (float4 prev)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// .. handle displacement mapping per vertex</span></div>
<div class="line">  <span class="comment">// .. handle bump/normal mapping</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Get all single light contribution terms</span></div>
<div class="line">  float3 diff = ComputeDiffuseContribution();</div>
<div class="line">  float3 spec = ComputeSpecularContribution(); </div>
<div class="line">  float3 ambi = ComputeAmbientContribution();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// .. and compute the final color value for this pixel</span></div>
<div class="line">  float3 color = diff + spec + ambi;</div>
<div class="line">  float3 opac  = EvaluateStack(opacity);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// note the *slightly* strange meaning of additive and multiplicative blending here ...</span></div>
<div class="line">  <span class="comment">// those names will most likely be changed in future versions</span></div>
<div class="line">  <span class="keywordflow">if</span> (blend_func == add)</div>
<div class="line">       <span class="keywordflow">return</span> prev+color*opac;</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (blend_func == multiply)</div>
<div class="line">       <span class="keywordflow">return</span> prev*(1.0-opac)+prev*opac;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> color;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 13:46:03 for Assimp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
