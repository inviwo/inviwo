<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inviwo: inviwo::filesystem Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="inviwo_dark.png"/></td>
  <td id="projectalign">
   <div id="projectname">Inviwo<span id="projectnumber">&#160;0.9.12-pre</span>
   </div>
   <div id="projectbrief">Inviwo documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceinviwo_1_1filesystem.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">inviwo::filesystem Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa2d3f40da95cbf87da4fb08dcadaf1fc" id="r_aa2d3f40da95cbf87da4fb08dcadaf1fc"><td class="memItemLeft" align="right" valign="top"><a id="aa2d3f40da95cbf87da4fb08dcadaf1fc" name="aa2d3f40da95cbf87da4fb08dcadaf1fc"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ListMode</b> { <b>Files</b>
, <b>Directories</b>
, <b>FilesAndDirectories</b>
 }</td></tr>
<tr class="separator:aa2d3f40da95cbf87da4fb08dcadaf1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a47b54ccafdc2950e58667d2a50274fc3" id="r_a47b54ccafdc2950e58667d2a50274fc3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b54ccafdc2950e58667d2a50274fc3">fopen</a> (const std::filesystem::path &amp;filename, const char *mode)</td></tr>
<tr class="separator:a47b54ccafdc2950e58667d2a50274fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fa52b79c7a57bdf0b9b9e1d647db0d" id="r_ab3fa52b79c7a57bdf0b9b9e1d647db0d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::fstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3fa52b79c7a57bdf0b9b9e1d647db0d">fstream</a> (const std::filesystem::path &amp;filename, std::ios_base::openmode mode=std::ios_base::in|std::ios_base::out)</td></tr>
<tr class="separator:ab3fa52b79c7a57bdf0b9b9e1d647db0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b963481462bd9f5417c01da5ae733d6" id="r_a7b963481462bd9f5417c01da5ae733d6"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::ifstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b963481462bd9f5417c01da5ae733d6">ifstream</a> (const std::filesystem::path &amp;filename, std::ios_base::openmode mode=std::ios_base::in)</td></tr>
<tr class="separator:a7b963481462bd9f5417c01da5ae733d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158fd5afc4f5f47dc6cc6da15e0836b3" id="r_a158fd5afc4f5f47dc6cc6da15e0836b3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a158fd5afc4f5f47dc6cc6da15e0836b3">ofstream</a> (const std::filesystem::path &amp;filename, std::ios_base::openmode mode=std::ios_base::out)</td></tr>
<tr class="separator:a158fd5afc4f5f47dc6cc6da15e0836b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a16aa05cabc3a84330617c3c4bddb90" id="r_a5a16aa05cabc3a84330617c3c4bddb90"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a16aa05cabc3a84330617c3c4bddb90">skipByteOrderMark</a> (std::istream &amp;stream)</td></tr>
<tr class="separator:a5a16aa05cabc3a84330617c3c4bddb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5039752575c9aff24aa9c1b752e7b3f4" id="r_a5039752575c9aff24aa9c1b752e7b3f4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5039752575c9aff24aa9c1b752e7b3f4">getWorkingDirectory</a> ()</td></tr>
<tr class="separator:a5039752575c9aff24aa9c1b752e7b3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fc1ac1c3117ace56b5f9a7b6044578" id="r_a82fc1ac1c3117ace56b5f9a7b6044578"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82fc1ac1c3117ace56b5f9a7b6044578">setWorkingDirectory</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a82fc1ac1c3117ace56b5f9a7b6044578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f023f70c612f1d7bf72937ed4a620c" id="r_af1f023f70c612f1d7bf72937ed4a620c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1f023f70c612f1d7bf72937ed4a620c">getExecutablePath</a> ()</td></tr>
<tr class="separator:af1f023f70c612f1d7bf72937ed4a620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2bc842a81daa4a45cdea058f903f07" id="r_a9b2bc842a81daa4a45cdea058f903f07"><td class="memItemLeft" align="right" valign="top"><a id="a9b2bc842a81daa4a45cdea058f903f07" name="a9b2bc842a81daa4a45cdea058f903f07"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getInviwoBinDir</b> ()</td></tr>
<tr class="separator:a9b2bc842a81daa4a45cdea058f903f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edba63a7203bd2032e29ad535798338" id="r_a7edba63a7203bd2032e29ad535798338"><td class="memItemLeft" align="right" valign="top"><a id="a7edba63a7203bd2032e29ad535798338" name="a7edba63a7203bd2032e29ad535798338"></a>
IVW_CORE_API std::vector&lt; std::filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLoadedLibraries</b> ()</td></tr>
<tr class="separator:a7edba63a7203bd2032e29ad535798338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8449f5229df164efa90a4c3f8c0007eb" id="r_a8449f5229df164efa90a4c3f8c0007eb"><td class="memItemLeft" align="right" valign="top"><a id="a8449f5229df164efa90a4c3f8c0007eb" name="a8449f5229df164efa90a4c3f8c0007eb"></a>
IVW_CORE_API int&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentProcessId</b> ()</td></tr>
<tr class="separator:a8449f5229df164efa90a4c3f8c0007eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec091a51c52b045292ce3eb18a2eb54" id="r_a3ec091a51c52b045292ce3eb18a2eb54"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec091a51c52b045292ce3eb18a2eb54">getInviwoUserSettingsPath</a> ()</td></tr>
<tr class="separator:a3ec091a51c52b045292ce3eb18a2eb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d04e2908fe7c413b873ac8463cea217" id="r_a5d04e2908fe7c413b873ac8463cea217"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d04e2908fe7c413b873ac8463cea217">fileExists</a> (const std::filesystem::path &amp;filePath)</td></tr>
<tr class="memdesc:a5d04e2908fe7c413b873ac8463cea217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file exists.  <br /></td></tr>
<tr class="separator:a5d04e2908fe7c413b873ac8463cea217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae831dc07476b7826e2b528a90aee3bf1" id="r_ae831dc07476b7826e2b528a90aee3bf1"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae831dc07476b7826e2b528a90aee3bf1">directoryExists</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:ae831dc07476b7826e2b528a90aee3bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a499cbc4135bd394279e175cebaed52" id="r_a7a499cbc4135bd394279e175cebaed52"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a499cbc4135bd394279e175cebaed52">fileModificationTime</a> (const std::filesystem::path &amp;filePath)</td></tr>
<tr class="memdesc:a7a499cbc4135bd394279e175cebaed52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last time file was modified. Error can occur if the file does not exist for example.  <br /></td></tr>
<tr class="separator:a7a499cbc4135bd394279e175cebaed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1298176ca84ca16c16750cb1b30e283b" id="r_a1298176ca84ca16c16750cb1b30e283b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1298176ca84ca16c16750cb1b30e283b">copyFile</a> (const std::filesystem::path &amp;src, const std::filesystem::path &amp;dst)</td></tr>
<tr class="memdesc:a1298176ca84ca16c16750cb1b30e283b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an existing file to a new file. Overwrites existing file.  <br /></td></tr>
<tr class="separator:a1298176ca84ca16c16750cb1b30e283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad333bf1ff2ccf13e98c8df6e0cb47fb" id="r_aad333bf1ff2ccf13e98c8df6e0cb47fb"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad333bf1ff2ccf13e98c8df6e0cb47fb">getDirectoryContents</a> (const std::filesystem::path &amp;path, ListMode mode=ListMode::Files)</td></tr>
<tr class="separator:aad333bf1ff2ccf13e98c8df6e0cb47fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bd15f33c625ffd0c8b97f67edeae59" id="r_a51bd15f33c625ffd0c8b97f67edeae59"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51bd15f33c625ffd0c8b97f67edeae59">getDirectoryContentsRecursively</a> (const std::filesystem::path &amp;path, ListMode mode=ListMode::Files)</td></tr>
<tr class="separator:a51bd15f33c625ffd0c8b97f67edeae59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f6a24d34556172da645232e3920f4c" id="r_ab9f6a24d34556172da645232e3920f4c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f6a24d34556172da645232e3920f4c">wildcardStringMatch</a> (const std::string &amp;pattern, const std::string &amp;str)</td></tr>
<tr class="separator:ab9f6a24d34556172da645232e3920f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea08a44a49a90d298bc2808c72c51861" id="r_aea08a44a49a90d298bc2808c72c51861"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea08a44a49a90d298bc2808c72c51861">wildcardStringMatchDigits</a> (const std::string &amp;pattern, const std::string &amp;str, int &amp;index, bool matchLess=false, bool matchMore=true)</td></tr>
<tr class="separator:aea08a44a49a90d298bc2808c72c51861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade542fa64d91ae847bb7b4e1f2fd90ef" id="r_ade542fa64d91ae847bb7b4e1f2fd90ef"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::optional&lt; std::filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade542fa64d91ae847bb7b4e1f2fd90ef">getParentFolderWithChildren</a> (const std::filesystem::path &amp;path, std::span&lt; const std::filesystem::path &gt; childFolders)</td></tr>
<tr class="separator:ade542fa64d91ae847bb7b4e1f2fd90ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d148823eb0fc950a101e914944a20" id="r_a163d148823eb0fc950a101e914944a20"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API const std::filesystem::path &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a163d148823eb0fc950a101e914944a20">findBasePath</a> ()</td></tr>
<tr class="separator:a163d148823eb0fc950a101e914944a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15abca3eb8493d3c3a772d582483ecee" id="r_a15abca3eb8493d3c3a772d582483ecee"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15abca3eb8493d3c3a772d582483ecee">getPath</a> (PathType pathType, const std::string &amp;suffix=&quot;&quot;, const bool createFolder=false)</td></tr>
<tr class="separator:a15abca3eb8493d3c3a772d582483ecee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c1b27f9738ed718bfcaf11b629a277" id="r_af2c1b27f9738ed718bfcaf11b629a277"><td class="memItemLeft" align="right" valign="top"><a id="af2c1b27f9738ed718bfcaf11b629a277" name="af2c1b27f9738ed718bfcaf11b629a277"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>createDirectoryRecursively</b> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:af2c1b27f9738ed718bfcaf11b629a277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16516734d6c920717397fa4f3bfbff48" id="r_a16516734d6c920717397fa4f3bfbff48"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16516734d6c920717397fa4f3bfbff48">addBasePath</a> (const std::filesystem::path &amp;url)</td></tr>
<tr class="memdesc:a16516734d6c920717397fa4f3bfbff48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> base path before the url.  <br /></td></tr>
<tr class="separator:a16516734d6c920717397fa4f3bfbff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0369e3f0cbb26009a553672d845cf7c9" id="r_a0369e3f0cbb26009a553672d845cf7c9"><td class="memItemLeft" align="right" valign="top"><a id="a0369e3f0cbb26009a553672d845cf7c9" name="a0369e3f0cbb26009a553672d845cf7c9"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getFileDirectory</b> (const std::filesystem::path &amp;url)</td></tr>
<tr class="separator:a0369e3f0cbb26009a553672d845cf7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf88914245224281882412eea5ca5275" id="r_adf88914245224281882412eea5ca5275"><td class="memItemLeft" align="right" valign="top"><a id="adf88914245224281882412eea5ca5275" name="adf88914245224281882412eea5ca5275"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getFileNameWithExtension</b> (const std::filesystem::path &amp;url)</td></tr>
<tr class="separator:adf88914245224281882412eea5ca5275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45893f1743d7ae15a47ac39db9be8b3" id="r_ac45893f1743d7ae15a47ac39db9be8b3"><td class="memItemLeft" align="right" valign="top"><a id="ac45893f1743d7ae15a47ac39db9be8b3" name="ac45893f1743d7ae15a47ac39db9be8b3"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getFileNameWithoutExtension</b> (const std::filesystem::path &amp;url)</td></tr>
<tr class="separator:ac45893f1743d7ae15a47ac39db9be8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df9851a3b203f10fbee19683c743a14" id="r_a2df9851a3b203f10fbee19683c743a14"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2df9851a3b203f10fbee19683c743a14">getFileExtension</a> (const std::filesystem::path &amp;url)</td></tr>
<tr class="memdesc:a2df9851a3b203f10fbee19683c743a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the characters after last dot (.).  <br /></td></tr>
<tr class="separator:a2df9851a3b203f10fbee19683c743a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ddaa35943548407d7bc8871c979154" id="r_a06ddaa35943548407d7bc8871c979154"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ddaa35943548407d7bc8871c979154">replaceFileExtension</a> (const std::filesystem::path &amp;url, std::string_view newFileExtension)</td></tr>
<tr class="separator:a06ddaa35943548407d7bc8871c979154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd8a70569955836ed127d08453f0cce" id="r_a2fd8a70569955836ed127d08453f0cce"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fd8a70569955836ed127d08453f0cce">getRelativePath</a> (const std::filesystem::path &amp;basePath, const std::filesystem::path &amp;absolutePath)</td></tr>
<tr class="memdesc:a2fd8a70569955836ed127d08453f0cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a path relative to basePath. Requirement: basePath and absulutePath has to be absolute paths. basePath should point at directory.  <br /></td></tr>
<tr class="separator:a2fd8a70569955836ed127d08453f0cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dfe1c4f8cdff74d2be0c43d17ed675" id="r_a02dfe1c4f8cdff74d2be0c43d17ed675"><td class="memItemLeft" align="right" valign="top"><a id="a02dfe1c4f8cdff74d2be0c43d17ed675" name="a02dfe1c4f8cdff74d2be0c43d17ed675"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getCanonicalPath</b> (const std::filesystem::path &amp;url)</td></tr>
<tr class="separator:a02dfe1c4f8cdff74d2be0c43d17ed675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8540b90e720a188d8c2ebbb9ea29f40f" id="r_a8540b90e720a188d8c2ebbb9ea29f40f"><td class="memItemLeft" align="right" valign="top"><a id="a8540b90e720a188d8c2ebbb9ea29f40f" name="a8540b90e720a188d8c2ebbb9ea29f40f"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAbsolutePath</b> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a8540b90e720a188d8c2ebbb9ea29f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad175585c0ce641220a188f1d0f805f75" id="r_ad175585c0ce641220a188f1d0f805f75"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad175585c0ce641220a188f1d0f805f75">sameDrive</a> (const std::filesystem::path &amp;refPath, const std::filesystem::path &amp;queryPath)</td></tr>
<tr class="memdesc:ad175585c0ce641220a188f1d0f805f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the second path is on the same drive as the first path.  <br /></td></tr>
<tr class="separator:ad175585c0ce641220a188f1d0f805f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088fe6644bcd30f6ffb4abb627e8be2a" id="r_a088fe6644bcd30f6ffb4abb627e8be2a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a088fe6644bcd30f6ffb4abb627e8be2a">cleanupPath</a> (std::string_view path)</td></tr>
<tr class="memdesc:a088fe6644bcd30f6ffb4abb627e8be2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clean up path by replacing backslashes with forward slash and removing surrounding quotes  <br /></td></tr>
<tr class="separator:a088fe6644bcd30f6ffb4abb627e8be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>filesystem </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a16516734d6c920717397fa4f3bfbff48" name="a16516734d6c920717397fa4f3bfbff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16516734d6c920717397fa4f3bfbff48">&#9670;&#160;</a></span>addBasePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::addBasePath </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> base path before the url. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1InviwoApplication.html#ac98f63ac3fd2478ccf46a7c235294f20">InviwoApplication::getBasePath</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Relative path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> base path + url </dd></dl>

</div>
</div>
<a id="a088fe6644bcd30f6ffb4abb627e8be2a" name="a088fe6644bcd30f6ffb4abb627e8be2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088fe6644bcd30f6ffb4abb627e8be2a">&#9670;&#160;</a></span>cleanupPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::cleanupPath </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clean up path by replacing backslashes with forward slash and removing surrounding quotes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>given path to be cleaned up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-quoted path containing no backslashes as directory separators </dd></dl>

</div>
</div>
<a id="a1298176ca84ca16c16750cb1b30e283b" name="a1298176ca84ca16c16750cb1b30e283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1298176ca84ca16c16750cb1b30e283b">&#9670;&#160;</a></span>copyFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::copyFile </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an existing file to a new file. Overwrites existing file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Path to the file to the existing file </td></tr>
    <tr><td class="paramname">dst</td><td>Path to the new file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if source file exists and the copy is successful, false otherwise </dd></dl>

</div>
</div>
<a id="ae831dc07476b7826e2b528a90aee3bf1" name="ae831dc07476b7826e2b528a90aee3bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae831dc07476b7826e2b528a90aee3bf1">&#9670;&#160;</a></span>directoryExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::directoryExists </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the directory exists</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5d04e2908fe7c413b873ac8463cea217" title="Check if a file exists.">fileExists</a> for files </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Directory path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if directory exists, false otherwise </dd></dl>

</div>
</div>
<a id="a5d04e2908fe7c413b873ac8463cea217" name="a5d04e2908fe7c413b873ac8463cea217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d04e2908fe7c413b873ac8463cea217">&#9670;&#160;</a></span>fileExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::fileExists </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file exists. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae831dc07476b7826e2b528a90aee3bf1">directoryExists</a> for directories </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>The path to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if file exists, false otherwise </dd></dl>

</div>
</div>
<a id="a7a499cbc4135bd394279e175cebaed52" name="a7a499cbc4135bd394279e175cebaed52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a499cbc4135bd394279e175cebaed52">&#9670;&#160;</a></span>fileModificationTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::time_t inviwo::filesystem::fileModificationTime </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last time file was modified. Error can occur if the file does not exist for example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>The path to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time of last modification, or 0 if an error occured (00:00, Jan 1 1970 UTC). </dd></dl>

</div>
</div>
<a id="a163d148823eb0fc950a101e914944a20" name="a163d148823eb0fc950a101e914944a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d148823eb0fc950a101e914944a20">&#9670;&#160;</a></span>findBasePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API const std::filesystem::path &amp; inviwo::filesystem::findBasePath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to find the Inviwo base path containing subfolders "data/workspaces" and "modules". If not found, try searching for path containing "modules". If neither are found, return the executable path.</p>
<dl class="section return"><dt>Returns</dt><dd>Inviwo base path </dd></dl>

</div>
</div>
<a id="a47b54ccafdc2950e58667d2a50274fc3" name="a47b54ccafdc2950e58667d2a50274fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b54ccafdc2950e58667d2a50274fc3">&#9670;&#160;</a></span>fopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API FILE * inviwo::filesystem::fopen </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and returns a FILE pointer for the given file name (utf-8 encoded). The call <code>auto f = filesystem::fopen(filename, mode);</code> is functionally equivalent to the statement <code>fopen(filename, mode);</code> or <code>_wfopen();</code>, respectively. No checks whether the file exists or was successfully opened are performed. That is the caller has to check it. For more details check the documentation of fopen.</p>
<p>Since all strings within Inviwo are utf-8 encoded, this function should be used to create a file handle when reading from/writing to files.</p>
<p>On Windows, the file name is first converted from a utf-8 string to std::wstring and then the file handle is created using the std::wstring as fopen(const char*) does not support utf-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>utf-8 encoded string </td></tr>
    <tr><td class="paramname">mode</td><td>mode to open the file (input or output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>file handle for the given file, i.e. <code>fopen(filename, mode);</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a47b54ccafdc2950e58667d2a50274fc3">fopen</a>, _wfopen </dd></dl>

</div>
</div>
<a id="ab3fa52b79c7a57bdf0b9b9e1d647db0d" name="ab3fa52b79c7a57bdf0b9b9e1d647db0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fa52b79c7a57bdf0b9b9e1d647db0d">&#9670;&#160;</a></span>fstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::fstream inviwo::filesystem::fstream </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode</td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::ios_base::in|std::ios_base::out</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and returns a std::fstream for the given file name (utf-8 encoded). The call <code>auto f = filesystem::fstream(filename, mode);</code> is functionally equivalent to the statement <code>std::fstream f(filename, mode);</code>. No checks whether the file exists or was successfully opened are performed. That is the caller has to check it. For more details check the documentation of std::fstream.</p>
<p>Since all strings within Inviwo are utf-8 encoded, this function should be used to create a stream when reading from/writing to files using streams.</p>
<p>On Windows, the file name is first converted from a utf-8 string to std::wstring and then the stream is created using the std::wstring as std::fstream(std::string) does not support utf-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>utf-8 encoded string </td></tr>
    <tr><td class="paramname">mode</td><td>mode to open the file (input or output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stream for the given file, i.e. <code>std::fstream(filename, mode);</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::fstream </dd></dl>

</div>
</div>
<a id="aad333bf1ff2ccf13e98c8df6e0cb47fb" name="aad333bf1ff2ccf13e98c8df6e0cb47fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad333bf1ff2ccf13e98c8df6e0cb47fb">&#9670;&#160;</a></span>getDirectoryContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::filesystem::path &gt; inviwo::filesystem::getDirectoryContents </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListMode</td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ListMode::Files</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the file listing of a directory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Files are listed for this directory </td></tr>
    <tr><td class="paramname">mode</td><td>What types of contents to return see ListMode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of files residing in the given path </dd></dl>

</div>
</div>
<a id="a51bd15f33c625ffd0c8b97f67edeae59" name="a51bd15f33c625ffd0c8b97f67edeae59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bd15f33c625ffd0c8b97f67edeae59">&#9670;&#160;</a></span>getDirectoryContentsRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::filesystem::path &gt; inviwo::filesystem::getDirectoryContentsRecursively </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListMode</td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ListMode::Files</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively searches and returns full path to files/directories in specified directory and its subdirectories. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Files are listed for this directory and its subdirectories </td></tr>
    <tr><td class="paramname">mode</td><td>What types of contents to return see ListMode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of files residing in the given path and its subdirectories </dd></dl>

</div>
</div>
<a id="af1f023f70c612f1d7bf72937ed4a620c" name="af1f023f70c612f1d7bf72937ed4a620c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f023f70c612f1d7bf72937ed4a620c">&#9670;&#160;</a></span>getExecutablePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::getExecutablePath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get full/path/to/executable running the application. </p><dl class="section return"><dt>Returns</dt><dd>Full path to the executable if successful, empty string otherwise. </dd></dl>

</div>
</div>
<a id="a2df9851a3b203f10fbee19683c743a14" name="a2df9851a3b203f10fbee19683c743a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df9851a3b203f10fbee19683c743a14">&#9670;&#160;</a></span>getFileExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::filesystem::getFileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the characters after last dot (.). </p>
<dl class="section note"><dt>Note</dt><dd>Avoid using this function for extracting file extensions if you are not sure that the expected extension only contains one dot. In general, there is no way to safely consider cases with multiple dots. File extensions with multiple dots can exist for compressed files (for example nii.gz). Instead, compare the url with registered extensions, see <a class="el" href="classinviwo_1_1FileExtension.html">inviwo::FileExtension</a> and <a class="el" href="classinviwo_1_1DataReaderFactory.html">inviwo::DataReaderFactory</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> </dd>
<dd>
getFileNameWithExtension </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Path to extract extension from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Extension excluding ., empty if no dot or filename are found. </dd></dl>

</div>
</div>
<a id="a3ec091a51c52b045292ce3eb18a2eb54" name="a3ec091a51c52b045292ce3eb18a2eb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec091a51c52b045292ce3eb18a2eb54">&#9670;&#160;</a></span>getInviwoUserSettingsPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::getInviwoUserSettingsPath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get path to the user settings / data folder for Inviwo, i.e. a folder where we have write-access. Will be:</p><ul>
<li>Windows: /AppData/Inviwo/</li>
<li>Linux: /home/.inviwo</li>
<li>Mac: /Library/Application Support/org.inviwo.network-editor</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Path to user settings folder </dd></dl>

</div>
</div>
<a id="ade542fa64d91ae847bb7b4e1f2fd90ef" name="ade542fa64d91ae847bb7b4e1f2fd90ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade542fa64d91ae847bb7b4e1f2fd90ef">&#9670;&#160;</a></span>getParentFolderWithChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::optional&lt; std::filesystem::path &gt; inviwo::filesystem::getParentFolderWithChildren </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::filesystem::path &gt;</td>          <td class="paramname"><span class="paramname"><em>childFolders</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverses all parent folders of path and returns the first directory matching the list of child folders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>directory where the search is started </td></tr>
    <tr><td class="paramname">childFolders</td><td>list of subfolders </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>path of parent directory holding all childFolders, otherwise std::nullopt </dd></dl>

</div>
</div>
<a id="a15abca3eb8493d3c3a772d582483ecee" name="a15abca3eb8493d3c3a772d582483ecee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15abca3eb8493d3c3a772d582483ecee">&#9670;&#160;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::getPath </td>
          <td>(</td>
          <td class="paramtype">PathType</td>          <td class="paramname"><span class="paramname"><em>pathType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>createFolder</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get basePath + pathType + suffix. </p><dl class="section see"><dt>See also</dt><dd>PathType </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathType</td><td>Enum for type of path </td></tr>
    <tr><td class="paramname">suffix</td><td>Path extension </td></tr>
    <tr><td class="paramname">createFolder</td><td>if true, will create the folder on disk if it does not exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basePath + pathType + suffix </dd></dl>

</div>
</div>
<a id="a2fd8a70569955836ed127d08453f0cce" name="a2fd8a70569955836ed127d08453f0cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd8a70569955836ed127d08453f0cce">&#9670;&#160;</a></span>getRelativePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::getRelativePath </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>basePath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>absolutePath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a path relative to basePath. Requirement: basePath and absulutePath has to be absolute paths. basePath should point at directory. </p>
<p>Example: basePath = "C:/foo/bar" absolutePath = "C:/foo/test/file.txt" returns "../test/file.txt" </p>

</div>
</div>
<a id="a5039752575c9aff24aa9c1b752e7b3f4" name="a5039752575c9aff24aa9c1b752e7b3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5039752575c9aff24aa9c1b752e7b3f4">&#9670;&#160;</a></span>getWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::getWorkingDirectory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the working directory of the application.</p>
<dl class="section note"><dt>Note</dt><dd>getBasePath should be used in the framework in general. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>getBasePath </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Full path to working directory. </dd></dl>

</div>
</div>
<a id="a7b963481462bd9f5417c01da5ae733d6" name="a7b963481462bd9f5417c01da5ae733d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b963481462bd9f5417c01da5ae733d6">&#9670;&#160;</a></span>ifstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::ifstream inviwo::filesystem::ifstream </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode</td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::ios_base::in</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and returns a std::ifstream for the given file name (utf-8 encoded). The call <code>auto in = filesystem::ifstream(filename, mode);</code> is functionally equivalent to the statement <code>std::ifstream in(filename, mode);</code>. No checks whether the file exists or was successfully opened are performed. That is the caller has to check it. For more details check the documentation of std::ifstream.</p>
<p>Since all strings within Inviwo are utf-8 encoded, this function should be used to create a stream when reading from files using streams.</p>
<p>On Windows, the file name is first converted from a utf-8 string to std::wstring and then the stream is created using the std::wstring as std::ifstream(std::string) does not support utf-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>utf-8 encoded string </td></tr>
    <tr><td class="paramname">mode</td><td>mode to open the file (input or output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stream for the given file, i.e. <code>std::ifstream(filename, mode);</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::ifstream </dd></dl>

</div>
</div>
<a id="a158fd5afc4f5f47dc6cc6da15e0836b3" name="a158fd5afc4f5f47dc6cc6da15e0836b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158fd5afc4f5f47dc6cc6da15e0836b3">&#9670;&#160;</a></span>ofstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::ofstream inviwo::filesystem::ofstream </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode</td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::ios_base::out</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and returns a std::ofstream for the given file name (utf-8 encoded). The call <code>auto out = filesystem::ofstream(filename, mode);</code> is functionally equivalent to the statement <code>std::ofstream out(filename, mode);</code>. No checks whether the file exists or was successfully opened are performed. That is the caller has to check it. For more details check the documentation of std::ofstream.</p>
<p>Since all strings within Inviwo are utf-8 encoded, this function should be used to create a stream when writing to files using streams.</p>
<p>On Windows, the file name is first converted from a utf-8 string to std::wstring and then the stream is created using the std::wstring as std::ofstream(std::string) does not support utf-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>utf-8 encoded string </td></tr>
    <tr><td class="paramname">mode</td><td>mode to open the file (input or output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stream for the given file, i.e. <code>std::ofstream(filename, mode);</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::ofstream </dd></dl>

</div>
</div>
<a id="a06ddaa35943548407d7bc8871c979154" name="a06ddaa35943548407d7bc8871c979154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ddaa35943548407d7bc8871c979154">&#9670;&#160;</a></span>replaceFileExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::filesystem::replaceFileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>newFileExtension</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the last file extension to newFileExtension, if no extension exists append newFileExtension. newFileExtension should not contain any leading "." </p>

</div>
</div>
<a id="ad175585c0ce641220a188f1d0f805f75" name="ad175585c0ce641220a188f1d0f805f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad175585c0ce641220a188f1d0f805f75">&#9670;&#160;</a></span>sameDrive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::sameDrive </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>refPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>queryPath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the second path is on the same drive as the first path. </p>
<p>If both paths are relative, this function returns true. If only refPath is relative <a class="el" href="classinviwo_1_1InviwoApplication.html#ac98f63ac3fd2478ccf46a7c235294f20">InviwoApplication::getBasePath</a> is used instead as reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refPath</td><td>reference path, if relative then <a class="el" href="classinviwo_1_1InviwoApplication.html#ac98f63ac3fd2478ccf46a7c235294f20">InviwoApplication::getBasePath</a> is used instead </td></tr>
    <tr><td class="paramname">queryPath</td><td>path to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if queryPath and refPath are located on the same drive (on Windows), always true on all other systems </dd></dl>

</div>
</div>
<a id="a82fc1ac1c3117ace56b5f9a7b6044578" name="a82fc1ac1c3117ace56b5f9a7b6044578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fc1ac1c3117ace56b5f9a7b6044578">&#9670;&#160;</a></span>setWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::filesystem::setWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the working directory of the application. </p>

</div>
</div>
<a id="a5a16aa05cabc3a84330617c3c4bddb90" name="a5a16aa05cabc3a84330617c3c4bddb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a16aa05cabc3a84330617c3c4bddb90">&#9670;&#160;</a></span>skipByteOrderMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::skipByteOrderMark </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects the UTF-8 byte order mark (BOM) and skips it if it exists. Reads the first three characters to determine if the BOM exists. Rewinds stream if no BOM exists and otherwise leaves the stream position after the three BOM characters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream to check and potentially modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if byte order mark was found, false otherwise </dd></dl>

</div>
</div>
<a id="ab9f6a24d34556172da645232e3920f4c" name="ab9f6a24d34556172da645232e3920f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f6a24d34556172da645232e3920f4c">&#9670;&#160;</a></span>wildcardStringMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::wildcardStringMatch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a given string matches a pattern. The pattern might contain '*' matching any string including the empty string and '?' matching a single character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern used for matching, might contain '*' and '?' </td></tr>
    <tr><td class="paramname">str</td><td>String which needs to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given string matches the pattern, false otherwise. </dd></dl>

</div>
</div>
<a id="aea08a44a49a90d298bc2808c72c51861" name="aea08a44a49a90d298bc2808c72c51861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea08a44a49a90d298bc2808c72c51861">&#9670;&#160;</a></span>wildcardStringMatchDigits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::filesystem::wildcardStringMatchDigits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>matchLess</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>matchMore</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a given string matches a pattern including digits. The pattern might contain a single sequence of '#' for indicating a number besides '*' matching any string including the empty string and '?' matching a single character.</p>
<p>The digit sequence indicated by '#' is extracted and returned. Depending on the flags, the number have to exactly match sequence or might be shorter (matchLess) or longer (matchMore). For example, the sequence '###' matches only a three-digit number. Enabling 'matchLess' also matches one-digit and two-digit numbers whereas 'matchMore' allows for numbers with more digits.</p>
<p>Examples:</p><ul>
<li>'###*.jpg' will match all jpeg files starting with a 3-digit sequence. Setting 'matchMore = true' matches the same files, but might extract longer numbers.</li>
<li>'myfile#.png' matches all files containing exactly one digit with 'matchMore = false'.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern used for matching, might contain a single sequence of '#' besides '*', and '?' </td></tr>
    <tr><td class="paramname">str</td><td>String which needs to be checked </td></tr>
    <tr><td class="paramname">index</td><td>if the match is successful, this index contains the extracted digit sequence indicated by '#' </td></tr>
    <tr><td class="paramname">matchLess</td><td>allows to match digit sequences shorter than defined by the number of '#' (default false) </td></tr>
    <tr><td class="paramname">matchMore</td><td>allows to match longer digit sequences (default true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given string matches the pattern, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinviwo.html">inviwo</a></li><li class="navelem"><a class="el" href="namespaceinviwo_1_1filesystem.html">filesystem</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
