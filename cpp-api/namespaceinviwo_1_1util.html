<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inviwo: inviwo::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="inviwo_dark.png"/></td>
  <td id="projectalign">
   <div id="projectname">Inviwo<span id="projectnumber">&#160;0.9.12-pre</span>
   </div>
   <div id="projectbrief">Inviwo documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceinviwo_1_1util.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">inviwo::util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1alwaysTrue.html">alwaysTrue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1BrickIterator.html">BrickIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator providing access to a subregion, or brick, within linearized 3D data.  <a href="classinviwo_1_1util_1_1BrickIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1BufferDispatcher.html">BufferDispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information on build time and date as well as git hashes.  <a href="structinviwo_1_1util_1_1BuildInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1cloneable__ptr.html">cloneable_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1Combinations.html">Combinations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultColorRepresentation.html">DefaultColorRepresentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultColorRepresentation_3_01ivec3_01_4.html">DefaultColorRepresentation&lt; ivec3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultColorRepresentation_3_01ivec4_01_4.html">DefaultColorRepresentation&lt; ivec4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultTraversalFilter.html">DefaultTraversalFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1extent_3_01const_01T_00_01N_01_4.html">extent&lt; const T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::mat&lt; C, R, T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::mat&lt; C, R, T, Q &gt;, 1 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::tquat&lt; T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::vec&lt; L, T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1flat__extent.html">flat_extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type.html">for_each_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type_3_01std_1_1tuple_3_01T_01_4_01_4.html">for_each_type&lt; std::tuple&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type_3_01std_1_1tuple_3_01T_00_01Types_8_8_8_01_4_01_4.html">for_each_type&lt; std::tuple&lt; T, Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type__pair.html">for_each_type_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type__pair_3_01std_1_1tuple_3_01ATypes_8_8_8_01_4_00_01std_1_980543efefbc8ab89773d2539d3c1f94.html">for_each_type_pair&lt; std::tuple&lt; ATypes... &gt;, std::tuple&lt; BTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype.html">glmtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype_3_01T_00_011_00_011_00_01P_01_4.html">glmtype&lt; T, 1, 1, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype_3_01T_00_01L_00_011_00_01P_01_4.html">glmtype&lt; T, L, 1, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1Grid3DPointGeneration.html">Grid3DPointGeneration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1GridPos.html">GridPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1HasEnumName.html">HasEnumName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IdentifiedDeserializer.html">IdentifiedDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1identity.html">identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IndexedDeserializer.html">IndexedDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper_3_012_00_01IndexType_01_4.html">IndexMapper&lt; 2, IndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper_3_013_00_01IndexType_01_4.html">IndexMapper&lt; 3, IndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IndexProduct.html">IndexProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__constructible.html">is_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1is__container.html">is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__dereferenceable.html">is_dereferenceable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__dereferenceable_3_01T_00_01std_1_1void__t_3_01decltype_07_5std_1_1dea79db0978b6be7e835bcf0aa2839bd26.html">is_dereferenceable&lt; T, std::void_t&lt; decltype(*std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1is__stream__insertable.html">is_stream_insertable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__string.html">is_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IterRangeGenerator.html">IterRangeGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1KeepTrueWhileInScope.html">KeepTrueWhileInScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the given bool variable to true and restores its state when leaving the scope  <a href="classinviwo_1_1util_1_1KeepTrueWhileInScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MapDeserializer.html">MapDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MemoryFileHandle.html">MemoryFileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII class for providing a FILE stream handle to a buffer in memory. This class will open a file handle to /dev/null and use a dedicated buffer for buffering. As long as less bytes than getBufferSize() bytes are written/read, its status is well defined. However, after writing more than buffer size bytes, the buffer contents will be flushed, i.e. are no longer accessible.  <a href="classinviwo_1_1util_1_1MemoryFileHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MetaDataToProperty.html">MetaDataToProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1nonesuch.html">nonesuch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1NotificationBlocker.html">NotificationBlocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1OnScopeExit.html">OnScopeExit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls the given function when leaving the current scope  <a href="structinviwo_1_1util_1_1OnScopeExit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1ostream__joiner.html">ostream_joiner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1overloaded.html">overloaded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1Permutations.html">Permutations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1PropertyDistanceSorter.html">PropertyDistanceSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1RandomCubicalPointGeneration.html">RandomCubicalPointGeneration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1RandomSphericalPointGeneration.html">RandomSphericalPointGeneration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank.html">rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank_3_01const_01T_01_4.html">rank&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::mat&lt; C, R, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::tquat&lt; T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::vec&lt; L, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1same__extent.html">same_extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::mat&lt; C, R, T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::tquat&lt; T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::vec&lt; L, T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TempFileHandle.html">TempFileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII interface for providing a file handle and file name to a temporary file.  <a href="classinviwo_1_1util_1_1TempFileHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TextureAtlas.html">TextureAtlas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classinviwo_1_1Texture.html">Texture</a> atlas for a number of strings rendered with the <a class="el" href="classinviwo_1_1TextRenderer.html" title="Render text using the FreeType font library.">TextRenderer</a>.  <a href="classinviwo_1_1util_1_1TextureAtlas.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1TransformIterator.html">TransformIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1value__type.html">value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::mat&lt; C, R, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::tquat&lt; T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::vec&lt; L, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab33d69d2eaa56f1ab7286b7794c71770" id="r_ab33d69d2eaa56f1ab7286b7794c71770"><td class="memTemplParams" colspan="2"><a id="ab33d69d2eaa56f1ab7286b7794c71770" name="ab33d69d2eaa56f1ab7286b7794c71770"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab33d69d2eaa56f1ab7286b7794c71770"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>classIdentifierType</b> = decltype(std::declval&lt;T&gt;().getClassIdentifier())</td></tr>
<tr class="separator:ab33d69d2eaa56f1ab7286b7794c71770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac037ba47ee8e89eb5e86b66c36e7f3d6" id="r_ac037ba47ee8e89eb5e86b66c36e7f3d6"><td class="memTemplParams" colspan="2"><a id="ac037ba47ee8e89eb5e86b66c36e7f3d6" name="ac037ba47ee8e89eb5e86b66c36e7f3d6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac037ba47ee8e89eb5e86b66c36e7f3d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasGetClassIdentifier</b> = is_detected_exact&lt;std::string, classIdentifierType, T&gt;</td></tr>
<tr class="separator:ac037ba47ee8e89eb5e86b66c36e7f3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720b22362c67c273e303d812cb5a7911" id="r_a720b22362c67c273e303d812cb5a7911"><td class="memItemLeft" align="right" valign="top"><a id="a720b22362c67c273e303d812cb5a7911" name="a720b22362c67c273e303d812cb5a7911"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OffsetCallback</b> = std::function&lt;ivec2(std::vector&lt;<a class="el" href="classinviwo_1_1Processor.html">Processor</a>*&gt;)&gt;</td></tr>
<tr class="separator:a720b22362c67c273e303d812cb5a7911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe6a29ff71066ec2bd3013b3b5a90b5" id="r_aafe6a29ff71066ec2bd3013b3b5a90b5"><td class="memTemplParams" colspan="2"><a id="aafe6a29ff71066ec2bd3013b3b5a90b5" name="aafe6a29ff71066ec2bd3013b3b5a90b5"></a>
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:aafe6a29ff71066ec2bd3013b3b5a90b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detail::detector</a>&lt;<a class="el" href="structinviwo_1_1util_1_1nonesuch.html">nonesuch</a>, void, Op, Args...&gt;::value_t</td></tr>
<tr class="separator:aafe6a29ff71066ec2bd3013b3b5a90b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542d84c88ed55b175fb086f149b18eed" id="r_a542d84c88ed55b175fb086f149b18eed"><td class="memTemplParams" colspan="2"><a id="a542d84c88ed55b175fb086f149b18eed" name="a542d84c88ed55b175fb086f149b18eed"></a>
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a542d84c88ed55b175fb086f149b18eed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detail::detector</a>&lt;<a class="el" href="structinviwo_1_1util_1_1nonesuch.html">nonesuch</a>, void, Op, Args...&gt;::type</td></tr>
<tr class="separator:a542d84c88ed55b175fb086f149b18eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8923de64619033ca1973a83b87277e64" id="r_a8923de64619033ca1973a83b87277e64"><td class="memTemplParams" colspan="2"><a id="a8923de64619033ca1973a83b87277e64" name="a8923de64619033ca1973a83b87277e64"></a>
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a8923de64619033ca1973a83b87277e64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or</b> = <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detail::detector</a>&lt;Default, void, Op, Args...&gt;</td></tr>
<tr class="separator:a8923de64619033ca1973a83b87277e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d881497a46a3842b58c134113c0a847" id="r_a3d881497a46a3842b58c134113c0a847"><td class="memTemplParams" colspan="2"><a id="a3d881497a46a3842b58c134113c0a847" name="a3d881497a46a3842b58c134113c0a847"></a>
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a3d881497a46a3842b58c134113c0a847"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detected_or</a>&lt;Default, Op, Args...&gt;::type</td></tr>
<tr class="separator:a3d881497a46a3842b58c134113c0a847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02640c3ccedb60dbd31db0de44adb4d" id="r_af02640c3ccedb60dbd31db0de44adb4d"><td class="memTemplParams" colspan="2"><a id="af02640c3ccedb60dbd31db0de44adb4d" name="af02640c3ccedb60dbd31db0de44adb4d"></a>
template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:af02640c3ccedb60dbd31db0de44adb4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact</b> = std::is_same&lt;Expected, detected_t&lt;Op, Args...&gt;&gt;</td></tr>
<tr class="separator:af02640c3ccedb60dbd31db0de44adb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3c3054721c97cb59756ed935858d6" id="r_af0a3c3054721c97cb59756ed935858d6"><td class="memTemplParams" colspan="2"><a id="af0a3c3054721c97cb59756ed935858d6" name="af0a3c3054721c97cb59756ed935858d6"></a>
template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:af0a3c3054721c97cb59756ed935858d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible</b> = std::is_convertible&lt;detected_t&lt;Op, Args...&gt;, To&gt;</td></tr>
<tr class="separator:af0a3c3054721c97cb59756ed935858d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e4eff95e999c0f37072af916d5d93b" id="r_ab1e4eff95e999c0f37072af916d5d93b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1e4eff95e999c0f37072af916d5d93b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1e4eff95e999c0f37072af916d5d93b">PrecisionType</a> = typename std::remove_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type</td></tr>
<tr class="separator:ab1e4eff95e999c0f37072af916d5d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5cc1457325e4cf1c8756319d5e83c5" id="r_a4c5cc1457325e4cf1c8756319d5e83c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c5cc1457325e4cf1c8756319d5e83c5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c5cc1457325e4cf1c8756319d5e83c5">PrecisionValueType</a> = typename <a class="el" href="#ab1e4eff95e999c0f37072af916d5d93b">PrecisionType</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a4c5cc1457325e4cf1c8756319d5e83c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfcd45bbda4cdbbe602953a4da910a3" id="r_aebfcd45bbda4cdbbe602953a4da910a3"><td class="memTemplParams" colspan="2"><a id="aebfcd45bbda4cdbbe602953a4da910a3" name="aebfcd45bbda4cdbbe602953a4da910a3"></a>
template&lt;template&lt; typename &gt; typename Wrapper, typename List &gt; </td></tr>
<tr class="memitem:aebfcd45bbda4cdbbe602953a4da910a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1wrap.html">detail::wrap</a>&lt;Wrapper, List&gt;::type</td></tr>
<tr class="separator:aebfcd45bbda4cdbbe602953a4da910a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bb950b99c99a8c895b08a7bb9dcc80" id="r_a17bb950b99c99a8c895b08a7bb9dcc80"><td class="memTemplParams" colspan="2"><a id="a17bb950b99c99a8c895b08a7bb9dcc80" name="a17bb950b99c99a8c895b08a7bb9dcc80"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17bb950b99c99a8c895b08a7bb9dcc80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value_type_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1value__type.html">value_type</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a17bb950b99c99a8c895b08a7bb9dcc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21641efde825241713d599989b3ebc8" id="r_ae21641efde825241713d599989b3ebc8"><td class="memTemplParams" colspan="2"><a id="ae21641efde825241713d599989b3ebc8" name="ae21641efde825241713d599989b3ebc8"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae21641efde825241713d599989b3ebc8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>same_extent_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1same__extent.html">same_extent</a>&lt;T, U&gt;::type</td></tr>
<tr class="separator:ae21641efde825241713d599989b3ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab192a43df07da71e0ff2c5de85c1d971" id="r_ab192a43df07da71e0ff2c5de85c1d971"><td class="memTemplParams" colspan="2"><a id="ab192a43df07da71e0ff2c5de85c1d971" name="ab192a43df07da71e0ff2c5de85c1d971"></a>
template&lt;typename T  = double, glm::length_t C = 1, glm::length_t R = 1, glm::qualifier Q = glm::defaultp&gt; </td></tr>
<tr class="memitem:ab192a43df07da71e0ff2c5de85c1d971"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmtype_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1glmtype.html">glmtype</a>&lt;T, C, R, Q&gt;::type</td></tr>
<tr class="separator:ab192a43df07da71e0ff2c5de85c1d971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81981d5a68a197914efe4faec07a255" id="r_af81981d5a68a197914efe4faec07a255"><td class="memItemLeft" align="right" valign="top"><a id="af81981d5a68a197914efe4faec07a255" name="af81981d5a68a197914efe4faec07a255"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexMapper2D</b> = <a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a>&lt;2, size_t&gt;</td></tr>
<tr class="separator:af81981d5a68a197914efe4faec07a255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85756acd1a8f5735b65db27476be8da2" id="r_a85756acd1a8f5735b65db27476be8da2"><td class="memItemLeft" align="right" valign="top"><a id="a85756acd1a8f5735b65db27476be8da2" name="a85756acd1a8f5735b65db27476be8da2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexMapper3D</b> = <a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a>&lt;3, size_t&gt;</td></tr>
<tr class="separator:a85756acd1a8f5735b65db27476be8da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5433403a98e6a64371dada8fd4b5693" id="r_aa5433403a98e6a64371dada8fd4b5693"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5433403a98e6a64371dada8fd4b5693"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5433403a98e6a64371dada8fd4b5693">HasClassIdentifierUpper</a></td></tr>
<tr class="separator:aa5433403a98e6a64371dada8fd4b5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2128449f85e6a0683ecfab6f0bf557f" id="r_af2128449f85e6a0683ecfab6f0bf557f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af2128449f85e6a0683ecfab6f0bf557f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2128449f85e6a0683ecfab6f0bf557f">HasClassIdentifierLower</a></td></tr>
<tr class="separator:af2128449f85e6a0683ecfab6f0bf557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab33e010d4cd421e1bdde9008fcb0ca" id="r_a7ab33e010d4cd421e1bdde9008fcb0ca"><td class="memTemplParams" colspan="2"><a id="a7ab33e010d4cd421e1bdde9008fcb0ca" name="a7ab33e010d4cd421e1bdde9008fcb0ca"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ab33e010d4cd421e1bdde9008fcb0ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasClassIdentifier</b> = std::disjunction&lt;HasClassIdentifierUpper&lt;T&gt;, HasClassIdentifierLower&lt;T&gt;&gt;</td></tr>
<tr class="separator:a7ab33e010d4cd421e1bdde9008fcb0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba30a4786bb014d0398323f6e602378" id="r_a2ba30a4786bb014d0398323f6e602378"><td class="memTemplParams" colspan="2"><a id="a2ba30a4786bb014d0398323f6e602378" name="a2ba30a4786bb014d0398323f6e602378"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ba30a4786bb014d0398323f6e602378"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasDataName</b> = is_detected_exact&lt;const std::string, detail::dataNameType, T&gt;</td></tr>
<tr class="separator:a2ba30a4786bb014d0398323f6e602378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e72a7827ed4af44cfdd53604e14d417" id="r_a2e72a7827ed4af44cfdd53604e14d417"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2e72a7827ed4af44cfdd53604e14d417"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e72a7827ed4af44cfdd53604e14d417">HasColorCodeUpper</a></td></tr>
<tr class="separator:a2e72a7827ed4af44cfdd53604e14d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48603c54e2435829ff923a16fb6f24f" id="r_ae48603c54e2435829ff923a16fb6f24f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae48603c54e2435829ff923a16fb6f24f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae48603c54e2435829ff923a16fb6f24f">HasColorCodeLower</a></td></tr>
<tr class="separator:ae48603c54e2435829ff923a16fb6f24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07144c582c6d20fd6ac21d58e540a001" id="r_a07144c582c6d20fd6ac21d58e540a001"><td class="memTemplParams" colspan="2"><a id="a07144c582c6d20fd6ac21d58e540a001" name="a07144c582c6d20fd6ac21d58e540a001"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a07144c582c6d20fd6ac21d58e540a001"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasColorCode</b> = std::disjunction&lt;HasColorCodeUpper&lt;T&gt;, HasColorCodeLower&lt;T&gt;&gt;</td></tr>
<tr class="separator:a07144c582c6d20fd6ac21d58e540a001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5aa2d2841bd2f1126316f3caacf80d" id="r_a9d5aa2d2841bd2f1126316f3caacf80d"><td class="memTemplParams" colspan="2"><a id="a9d5aa2d2841bd2f1126316f3caacf80d" name="a9d5aa2d2841bd2f1126316f3caacf80d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d5aa2d2841bd2f1126316f3caacf80d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasDataInfo</b> = is_detected_exact&lt;std::string, detail::dataInfoType, T&gt;</td></tr>
<tr class="separator:a9d5aa2d2841bd2f1126316f3caacf80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdec96c91291ceceeda4e6fcebb9d22" id="r_aecdec96c91291ceceeda4e6fcebb9d22"><td class="memTemplParams" colspan="2"><a id="aecdec96c91291ceceeda4e6fcebb9d22" name="aecdec96c91291ceceeda4e6fcebb9d22"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecdec96c91291ceceeda4e6fcebb9d22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasInfo</b> = is_detected_exact&lt;<a class="el" href="classinviwo_1_1Document.html">Document</a>, detail::infoType, T&gt;</td></tr>
<tr class="separator:aecdec96c91291ceceeda4e6fcebb9d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a63ab9cda788314e4a57788af20b8effd" id="r_a63ab9cda788314e4a57788af20b8effd"><td class="memItemLeft" align="right" valign="top"><a id="a63ab9cda788314e4a57788af20b8effd" name="a63ab9cda788314e4a57788af20b8effd"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>UseUnitPrefixes</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:a63ab9cda788314e4a57788af20b8effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a21db522a804cf93c00863b5dfd76f" id="r_af7a21db522a804cf93c00863b5dfd76f"><td class="memItemLeft" align="right" valign="top"><a id="af7a21db522a804cf93c00863b5dfd76f" name="af7a21db522a804cf93c00863b5dfd76f"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>TraversalDirection</b> { <b>Up</b>
, <b>Down</b>
 }</td></tr>
<tr class="separator:af7a21db522a804cf93c00863b5dfd76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aa2caf857929fd4da8450f78b1c4d9" id="r_a58aa2caf857929fd4da8450f78b1c4d9"><td class="memItemLeft" align="right" valign="top"><a id="a58aa2caf857929fd4da8450f78b1c4d9" name="a58aa2caf857929fd4da8450f78b1c4d9"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>VisitPattern</b> { <b>Pre</b>
, <b>Post</b>
 }</td></tr>
<tr class="separator:a58aa2caf857929fd4da8450f78b1c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d369980e91d789b8e912967f375ab4" id="r_ad5d369980e91d789b8e912967f375ab4"><td class="memItemLeft" align="right" valign="top"><a id="ad5d369980e91d789b8e912967f375ab4" name="ad5d369980e91d789b8e912967f375ab4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>DryRun</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:ad5d369980e91d789b8e912967f375ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7df44ff09cb0549d16a59863813359" id="r_a3b7df44ff09cb0549d16a59863813359"><td class="memItemLeft" align="right" valign="top"><a id="a3b7df44ff09cb0549d16a59863813359" name="a3b7df44ff09cb0549d16a59863813359"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>OverwriteState</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:a3b7df44ff09cb0549d16a59863813359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b7c5a6156793bd1e87dec727b16af2" id="r_a50b7c5a6156793bd1e87dec727b16af2"><td class="memItemLeft" align="right" valign="top"><a id="a50b7c5a6156793bd1e87dec727b16af2" name="a50b7c5a6156793bd1e87dec727b16af2"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>VolumeLaplacianPostProcessing</b> { <b>None</b>
, <b>Normalized</b>
, <b>SignNormalized</b>
, <b>Scaled</b>
 }</td></tr>
<tr class="separator:a50b7c5a6156793bd1e87dec727b16af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61328d8b81f3e51d9a98e3436be6f5b8" id="r_a61328d8b81f3e51d9a98e3436be6f5b8"><td class="memItemLeft" align="right" valign="top"><a id="a61328d8b81f3e51d9a98e3436be6f5b8" name="a61328d8b81f3e51d9a98e3436be6f5b8"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode</b> (std::span&lt; char &gt; s, bool url=false)</td></tr>
<tr class="separator:a61328d8b81f3e51d9a98e3436be6f5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c998106a20ec6705c7df7141ca0494" id="r_af2c998106a20ec6705c7df7141ca0494"><td class="memItemLeft" align="right" valign="top"><a id="af2c998106a20ec6705c7df7141ca0494" name="af2c998106a20ec6705c7df7141ca0494"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode_pem</b> (std::span&lt; char &gt; s)</td></tr>
<tr class="separator:af2c998106a20ec6705c7df7141ca0494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8371e1cc72aea9d4a112f5d8feaadb" id="r_a9f8371e1cc72aea9d4a112f5d8feaadb"><td class="memItemLeft" align="right" valign="top"><a id="a9f8371e1cc72aea9d4a112f5d8feaadb" name="a9f8371e1cc72aea9d4a112f5d8feaadb"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode_mime</b> (std::span&lt; char &gt; s)</td></tr>
<tr class="separator:a9f8371e1cc72aea9d4a112f5d8feaadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0721194f56ccea706c8eb3e5b1d2c38d" id="r_a0721194f56ccea706c8eb3e5b1d2c38d"><td class="memItemLeft" align="right" valign="top"><a id="a0721194f56ccea706c8eb3e5b1d2c38d" name="a0721194f56ccea706c8eb3e5b1d2c38d"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (std::string_view s, bool remove_linebreaks=false)</td></tr>
<tr class="separator:a0721194f56ccea706c8eb3e5b1d2c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad646944af1abb5d57419c279f02c2f0c" id="r_ad646944af1abb5d57419c279f02c2f0c"><td class="memItemLeft" align="right" valign="top"><a id="ad646944af1abb5d57419c279f02c2f0c" name="ad646944af1abb5d57419c279f02c2f0c"></a>
IVW_CORE_API std::optional&lt; mat4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBoxUnion</b> (const std::optional&lt; mat4 &gt; &amp;a, const std::optional&lt; mat4 &gt; &amp;b)</td></tr>
<tr class="separator:ad646944af1abb5d57419c279f02c2f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0123d642715c707b5cc76d11ca0bad95" id="r_a0123d642715c707b5cc76d11ca0bad95"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0123d642715c707b5cc76d11ca0bad95">boundingBox</a> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:a0123d642715c707b5cc76d11ca0bad95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212b4034a9b7f9090fb3cdf1ced7153d" id="r_a212b4034a9b7f9090fb3cdf1ced7153d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a212b4034a9b7f9090fb3cdf1ced7153d">boundingBox</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; &gt; &amp;layers)</td></tr>
<tr class="separator:a212b4034a9b7f9090fb3cdf1ced7153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a73f5197bbfc5940421cee5d8f5755" id="r_a74a73f5197bbfc5940421cee5d8f5755"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a73f5197bbfc5940421cee5d8f5755">boundingBox</a> (const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:a74a73f5197bbfc5940421cee5d8f5755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a49c8d7b70aa04748e46e77aaa4bf3" id="r_aa7a49c8d7b70aa04748e46e77aaa4bf3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a49c8d7b70aa04748e46e77aaa4bf3">boundingBox</a> (const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &gt; &amp;meshes)</td></tr>
<tr class="separator:aa7a49c8d7b70aa04748e46e77aaa4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b304bd97447cbc99865cf2a8bdc3a9" id="r_ac6b304bd97447cbc99865cf2a8bdc3a9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6b304bd97447cbc99865cf2a8bdc3a9">boundingBox</a> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:ac6b304bd97447cbc99865cf2a8bdc3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07503961e01f5f633c9f1a371b36d780" id="r_a07503961e01f5f633c9f1a371b36d780"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07503961e01f5f633c9f1a371b36d780">boundingBox</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &amp;volumes)</td></tr>
<tr class="separator:a07503961e01f5f633c9f1a371b36d780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125fdc1aa254554458167122ca14c08b" id="r_a125fdc1aa254554458167122ca14c08b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a125fdc1aa254554458167122ca14c08b">cubePlaneIntersectionAppend</a> (const <a class="el" href="classinviwo_1_1Plane.html">Plane</a> &amp;plane, std::vector&lt; vec3 &gt; &amp;pos, std::vector&lt; std::uint32_t &gt; &amp;inds)</td></tr>
<tr class="separator:a125fdc1aa254554458167122ca14c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325313545a3da575e7d59610adc77b5" id="r_a8325313545a3da575e7d59610adc77b5"><td class="memItemLeft" align="right" valign="top"><a id="a8325313545a3da575e7d59610adc77b5" name="a8325313545a3da575e7d59610adc77b5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>cubePlaneInstersection</b> (const <a class="el" href="classinviwo_1_1Plane.html">Plane</a> &amp;plane)</td></tr>
<tr class="separator:a8325313545a3da575e7d59610adc77b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfdf4a3d482622cdc4e0c93413d8882" id="r_a2bfdf4a3d482622cdc4e0c93413d8882"><td class="memTemplParams" colspan="2"><a id="a2bfdf4a3d482622cdc4e0c93413d8882" name="a2bfdf4a3d482622cdc4e0c93413d8882"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bfdf4a3d482622cdc4e0c93413d8882"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMap</b> (T val, glm::vec&lt; 2, T &gt; from, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:a2bfdf4a3d482622cdc4e0c93413d8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5758ff20b515082e53332a2df4085ad" id="r_ae5758ff20b515082e53332a2df4085ad"><td class="memTemplParams" colspan="2"><a id="ae5758ff20b515082e53332a2df4085ad" name="ae5758ff20b515082e53332a2df4085ad"></a>
template&lt;glm::length_t L, typename T &gt; </td></tr>
<tr class="memitem:ae5758ff20b515082e53332a2df4085ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::vec&lt; L, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMap</b> (glm::vec&lt; L, T &gt; val, glm::vec&lt; 2, T &gt; from, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:ae5758ff20b515082e53332a2df4085ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd3cc948e2a6a9380f01d967aeba6aa" id="r_abdd3cc948e2a6a9380f01d967aeba6aa"><td class="memTemplParams" colspan="2"><a id="abdd3cc948e2a6a9380f01d967aeba6aa" name="abdd3cc948e2a6a9380f01d967aeba6aa"></a>
template&lt;glm::length_t C, glm::length_t R, typename T &gt; </td></tr>
<tr class="memitem:abdd3cc948e2a6a9380f01d967aeba6aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::mat&lt; C, R, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMap</b> (glm::mat&lt; C, R, T &gt; val, glm::vec&lt; 2, T &gt; from, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:abdd3cc948e2a6a9380f01d967aeba6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f266dd81c7151d6857b280e26562cf" id="r_af4f266dd81c7151d6857b280e26562cf"><td class="memTemplParams" colspan="2"><a id="af4f266dd81c7151d6857b280e26562cf" name="af4f266dd81c7151d6857b280e26562cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4f266dd81c7151d6857b280e26562cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapToNormalized</b> (T val, glm::vec&lt; 2, T &gt; from) noexcept</td></tr>
<tr class="separator:af4f266dd81c7151d6857b280e26562cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac082a7f127600f0b57b4456d62540843" id="r_ac082a7f127600f0b57b4456d62540843"><td class="memTemplParams" colspan="2"><a id="ac082a7f127600f0b57b4456d62540843" name="ac082a7f127600f0b57b4456d62540843"></a>
template&lt;glm::length_t L, typename T &gt; </td></tr>
<tr class="memitem:ac082a7f127600f0b57b4456d62540843"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::vec&lt; L, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapToNormalized</b> (glm::vec&lt; L, T &gt; val, glm::vec&lt; 2, T &gt; from) noexcept</td></tr>
<tr class="separator:ac082a7f127600f0b57b4456d62540843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9d45b7c63c2995d3733f271b1f8adf" id="r_aba9d45b7c63c2995d3733f271b1f8adf"><td class="memTemplParams" colspan="2"><a id="aba9d45b7c63c2995d3733f271b1f8adf" name="aba9d45b7c63c2995d3733f271b1f8adf"></a>
template&lt;glm::length_t C, glm::length_t R, typename T &gt; </td></tr>
<tr class="memitem:aba9d45b7c63c2995d3733f271b1f8adf"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::mat&lt; C, R, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapToNormalized</b> (glm::mat&lt; C, R, T &gt; val, glm::vec&lt; 2, T &gt; from) noexcept</td></tr>
<tr class="separator:aba9d45b7c63c2995d3733f271b1f8adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05c3773b68b1e83ed4e34429afddf66" id="r_ae05c3773b68b1e83ed4e34429afddf66"><td class="memTemplParams" colspan="2"><a id="ae05c3773b68b1e83ed4e34429afddf66" name="ae05c3773b68b1e83ed4e34429afddf66"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae05c3773b68b1e83ed4e34429afddf66"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapFromNormalized</b> (T val, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:ae05c3773b68b1e83ed4e34429afddf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cfb827c9adca6e61b59e8839d1ba03" id="r_aa7cfb827c9adca6e61b59e8839d1ba03"><td class="memTemplParams" colspan="2"><a id="aa7cfb827c9adca6e61b59e8839d1ba03" name="aa7cfb827c9adca6e61b59e8839d1ba03"></a>
template&lt;glm::length_t L, typename T &gt; </td></tr>
<tr class="memitem:aa7cfb827c9adca6e61b59e8839d1ba03"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::vec&lt; L, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapFromNormalized</b> (glm::vec&lt; L, T &gt; val, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:aa7cfb827c9adca6e61b59e8839d1ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33395e1e9955d9d5b00384084b8f764b" id="r_a33395e1e9955d9d5b00384084b8f764b"><td class="memTemplParams" colspan="2"><a id="a33395e1e9955d9d5b00384084b8f764b" name="a33395e1e9955d9d5b00384084b8f764b"></a>
template&lt;glm::length_t C, glm::length_t R, typename T &gt; </td></tr>
<tr class="memitem:a33395e1e9955d9d5b00384084b8f764b"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::mat&lt; C, R, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapFromNormalized</b> (glm::mat&lt; C, R, T &gt; val, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:a33395e1e9955d9d5b00384084b8f764b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84a9ec3e9841aca2ea06fa34aaaed50" id="r_ae84a9ec3e9841aca2ea06fa34aaaed50"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1Document.html">Document</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae84a9ec3e9841aca2ea06fa34aaaed50">md2doc</a> (std::string_view markdown)</td></tr>
<tr class="separator:ae84a9ec3e9841aca2ea06fa34aaaed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e303f4a0c646b1328474d4df906e534" id="r_a7e303f4a0c646b1328474d4df906e534"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1Document.html">Document</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e303f4a0c646b1328474d4df906e534">unindentMd2doc</a> (std::string_view markdown)</td></tr>
<tr class="separator:a7e303f4a0c646b1328474d4df906e534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b7574c90a17ef8edcc49ddd56aa365" id="r_a06b7574c90a17ef8edcc49ddd56aa365"><td class="memTemplParams" colspan="2"><a id="a06b7574c90a17ef8edcc49ddd56aa365" name="a06b7574c90a17ef8edcc49ddd56aa365"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06b7574c90a17ef8edcc49ddd56aa365"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeVectorRange</b> (ptrdiff_t start, ptrdiff_t end, ptrdiff_t step=1)</td></tr>
<tr class="separator:a06b7574c90a17ef8edcc49ddd56aa365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b664cc070dc26eea89e55b8f62e2137" id="r_a2b664cc070dc26eea89e55b8f62e2137"><td class="memTemplParams" colspan="2"><a id="a2b664cc070dc26eea89e55b8f62e2137" name="a2b664cc070dc26eea89e55b8f62e2137"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2b664cc070dc26eea89e55b8f62e2137"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Permutations</b> (std::span&lt; T, N &gt;, size_t) -&gt; Permutations&lt; T &gt;</td></tr>
<tr class="separator:a2b664cc070dc26eea89e55b8f62e2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be78c1477b66628e85a4683ffc396ac" id="r_a1be78c1477b66628e85a4683ffc396ac"><td class="memTemplParams" colspan="2"><a id="a1be78c1477b66628e85a4683ffc396ac" name="a1be78c1477b66628e85a4683ffc396ac"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a1be78c1477b66628e85a4683ffc396ac"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Combinations</b> (std::span&lt; T, N &gt;, size_t) -&gt; Combinations&lt; T &gt;</td></tr>
<tr class="separator:a1be78c1477b66628e85a4683ffc396ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf4804f512902d5845ab36b69f0f4c" id="r_ab9bf4804f512902d5845ab36b69f0f4c"><td class="memTemplParams" colspan="2"><a id="ab9bf4804f512902d5845ab36b69f0f4c" name="ab9bf4804f512902d5845ab36b69f0f4c"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab9bf4804f512902d5845ab36b69f0f4c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexProduct</b> (std::span&lt; T, N &gt;) -&gt; IndexProduct&lt; T &gt;</td></tr>
<tr class="separator:ab9bf4804f512902d5845ab36b69f0f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba248938bdec0647ee6706ea2ece4c8c" id="r_aba248938bdec0647ee6706ea2ece4c8c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba248938bdec0647ee6706ea2ece4c8c">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *)</td></tr>
<tr class="separator:aba248938bdec0647ee6706ea2ece4c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608356f2ce89e1326c5ab6910337a907" id="r_a608356f2ce89e1326c5ab6910337a907"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a608356f2ce89e1326c5ab6910337a907">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *)</td></tr>
<tr class="separator:a608356f2ce89e1326c5ab6910337a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baa816930736caaf0d8b9f4e0733723" id="r_a0baa816930736caaf0d8b9f4e0733723"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0baa816930736caaf0d8b9f4e0733723">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> *)</td></tr>
<tr class="separator:a0baa816930736caaf0d8b9f4e0733723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab66fbd51685a6de63dfd0e06b89013" id="r_a6ab66fbd51685a6de63dfd0e06b89013"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab66fbd51685a6de63dfd0e06b89013">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *)</td></tr>
<tr class="separator:a6ab66fbd51685a6de63dfd0e06b89013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458419095875341f984870e6f8e9fd13" id="r_a458419095875341f984870e6f8e9fd13"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a458419095875341f984870e6f8e9fd13">getInviwoApplication</a> ()</td></tr>
<tr class="separator:a458419095875341f984870e6f8e9fd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d6ed95184ff0ae2c68b501dcd0cff" id="r_a819d6ed95184ff0ae2c68b501dcd0cff"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819d6ed95184ff0ae2c68b501dcd0cff">isInviwoApplicationInitialized</a> ()</td></tr>
<tr class="separator:a819d6ed95184ff0ae2c68b501dcd0cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cc48e4cef1ca0ef24a274fc8b444d9" id="r_a04cc48e4cef1ca0ef24a274fc8b444d9"><td class="memItemLeft" align="right" valign="top"><a id="a04cc48e4cef1ca0ef24a274fc8b444d9" name="a04cc48e4cef1ca0ef24a274fc8b444d9"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Buffer.html">IndexBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeIndexBuffer</b> (std::vector&lt; std::uint32_t &gt; &amp;&amp;data)</td></tr>
<tr class="separator:a04cc48e4cef1ca0ef24a274fc8b444d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbce003fde844659f3fb7534b370d64c" id="r_acbce003fde844659f3fb7534b370d64c"><td class="memTemplParams" colspan="2"><a id="acbce003fde844659f3fb7534b370d64c" name="acbce003fde844659f3fb7534b370d64c"></a>
template&lt;typename T  = vec3, BufferUsage U = BufferUsage::Static, BufferTarget Target = BufferTarget::Data&gt; </td></tr>
<tr class="memitem:acbce003fde844659f3fb7534b370d64c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a>&lt; T, Target &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeBuffer</b> (std::vector&lt; T &gt; &amp;&amp;data)</td></tr>
<tr class="separator:acbce003fde844659f3fb7534b370d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37abc25e96c99f34aac8f37606c7df4" id="r_ad37abc25e96c99f34aac8f37606c7df4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad37abc25e96c99f34aac8f37606c7df4">getCameraFovProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty)</td></tr>
<tr class="memdesc:ad37abc25e96c99f34aac8f37606c7df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertical fov property in the cameraProperty.  <br /></td></tr>
<tr class="separator:ad37abc25e96c99f34aac8f37606c7df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1562123df97b5129796b73f231e1bd5" id="r_ad1562123df97b5129796b73f231e1bd5"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1562123df97b5129796b73f231e1bd5">createCameraFovProperty</a> (std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:ad1562123df97b5129796b73f231e1bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vertical fov property for use in a camera property.  <br /></td></tr>
<tr class="separator:ad1562123df97b5129796b73f231e1bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25faca6335f85635cde61c0986c2343" id="r_aa25faca6335f85635cde61c0986c2343"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25faca6335f85635cde61c0986c2343">updateOrCreateCameraFovProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty, std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:aa25faca6335f85635cde61c0986c2343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either return an existing vertical fov property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property.  <br /></td></tr>
<tr class="separator:aa25faca6335f85635cde61c0986c2343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfe78f266537021920d03efb74a15a3" id="r_a8cfe78f266537021920d03efb74a15a3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cfe78f266537021920d03efb74a15a3">getCameraWidthProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty)</td></tr>
<tr class="memdesc:a8cfe78f266537021920d03efb74a15a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the width property in the cameraProperty.  <br /></td></tr>
<tr class="separator:a8cfe78f266537021920d03efb74a15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cd42ede5eb2f1d94c2405c9f36c005" id="r_a53cd42ede5eb2f1d94c2405c9f36c005"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53cd42ede5eb2f1d94c2405c9f36c005">createCameraWidthProperty</a> (std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:a53cd42ede5eb2f1d94c2405c9f36c005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a width property for use in a <a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a>.  <br /></td></tr>
<tr class="separator:a53cd42ede5eb2f1d94c2405c9f36c005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27d645275cb437d22b94f20ddfe611a" id="r_ab27d645275cb437d22b94f20ddfe611a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab27d645275cb437d22b94f20ddfe611a">updateOrCreateCameraWidthProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty, std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:ab27d645275cb437d22b94f20ddfe611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either return an existing width property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property.  <br /></td></tr>
<tr class="separator:ab27d645275cb437d22b94f20ddfe611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae046e2b3232a4ce60452ccc5853efb9" id="r_aae046e2b3232a4ce60452ccc5853efb9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae046e2b3232a4ce60452ccc5853efb9">getCameraEyeOffsetProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty)</td></tr>
<tr class="memdesc:aae046e2b3232a4ce60452ccc5853efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the eye offset property in the cameraProperty.  <br /></td></tr>
<tr class="separator:aae046e2b3232a4ce60452ccc5853efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2a9a37232b9367cf8bc52093935b37" id="r_a5e2a9a37232b9367cf8bc52093935b37"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e2a9a37232b9367cf8bc52093935b37">createCameraEyeOffsetProperty</a> (std::function&lt; vec2()&gt; get, std::function&lt; void(const vec2 &amp;)&gt; set)</td></tr>
<tr class="memdesc:a5e2a9a37232b9367cf8bc52093935b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an eye offset property for use in a camera property.  <br /></td></tr>
<tr class="separator:a5e2a9a37232b9367cf8bc52093935b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d38c8a311e159b1bdb778697984dbe" id="r_aa4d38c8a311e159b1bdb778697984dbe"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d38c8a311e159b1bdb778697984dbe">updateOrCreateCameraEyeOffsetProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty, std::function&lt; vec2()&gt; get, std::function&lt; void(const vec2 &amp;)&gt; set)</td></tr>
<tr class="memdesc:aa4d38c8a311e159b1bdb778697984dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either return an existing eye offset property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property.  <br /></td></tr>
<tr class="separator:aa4d38c8a311e159b1bdb778697984dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7430ed5a7df8b460b6fdae1d9778ed7" id="r_ab7430ed5a7df8b460b6fdae1d9778ed7"><td class="memItemLeft" align="right" valign="top"><a id="ab7430ed5a7df8b460b6fdae1d9778ed7" name="ab7430ed5a7df8b460b6fdae1d9778ed7"></a>
IVW_CORE_API float&#160;</td><td class="memItemRight" valign="bottom"><b>fovyToWidth</b> (float fovy, float distance, float aspect)</td></tr>
<tr class="separator:ab7430ed5a7df8b460b6fdae1d9778ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869aff7fa775da8d091ab53335f07de" id="r_ac869aff7fa775da8d091ab53335f07de"><td class="memItemLeft" align="right" valign="top"><a id="ac869aff7fa775da8d091ab53335f07de" name="ac869aff7fa775da8d091ab53335f07de"></a>
IVW_CORE_API float&#160;</td><td class="memItemRight" valign="bottom"><b>widthToFovy</b> (float width, float distance, float aspect)</td></tr>
<tr class="separator:ac869aff7fa775da8d091ab53335f07de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76223fb253c738efe53ef628360a54b" id="r_ad76223fb253c738efe53ef628360a54b"><td class="memItemLeft" align="right" valign="top"><a id="ad76223fb253c738efe53ef628360a54b" name="ad76223fb253c738efe53ef628360a54b"></a>
IVW_CORE_API float&#160;</td><td class="memItemRight" valign="bottom"><b>widthToViewDist</b> (float width, float fov, float aspect)</td></tr>
<tr class="separator:ad76223fb253c738efe53ef628360a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916efff8c0f4ed2fd1774e7aac8b9265" id="r_a916efff8c0f4ed2fd1774e7aac8b9265"><td class="memTemplParams" colspan="2"><a id="a916efff8c0f4ed2fd1774e7aac8b9265" name="a916efff8c0f4ed2fd1774e7aac8b9265"></a>
template&lt;typename CamType &gt; </td></tr>
<tr class="memitem:a916efff8c0f4ed2fd1774e7aac8b9265"><td class="memTemplItemLeft" align="right" valign="top">vec3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>perspectiveZoom</b> (CamType &amp;cam, float factor, std::optional&lt; mat4 &gt;)</td></tr>
<tr class="separator:a916efff8c0f4ed2fd1774e7aac8b9265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f29a2adf6ba7edfe46f0bbf9a1e3c" id="r_a2b1f29a2adf6ba7edfe46f0bbf9a1e3c"><td class="memTemplParams" colspan="2"><a id="a2b1f29a2adf6ba7edfe46f0bbf9a1e3c" name="a2b1f29a2adf6ba7edfe46f0bbf9a1e3c"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a2b1f29a2adf6ba7edfe46f0bbf9a1e3c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generateTransforms</b> (std::array&lt; <a class="el" href="namespaceinviwo.html#a5d5ef9c7cb55aff220f45ad7d5c891c8">CoordinateSpace</a>, N &gt; spaces)</td></tr>
<tr class="separator:a2b1f29a2adf6ba7edfe46f0bbf9a1e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a4fe15a6ce4e2858ff3d7333515866" id="r_a17a4fe15a6ce4e2858ff3d7333515866"><td class="memItemLeft" align="right" valign="top"><a id="a17a4fe15a6ce4e2858ff3d7333515866" name="a17a4fe15a6ce4e2858ff3d7333515866"></a>
IVW_CORE_API uvec3&#160;</td><td class="memItemRight" valign="bottom"><b>getDataFormatColor</b> (NumericType t, size_t comp, size_t size)</td></tr>
<tr class="separator:a17a4fe15a6ce4e2858ff3d7333515866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f205a4666ea62977429eb4a760e87b" id="r_ad9f205a4666ea62977429eb4a760e87b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f205a4666ea62977429eb4a760e87b">appendIfNotEmpty</a> (std::string_view a, std::string_view b)</td></tr>
<tr class="separator:ad9f205a4666ea62977429eb4a760e87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da507308ead7dfcf87057ee61d5f7bc" id="r_a4da507308ead7dfcf87057ee61d5f7bc"><td class="memItemLeft" align="right" valign="top"><a id="a4da507308ead7dfcf87057ee61d5f7bc" name="a4da507308ead7dfcf87057ee61d5f7bc"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfPrimitives</b> (DrawType dt, ConnectivityType ct, size_t indices)</td></tr>
<tr class="separator:a4da507308ead7dfcf87057ee61d5f7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7b00c8154ef230492a4910c6f79c58" id="r_a5a7b00c8154ef230492a4910c6f79c58"><td class="memItemLeft" align="right" valign="top"><a id="a5a7b00c8154ef230492a4910c6f79c58" name="a5a7b00c8154ef230492a4910c6f79c58"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfVerticesForPrimitive</b> (DrawType dt)</td></tr>
<tr class="separator:a5a7b00c8154ef230492a4910c6f79c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbf4900cecbb7eaca4bbb1d642b0284" id="r_a5dbf4900cecbb7eaca4bbb1d642b0284"><td class="memItemLeft" align="right" valign="top"><a id="a5dbf4900cecbb7eaca4bbb1d642b0284" name="a5dbf4900cecbb7eaca4bbb1d642b0284"></a>
IVW_CORE_API std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>calculatePercentiles</b> (const std::vector&lt; size_t &gt; &amp;hist, dvec2 range, size_t sum)</td></tr>
<tr class="separator:a5dbf4900cecbb7eaca4bbb1d642b0284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa869b00bc942efbca128e0cb8b084ff6" id="r_aa869b00bc942efbca128e0cb8b084ff6"><td class="memItemLeft" align="right" valign="top"><a id="aa869b00bc942efbca128e0cb8b084ff6" name="aa869b00bc942efbca128e0cb8b084ff6"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1Statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calculateHistogramStats</b> (const std::vector&lt; size_t &gt; &amp;hist)</td></tr>
<tr class="separator:aa869b00bc942efbca128e0cb8b084ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56ff35451c5eafad52c74568b0ae4f2" id="r_ae56ff35451c5eafad52c74568b0ae4f2"><td class="memTemplParams" colspan="2"><a id="ae56ff35451c5eafad52c74568b0ae4f2" name="ae56ff35451c5eafad52c74568b0ae4f2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae56ff35451c5eafad52c74568b0ae4f2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structinviwo_1_1Histogram1D.html">Histogram1D</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculateHistograms</b> (std::span&lt; const T &gt; data, const <a class="el" href="classinviwo_1_1DataMapper.html">DataMapper</a> &amp;dataMap, size_t bins)</td></tr>
<tr class="separator:ae56ff35451c5eafad52c74568b0ae4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd9efe91dbf2a0948f48cb2006efbe" id="r_aa6fd9efe91dbf2a0948f48cb2006efbe"><td class="memTemplParams" colspan="2"><a id="aa6fd9efe91dbf2a0948f48cb2006efbe" name="aa6fd9efe91dbf2a0948f48cb2006efbe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6fd9efe91dbf2a0948f48cb2006efbe"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; 4, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>applySwizzleMask</b> (const glm::vec&lt; 4, T &gt; &amp;value, const SwizzleMask &amp;swizzlemask)</td></tr>
<tr class="separator:aa6fd9efe91dbf2a0948f48cb2006efbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459b9f2146938f3a148047c59ecb7af" id="r_a8459b9f2146938f3a148047c59ecb7af"><td class="memItemLeft" align="right" valign="top"><a id="a8459b9f2146938f3a148047c59ecb7af" name="a8459b9f2146938f3a148047c59ecb7af"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>registerCoreRepresentations</b> (<a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> &amp;obj)</td></tr>
<tr class="separator:a8459b9f2146938f3a148047c59ecb7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342409a6d80362de7c0658f9a1a73a33" id="r_a342409a6d80362de7c0658f9a1a73a33"><td class="memItemLeft" align="right" valign="top"><a id="a342409a6d80362de7c0658f9a1a73a33" name="a342409a6d80362de7c0658f9a1a73a33"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>registerCoreRepresentations</b> (<a class="el" href="classinviwo_1_1RepresentationFactoryManager.html">RepresentationFactoryManager</a> &amp;obj)</td></tr>
<tr class="separator:a342409a6d80362de7c0658f9a1a73a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe00225936cd1b989a4f5eb6855e7c4" id="r_a3fe00225936cd1b989a4f5eb6855e7c4"><td class="memItemLeft" align="right" valign="top"><a id="a3fe00225936cd1b989a4f5eb6855e7c4" name="a3fe00225936cd1b989a4f5eb6855e7c4"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>distributeAlphaEvenly</b> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a3fe00225936cd1b989a4f5eb6855e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa968168071463db242384b63a4d17702" id="r_aa968168071463db242384b63a4d17702"><td class="memItemLeft" align="right" valign="top"><a id="aa968168071463db242384b63a4d17702" name="aa968168071463db242384b63a4d17702"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>distributePositionEvenly</b> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:aa968168071463db242384b63a4d17702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833fb2a28acd35e6be134baa81331fa" id="r_ad833fb2a28acd35e6be134baa81331fa"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad833fb2a28acd35e6be134baa81331fa">alignAlphaToMean</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:ad833fb2a28acd35e6be134baa81331fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92665c9b8c2cd085faf8e4b701edbdc7" id="r_a92665c9b8c2cd085faf8e4b701edbdc7"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92665c9b8c2cd085faf8e4b701edbdc7">alignAlphaToTop</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a92665c9b8c2cd085faf8e4b701edbdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f406a130b054515fd4dceb5b35b84ba" id="r_a2f406a130b054515fd4dceb5b35b84ba"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f406a130b054515fd4dceb5b35b84ba">alignAlphaToBottom</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a2f406a130b054515fd4dceb5b35b84ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd54c996575d2b47bea52c51ee3ec14" id="r_a6fd54c996575d2b47bea52c51ee3ec14"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd54c996575d2b47bea52c51ee3ec14">alignPositionToMean</a> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a6fd54c996575d2b47bea52c51ee3ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27792fd235656d42d7e286db7cdc4bd3" id="r_a27792fd235656d42d7e286db7cdc4bd3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27792fd235656d42d7e286db7cdc4bd3">alignPositionToLeft</a> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a27792fd235656d42d7e286db7cdc4bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886b02bc8bf08edc11981f255bdc9780" id="r_a886b02bc8bf08edc11981f255bdc9780"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a886b02bc8bf08edc11981f255bdc9780">alignPositionToRight</a> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a886b02bc8bf08edc11981f255bdc9780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7669f35617341a0ec4465acb3a0b4a93" id="r_a7669f35617341a0ec4465acb3a0b4a93"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7669f35617341a0ec4465acb3a0b4a93">interpolateAlpha</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a7669f35617341a0ec4465acb3a0b4a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3c9707e78b11bc105e3b2614f1621" id="r_a0cb3c9707e78b11bc105e3b2614f1621"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb3c9707e78b11bc105e3b2614f1621">flipPositions</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a0cb3c9707e78b11bc105e3b2614f1621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7304908bd837dfaff011544e102fd7be" id="r_a7304908bd837dfaff011544e102fd7be"><td class="memTemplParams" colspan="2"><a id="a7304908bd837dfaff011544e102fd7be" name="a7304908bd837dfaff011544e102fd7be"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a7304908bd837dfaff011544e102fd7be"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structinviwo_1_1Axis.html">Axis</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultAxes</b> ()</td></tr>
<tr class="separator:a7304908bd837dfaff011544e102fd7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9501a7975eb778dadfdf84c36b2e42" id="r_a5a9501a7975eb778dadfdf84c36b2e42"><td class="memItemLeft" align="right" valign="top"><a id="a5a9501a7975eb778dadfdf84c36b2e42" name="a5a9501a7975eb778dadfdf84c36b2e42"></a>
IVW_CORE_API unitgroups::EnabledGroups&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemUnitGroups</b> ()</td></tr>
<tr class="separator:a5a9501a7975eb778dadfdf84c36b2e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061d6f9bef87114a1d72695cb6c84a90" id="r_a061d6f9bef87114a1d72695cb6c84a90"><td class="memItemLeft" align="right" valign="top"><a id="a061d6f9bef87114a1d72695cb6c84a90" name="a061d6f9bef87114a1d72695cb6c84a90"></a>
IVW_CORE_API std::unordered_map&lt; units::detail::unit_data, std::vector&lt; <a class="el" href="structinviwo_1_1UnitDesc.html">UnitDesc</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitGroupsFor</b> (Unit unit, const unitgroups::EnabledGroups &amp;enabledGroups)</td></tr>
<tr class="separator:a061d6f9bef87114a1d72695cb6c84a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2934c7b85aa65ddcb66c9479835c9e" id="r_adb2934c7b85aa65ddcb66c9479835c9e"><td class="memItemLeft" align="right" valign="top"><a id="adb2934c7b85aa65ddcb66c9479835c9e" name="adb2934c7b85aa65ddcb66c9479835c9e"></a>
IVW_CORE_API std::pair&lt; double, std::vector&lt; std::tuple&lt; std::string_view, std::string_view, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findBestSetOfNamedUnits</b> (Unit unit, const unitgroups::EnabledGroups &amp;enabledGroups, UseUnitPrefixes usesPrefixes)</td></tr>
<tr class="separator:adb2934c7b85aa65ddcb66c9479835c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4108147afd8e9756d9268e33b47507ea" id="r_a4108147afd8e9756d9268e33b47507ea"><td class="memItemLeft" align="right" valign="top"><a id="a4108147afd8e9756d9268e33b47507ea" name="a4108147afd8e9756d9268e33b47507ea"></a>
IVW_CORE_API std::back_insert_iterator&lt; fmt::memory_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>formatUnitTo</b> (std::back_insert_iterator&lt; fmt::memory_buffer &gt; it, Unit unit, const unitgroups::EnabledGroups &amp;enabledGroups, UseUnitPrefixes usesPrefixes)</td></tr>
<tr class="separator:a4108147afd8e9756d9268e33b47507ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18afcb89dd78c0d803b13b0715a01d8b" id="r_a18afcb89dd78c0d803b13b0715a01d8b"><td class="memTemplParams" colspan="2"><a id="a18afcb89dd78c0d803b13b0715a01d8b" name="a18afcb89dd78c0d803b13b0715a01d8b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a18afcb89dd78c0d803b13b0715a01d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>printEvent</b> (std::ostream &amp;os, const std::string &amp;event, Args... args)</td></tr>
<tr class="separator:a18afcb89dd78c0d803b13b0715a01d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8db32f8dec48d42fd34e07e10456ca" id="r_a3a8db32f8dec48d42fd34e07e10456ca"><td class="memItemLeft" align="right" valign="top"><a id="a3a8db32f8dec48d42fd34e07e10456ca" name="a3a8db32f8dec48d42fd34e07e10456ca"></a>
void IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>readBytesIntoBuffer</b> (const std::filesystem::path &amp;file, size_t offset, size_t bytes, bool littleEndian, size_t elementSize, void *dest)</td></tr>
<tr class="separator:a3a8db32f8dec48d42fd34e07e10456ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4d4e6fe612ca06641d9354787759eb" id="r_a8a4d4e6fe612ca06641d9354787759eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a4d4e6fe612ca06641d9354787759eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a4d4e6fe612ca06641d9354787759eb">saveData</a> (const T &amp;data, const std::filesystem::path &amp;filePath, const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;extension, Overwrite overwrite)</td></tr>
<tr class="separator:a8a4d4e6fe612ca06641d9354787759eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e915887dd7afac4db322379b958423" id="r_a28e915887dd7afac4db322379b958423"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28e915887dd7afac4db322379b958423"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::filesystem::path &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28e915887dd7afac4db322379b958423">saveData</a> (const T &amp;data, const std::filesystem::path &amp;path, std::string_view name, const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;extensions, Overwrite overwrite)</td></tr>
<tr class="separator:a28e915887dd7afac4db322379b958423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3178732543e83efe73b75a9d07e48fec" id="r_a3178732543e83efe73b75a9d07e48fec"><td class="memItemLeft" align="right" valign="top"><a id="a3178732543e83efe73b75a9d07e48fec" name="a3178732543e83efe73b75a9d07e48fec"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveLayer</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer, const std::filesystem::path &amp;path, const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;extension=<a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a>())</td></tr>
<tr class="separator:a3178732543e83efe73b75a9d07e48fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2a60a6f5a408eb8a05f86cc2ddfef8" id="r_adf2a60a6f5a408eb8a05f86cc2ddfef8"><td class="memItemLeft" align="right" valign="top"><a id="adf2a60a6f5a408eb8a05f86cc2ddfef8" name="adf2a60a6f5a408eb8a05f86cc2ddfef8"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveLayer</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:adf2a60a6f5a408eb8a05f86cc2ddfef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae932354be8c75c369167164e2a241e4c" id="r_ae932354be8c75c369167164e2a241e4c"><td class="memTemplParams" colspan="2"><a id="ae932354be8c75c369167164e2a241e4c" name="ae932354be8c75c369167164e2a241e4c"></a>
template&lt;typename T , typename ValueGetter , typename IdGetter  = decltype(defaultIdGetter)&gt; </td></tr>
<tr class="memitem:ae932354be8c75c369167164e2a241e4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeContainerWrapper</b> (std::string_view key, ValueGetter valueGetter, IdGetter idGetter=defaultIdGetter)</td></tr>
<tr class="separator:ae932354be8c75c369167164e2a241e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d242ceccd576433a16ba3fb49b9015" id="r_a81d242ceccd576433a16ba3fb49b9015"><td class="memItemLeft" align="right" valign="top"><a id="a81d242ceccd576433a16ba3fb49b9015" name="a81d242ceccd576433a16ba3fb49b9015"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>renamePort</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Port.html">Port</a> *, std::string &gt; &gt; rules)</td></tr>
<tr class="separator:a81d242ceccd576433a16ba3fb49b9015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd1dc9d1b5331c6283334deec1a213" id="r_a33cd1dc9d1b5331c6283334deec1a213"><td class="memItemLeft" align="right" valign="top"><a id="a33cd1dc9d1b5331c6283334deec1a213" name="a33cd1dc9d1b5331c6283334deec1a213"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>renameProperty</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Property.html">Property</a> *, std::string &gt; &gt; rules, std::string path=&quot;Properties&quot;)</td></tr>
<tr class="separator:a33cd1dc9d1b5331c6283334deec1a213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1c0cb22b88b98acda2e4675f9b3a1" id="r_ab2b1c0cb22b88b98acda2e4675f9b3a1"><td class="memItemLeft" align="right" valign="top"><a id="ab2b1c0cb22b88b98acda2e4675f9b3a1" name="ab2b1c0cb22b88b98acda2e4675f9b3a1"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>changePropertyType</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Property.html">Property</a> *, std::string &gt; &gt; rules)</td></tr>
<tr class="separator:ab2b1c0cb22b88b98acda2e4675f9b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88c92e2f718ec5c0b0d4d9e709aaefe" id="r_ab88c92e2f718ec5c0b0d4d9e709aaefe"><td class="memItemLeft" align="right" valign="top"><a id="ab88c92e2f718ec5c0b0d4d9e709aaefe" name="ab88c92e2f718ec5c0b0d4d9e709aaefe"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectPredecessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ab88c92e2f718ec5c0b0d4d9e709aaefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406093b30abbcc88760e117872fac31f" id="r_a406093b30abbcc88760e117872fac31f"><td class="memItemLeft" align="right" valign="top"><a id="a406093b30abbcc88760e117872fac31f" name="a406093b30abbcc88760e117872fac31f"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectSuccessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a406093b30abbcc88760e117872fac31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4281907848129ace041135deee2e6" id="r_ac4a4281907848129ace041135deee2e6"><td class="memItemLeft" align="right" valign="top"><a id="ac4a4281907848129ace041135deee2e6" name="ac4a4281907848129ace041135deee2e6"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPredecessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ac4a4281907848129ace041135deee2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb8d1b84ba1196842c236e7e45b6cd9" id="r_a0bb8d1b84ba1196842c236e7e45b6cd9"><td class="memItemLeft" align="right" valign="top"><a id="a0bb8d1b84ba1196842c236e7e45b6cd9" name="a0bb8d1b84ba1196842c236e7e45b6cd9"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSuccessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a0bb8d1b84ba1196842c236e7e45b6cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8265d9e0a2ad906d2ffb7d2671efc65" id="r_ab8265d9e0a2ad906d2ffb7d2671efc65"><td class="memTemplParams" colspan="2"><a id="ab8265d9e0a2ad906d2ffb7d2671efc65" name="ab8265d9e0a2ad906d2ffb7d2671efc65"></a>
template&lt;TraversalDirection D, VisitPattern V, typename Func , typename <a class="el" href="namespaceinviwo.html#a0780518930e4f82763044068321c57f4ad7778d0c64b6ba21494c97f77a66885a">Filter</a>  = DefaultTraversalFilter&gt; </td></tr>
<tr class="memitem:ab8265d9e0a2ad906d2ffb7d2671efc65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>traverseNetwork</b> (std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;state, <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, Func f, <a class="el" href="namespaceinviwo.html#a0780518930e4f82763044068321c57f4ad7778d0c64b6ba21494c97f77a66885a">Filter</a> connectionFilter=<a class="el" href="structinviwo_1_1util_1_1DefaultTraversalFilter.html">DefaultTraversalFilter</a>{})</td></tr>
<tr class="separator:ab8265d9e0a2ad906d2ffb7d2671efc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a41b8c7fc838241322d10ec52760b4" id="r_aa5a41b8c7fc838241322d10ec52760b4"><td class="memItemLeft" align="right" valign="top"><a id="aa5a41b8c7fc838241322d10ec52760b4" name="aa5a41b8c7fc838241322d10ec52760b4"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>topologicalSortFiltered</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:aa5a41b8c7fc838241322d10ec52760b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b1f2a584ca159e869ee5666acef52" id="r_a049b1f2a584ca159e869ee5666acef52"><td class="memItemLeft" align="right" valign="top"><a id="a049b1f2a584ca159e869ee5666acef52" name="a049b1f2a584ca159e869ee5666acef52"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>topologicalSort</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:a049b1f2a584ca159e869ee5666acef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad4b58375e9767217d380b694a0f008" id="r_a1ad4b58375e9767217d380b694a0f008"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ad4b58375e9767217d380b694a0f008">getPositions</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors)</td></tr>
<tr class="separator:a1ad4b58375e9767217d380b694a0f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917b0dac4338ee41354df68a988d4bca" id="r_a917b0dac4338ee41354df68a988d4bca"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a917b0dac4338ee41354df68a988d4bca">getPositions</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:a917b0dac4338ee41354df68a988d4bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9814ba491ab54162a61144582fff0dbd" id="r_a9814ba491ab54162a61144582fff0dbd"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9814ba491ab54162a61144582fff0dbd">getCenterPosition</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors)</td></tr>
<tr class="separator:a9814ba491ab54162a61144582fff0dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930eff3a3f70e0c02c85a55c99c13166" id="r_a930eff3a3f70e0c02c85a55c99c13166"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a930eff3a3f70e0c02c85a55c99c13166">getCenterPosition</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:a930eff3a3f70e0c02c85a55c99c13166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8256eb5b33cde59a3e0d832b0569d323" id="r_a8256eb5b33cde59a3e0d832b0569d323"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8256eb5b33cde59a3e0d832b0569d323">getBoundingBox</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors)</td></tr>
<tr class="separator:a8256eb5b33cde59a3e0d832b0569d323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9c4d7699d86580d306484f30f7110d" id="r_ade9c4d7699d86580d306484f30f7110d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9c4d7699d86580d306484f30f7110d">getBoundingBox</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:ade9c4d7699d86580d306484f30f7110d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341a5fe91b0d7f378da017b90eb3779" id="r_a1341a5fe91b0d7f378da017b90eb3779"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1341a5fe91b0d7f378da017b90eb3779">offsetPosition</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors, ivec2 offset)</td></tr>
<tr class="separator:a1341a5fe91b0d7f378da017b90eb3779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fa91973f804cd02c1e28fb635202d1" id="r_af6fa91973f804cd02c1e28fb635202d1"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6fa91973f804cd02c1e28fb635202d1">setSelected</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors, bool selected)</td></tr>
<tr class="separator:af6fa91973f804cd02c1e28fb635202d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a34e87ebb373c7632a3308144a1fc8" id="r_a11a34e87ebb373c7632a3308144a1fc8"><td class="memItemLeft" align="right" valign="top"><a id="a11a34e87ebb373c7632a3308144a1fc8" name="a11a34e87ebb373c7632a3308144a1fc8"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>serializeSelected</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::ostream &amp;os, const std::filesystem::path &amp;refPath)</td></tr>
<tr class="separator:a11a34e87ebb373c7632a3308144a1fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d35bf328c84cfedc3dfd7976ae43a" id="r_a3c1d35bf328c84cfedc3dfd7976ae43a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c1d35bf328c84cfedc3dfd7976ae43a">appendPartialProcessorNetwork</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::istream &amp;is, const std::filesystem::path &amp;refPath, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, OffsetCallback offsetCallback=nullptr)</td></tr>
<tr class="separator:a3c1d35bf328c84cfedc3dfd7976ae43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0947636398083de9bd93535fcb73690" id="r_ae0947636398083de9bd93535fcb73690"><td class="memItemLeft" align="right" valign="top"><a id="ae0947636398083de9bd93535fcb73690" name="ae0947636398083de9bd93535fcb73690"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>appendProcessorNetwork</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *destinationNetwork, const std::filesystem::path &amp;workspaceFile, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:ae0947636398083de9bd93535fcb73690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852cf5397506063c368ab0149d04e35c" id="r_a852cf5397506063c368ab0149d04e35c"><td class="memItemLeft" align="right" valign="top"><a id="a852cf5397506063c368ab0149d04e35c" name="a852cf5397506063c368ab0149d04e35c"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>addProcessorOnConnection</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> &gt; processor, <a class="el" href="classinviwo_1_1PortConnection.html">PortConnection</a> connection)</td></tr>
<tr class="separator:a852cf5397506063c368ab0149d04e35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8469c3a2db5ca517b8c6ca21d4af2611" id="r_a8469c3a2db5ca517b8c6ca21d4af2611"><td class="memItemLeft" align="right" valign="top"><a id="a8469c3a2db5ca517b8c6ca21d4af2611" name="a8469c3a2db5ca517b8c6ca21d4af2611"></a>
IVW_CORE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replaceProcessor</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> &gt; newProcessor, <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *oldProcessor)</td></tr>
<tr class="separator:a8469c3a2db5ca517b8c6ca21d4af2611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0849ce36357ea23ee78ce17d4e86828f" id="r_a0849ce36357ea23ee78ce17d4e86828f"><td class="memItemLeft" align="right" valign="top"><a id="a0849ce36357ea23ee78ce17d4e86828f" name="a0849ce36357ea23ee78ce17d4e86828f"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>forEachWorkspaceInDirRecursive</b> (const std::filesystem::path &amp;path, std::function&lt; void(const std::filesystem::path &amp;)&gt; callback)</td></tr>
<tr class="separator:a0849ce36357ea23ee78ce17d4e86828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaf6207efb6d23b9de5b69a24876493" id="r_a0eaf6207efb6d23b9de5b69a24876493"><td class="memItemLeft" align="right" valign="top"><a id="a0eaf6207efb6d23b9de5b69a24876493" name="a0eaf6207efb6d23b9de5b69a24876493"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>updateWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, const std::filesystem::path &amp;path, DryRun dryRun, std::function&lt; void()&gt; updateGui=[]() {}, size_t current=0, size_t total=0)</td></tr>
<tr class="separator:a0eaf6207efb6d23b9de5b69a24876493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59000b623363065dd97ab6b0ef72b18" id="r_ab59000b623363065dd97ab6b0ef72b18"><td class="memItemLeft" align="right" valign="top"><a id="ab59000b623363065dd97ab6b0ef72b18" name="ab59000b623363065dd97ab6b0ef72b18"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>updateExampleWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, DryRun dryRun, std::function&lt; void()&gt; updateGui=[]() {})</td></tr>
<tr class="separator:ab59000b623363065dd97ab6b0ef72b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1fe9b020e3a318a840f7177b2e0148" id="r_afe1fe9b020e3a318a840f7177b2e0148"><td class="memItemLeft" align="right" valign="top"><a id="afe1fe9b020e3a318a840f7177b2e0148" name="afe1fe9b020e3a318a840f7177b2e0148"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>updateRegressionWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, DryRun dryRun, std::function&lt; void()&gt; updateGui=[]() {})</td></tr>
<tr class="separator:afe1fe9b020e3a318a840f7177b2e0148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac526048b608d9c8b31251eb6d4c633e4" id="r_ac526048b608d9c8b31251eb6d4c633e4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac526048b608d9c8b31251eb6d4c633e4">replaceSelectionWithCompositeProcessor</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;network)</td></tr>
<tr class="separator:ac526048b608d9c8b31251eb6d4c633e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c89b716938f61f15132ae42d6d4a16b" id="r_a4c89b716938f61f15132ae42d6d4a16b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c89b716938f61f15132ae42d6d4a16b">expandCompositeProcessorIntoNetwork</a> (<a class="el" href="classinviwo_1_1CompositeProcessor.html">CompositeProcessor</a> &amp;composite)</td></tr>
<tr class="separator:a4c89b716938f61f15132ae42d6d4a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e400fc2734a064a4b9257da2776893" id="r_ac1e400fc2734a064a4b9257da2776893"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1e400fc2734a064a4b9257da2776893">exportAllFiles</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;network, const std::filesystem::path &amp;dir, std::string_view nameTemplate, const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;candidateExtensions, Overwrite overwrite)</td></tr>
<tr class="separator:ac1e400fc2734a064a4b9257da2776893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b08b9b06ff9618dc41000a24d590ecc" id="r_a3b08b9b06ff9618dc41000a24d590ecc"><td class="memItemLeft" align="right" valign="top"><a id="a3b08b9b06ff9618dc41000a24d590ecc" name="a3b08b9b06ff9618dc41000a24d590ecc"></a>
<a class="el" href="classinviwo_1_1Tags.html">Tags</a> IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getPlatformTags</b> (const <a class="el" href="classinviwo_1_1Tags.html">Tags</a> &amp;t)</td></tr>
<tr class="separator:a3b08b9b06ff9618dc41000a24d590ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f0efd826c637426672e1c60dd26c52" id="r_a72f0efd826c637426672e1c60dd26c52"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API const <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f0efd826c637426672e1c60dd26c52">getMetaData</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a72f0efd826c637426672e1c60dd26c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c8c14214ac56aeafc8d0165333c57" id="r_af74c8c14214ac56aeafc8d0165333c57"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74c8c14214ac56aeafc8d0165333c57">getMetaData</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:af74c8c14214ac56aeafc8d0165333c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f521098da377963713d6db28a4d5f6e" id="r_a5f521098da377963713d6db28a4d5f6e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f521098da377963713d6db28a4d5f6e">getPosition</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a5f521098da377963713d6db28a4d5f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164993d46bdb58f8b16a943c65ae4b9c" id="r_a164993d46bdb58f8b16a943c65ae4b9c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164993d46bdb58f8b16a943c65ae4b9c">setPosition</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, ivec2 pos)</td></tr>
<tr class="separator:a164993d46bdb58f8b16a943c65ae4b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33720f81ed26a3562c7447ce9eb89288" id="r_a33720f81ed26a3562c7447ce9eb89288"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33720f81ed26a3562c7447ce9eb89288">isSelected</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a33720f81ed26a3562c7447ce9eb89288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78172b271a10c03a2bb4a1a41bbde23e" id="r_a78172b271a10c03a2bb4a1a41bbde23e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78172b271a10c03a2bb4a1a41bbde23e">setSelected</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, bool selected)</td></tr>
<tr class="separator:a78172b271a10c03a2bb4a1a41bbde23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743b3fa3cbde44118de690fe87a21113" id="r_a743b3fa3cbde44118de690fe87a21113"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a743b3fa3cbde44118de690fe87a21113"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a743b3fa3cbde44118de690fe87a21113">makeProcessor</a> (ivec2 pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a743b3fa3cbde44118de690fe87a21113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae521c3dff86b5ef56d2797786d2b95bf" id="r_ae521c3dff86b5ef56d2797786d2b95bf"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae521c3dff86b5ef56d2797786d2b95bf">getProcessorModule</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;app)</td></tr>
<tr class="memdesc:ae521c3dff86b5ef56d2797786d2b95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find which module that registered a processor.  <br /></td></tr>
<tr class="separator:ae521c3dff86b5ef56d2797786d2b95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edb2ff6faa4d51610458290ed1f45c5" id="r_a1edb2ff6faa4d51610458290ed1f45c5"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1edb2ff6faa4d51610458290ed1f45c5">getProcessorModule</a> (std::string_view classIdentifier, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;app)</td></tr>
<tr class="memdesc:a1edb2ff6faa4d51610458290ed1f45c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find which module that registered a processor.  <br /></td></tr>
<tr class="separator:a1edb2ff6faa4d51610458290ed1f45c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb4e1d0a952f2a8216385f68ac32178" id="r_a9bb4e1d0a952f2a8216385f68ac32178"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a9bb4e1d0a952f2a8216385f68ac32178"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bb4e1d0a952f2a8216385f68ac32178">trySetProperty</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *proc, std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, V &amp;&amp;val, bool recursive=false)</td></tr>
<tr class="memdesc:a9bb4e1d0a952f2a8216385f68ac32178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set a processor's property to a given value.  <br /></td></tr>
<tr class="separator:a9bb4e1d0a952f2a8216385f68ac32178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec54f1f2a92884f6dbee0f725a8c6f9" id="r_a0ec54f1f2a92884f6dbee0f725a8c6f9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec54f1f2a92884f6dbee0f725a8c6f9">getProcessorModuleIdentifier</a> (std::string_view classIdentifier, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;app)</td></tr>
<tr class="memdesc:a0ec54f1f2a92884f6dbee0f725a8c6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the module identifier of a registered processor.  <br /></td></tr>
<tr class="separator:a0ec54f1f2a92884f6dbee0f725a8c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49cedd9ee71ada8b2e5c822dce8fd4" id="r_acf49cedd9ee71ada8b2e5c822dce8fd4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1OptionPropertyOption.html">OptionPropertyIntOption</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf49cedd9ee71ada8b2e5c822dce8fd4">enumeratedOptions</a> (std::string_view name, size_t count, int start=0, int step=1)</td></tr>
<tr class="separator:acf49cedd9ee71ada8b2e5c822dce8fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3f90c8cfa64a0898b021cca551de05" id="r_ada3f90c8cfa64a0898b021cca551de05"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada3f90c8cfa64a0898b021cca551de05">ordinalColor</a> (float r, float g, float b, float a=1.0f, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:ada3f90c8cfa64a0898b021cca551de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81edf9b276066462960fe0b021067ac9" id="r_a81edf9b276066462960fe0b021067ac9"><td class="memItemLeft" align="right" valign="top"><a id="a81edf9b276066462960fe0b021067ac9" name="a81edf9b276066462960fe0b021067ac9"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordinalColor</b> (const vec4 &amp;value, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a81edf9b276066462960fe0b021067ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ddfe5e9aca53b4bdeca169d9c94238" id="r_a26ddfe5e9aca53b4bdeca169d9c94238"><td class="memItemLeft" align="right" valign="top"><a id="a26ddfe5e9aca53b4bdeca169d9c94238" name="a26ddfe5e9aca53b4bdeca169d9c94238"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordinalColor</b> (const vec3 &amp;value, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a26ddfe5e9aca53b4bdeca169d9c94238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad4ee6e4bff4e3a4c701bb0a2011c9" id="r_a68ad4ee6e4bff4e3a4c701bb0a2011c9"><td class="memItemLeft" align="right" valign="top"><a id="a68ad4ee6e4bff4e3a4c701bb0a2011c9" name="a68ad4ee6e4bff4e3a4c701bb0a2011c9"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordinalLight</b> (const vec3 &amp;pos, float min=-100.0, float max=100.0, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a68ad4ee6e4bff4e3a4c701bb0a2011c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58b65316e88fa13b51e3f2a3093b066" id="r_aa58b65316e88fa13b51e3f2a3093b066"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename U  = T&gt; </td></tr>
<tr class="memitem:aa58b65316e88fa13b51e3f2a3093b066"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa58b65316e88fa13b51e3f2a3093b066">ordinalSymmetricVector</a> (const T &amp;value={0}, const U &amp;minMax=U{100})</td></tr>
<tr class="separator:aa58b65316e88fa13b51e3f2a3093b066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3c7230deaaaa556873e2684e4303f" id="r_ae6c3c7230deaaaa556873e2684e4303f"><td class="memTemplParams" colspan="2">template&lt;typename T  = size_t, typename U  = T&gt; </td></tr>
<tr class="memitem:ae6c3c7230deaaaa556873e2684e4303f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6c3c7230deaaaa556873e2684e4303f">ordinalCount</a> (const T &amp;value=T{0}, const U &amp;max=U{100})</td></tr>
<tr class="separator:ae6c3c7230deaaaa556873e2684e4303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0d6260ee968193442da41efb8fff79" id="r_aec0d6260ee968193442da41efb8fff79"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename U  = T&gt; </td></tr>
<tr class="memitem:aec0d6260ee968193442da41efb8fff79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec0d6260ee968193442da41efb8fff79">ordinalLength</a> (const T &amp;value=T{0}, const U &amp;max=U{100})</td></tr>
<tr class="separator:aec0d6260ee968193442da41efb8fff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10672d3ce62a8142941c05a182ca335" id="r_ae10672d3ce62a8142941c05a182ca335"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename U  = T&gt; </td></tr>
<tr class="memitem:ae10672d3ce62a8142941c05a182ca335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae10672d3ce62a8142941c05a182ca335">ordinalScale</a> (const T &amp;value=T{0}, const U &amp;max=U{100})</td></tr>
<tr class="separator:ae10672d3ce62a8142941c05a182ca335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fe508315d93a69417c6ee9614303d6" id="r_a78fe508315d93a69417c6ee9614303d6"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalRefPropertyState.html">OrdinalRefPropertyState</a>&lt; vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78fe508315d93a69417c6ee9614303d6">ordinalRefColor</a> (<a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a78fe508315d93a69417c6ee9614303d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f57559577f5aec3ec856e38b2b4d58c" id="r_a6f57559577f5aec3ec856e38b2b4d58c"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename U  = T&gt; </td></tr>
<tr class="memitem:a6f57559577f5aec3ec856e38b2b4d58c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1OrdinalRefPropertyState.html">OrdinalRefPropertyState</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f57559577f5aec3ec856e38b2b4d58c">ordinalRefSymmetricVector</a> (const U &amp;minMax=U{100})</td></tr>
<tr class="separator:a6f57559577f5aec3ec856e38b2b4d58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47927175e2344c3b515b14d86e5c508e" id="r_a47927175e2344c3b515b14d86e5c508e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a47927175e2344c3b515b14d86e5c508e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47927175e2344c3b515b14d86e5c508e">updateDefaultState</a> (T &amp;property, const U &amp;state, OverwriteState overwrite)</td></tr>
<tr class="separator:a47927175e2344c3b515b14d86e5c508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f808c2136fe40a97e990458c0ca4231" id="r_a7f808c2136fe40a97e990458c0ca4231"><td class="memTemplParams" colspan="2"><a id="a7f808c2136fe40a97e990458c0ca4231" name="a7f808c2136fe40a97e990458c0ca4231"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a7f808c2136fe40a97e990458c0ca4231"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; const std::string_view, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultValues</b> ()</td></tr>
<tr class="separator:a7f808c2136fe40a97e990458c0ca4231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f02b27583f5e5189bf082ee8ec7ea" id="r_ab59f02b27583f5e5189bf082ee8ec7ea"><td class="memItemLeft" align="right" valign="top"><a id="ab59f02b27583f5e5189bf082ee8ec7ea" name="ab59f02b27583f5e5189bf082ee8ec7ea"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>debugBreak</b> ()</td></tr>
<tr class="separator:ab59f02b27583f5e5189bf082ee8ec7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7add893c040adf20aa7bfb32b6aa7" id="r_ac1a7add893c040adf20aa7bfb32b6aa7"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1a7add893c040adf20aa7bfb32b6aa7">reverse</a> (<a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> &amp;b)</td></tr>
<tr class="separator:ac1a7add893c040adf20aa7bfb32b6aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac161982c151dab1c0f48df711facdd0d" id="r_ac161982c151dab1c0f48df711facdd0d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a> &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac161982c151dab1c0f48df711facdd0d">getBuildInfo</a> ()</td></tr>
<tr class="memdesc:ac161982c151dab1c0f48df711facdd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses build information via an INI file or compile-time definitions.  <br /></td></tr>
<tr class="separator:ac161982c151dab1c0f48df711facdd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1136c71f85d4df4b2b2449aee7121b0" id="r_af1136c71f85d4df4b2b2449aee7121b0"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1136c71f85d4df4b2b2449aee7121b0">msToString</a> (double ms, bool includeZeros=true, bool spacing=false)</td></tr>
<tr class="memdesc:af1136c71f85d4df4b2b2449aee7121b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the given duration from milliseconds to a string. The returned string will have the format "%dd %dh %dmin %dsec %.3fms", where days, hours, minutes, seconds, ... are suppressed up to the first non-zero unit if not needed. Milliseconds and seconds are combined if larger than 1 second.  <br /></td></tr>
<tr class="separator:af1136c71f85d4df4b2b2449aee7121b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818947e6c0c72cbdeb18b6631686091b" id="r_a818947e6c0c72cbdeb18b6631686091b"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period  = std::ratio&lt;1&gt;&gt; </td></tr>
<tr class="memitem:a818947e6c0c72cbdeb18b6631686091b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a818947e6c0c72cbdeb18b6631686091b">durationToString</a> (std::chrono::duration&lt; Rep, Period &gt; duration, bool includeZeros=true, bool spacing=false)</td></tr>
<tr class="memdesc:a818947e6c0c72cbdeb18b6631686091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function for converting a std::chrono::duration to a string calling msToString(double).  <br /></td></tr>
<tr class="separator:a818947e6c0c72cbdeb18b6631686091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6454513ac3989576585452cfcc96ad32" id="r_a6454513ac3989576585452cfcc96ad32"><td class="memItemLeft" align="right" valign="top"><a id="a6454513ac3989576585452cfcc96ad32" name="a6454513ac3989576585452cfcc96ad32"></a>
constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>constexpr_hash</b> (std::string_view str) noexcept</td></tr>
<tr class="separator:a6454513ac3989576585452cfcc96ad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09726916a99e7ab3917ffb55d5155961" id="r_a09726916a99e7ab3917ffb55d5155961"><td class="memTemplParams" colspan="2"><a id="a09726916a99e7ab3917ffb55d5155961" name="a09726916a99e7ab3917ffb55d5155961"></a>
template&lt;size_t len&gt; </td></tr>
<tr class="memitem:a09726916a99e7ab3917ffb55d5155961"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_hash</b> (const char(&amp;str)[len]) noexcept</td></tr>
<tr class="separator:a09726916a99e7ab3917ffb55d5155961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d48f7460aa46b805b25b7c8802e1433" id="r_a2d48f7460aa46b805b25b7c8802e1433"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d48f7460aa46b805b25b7c8802e1433">demangle</a> (const char *name)</td></tr>
<tr class="separator:a2d48f7460aa46b805b25b7c8802e1433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cede42366cbed152e45d50fb16d062" id="r_a17cede42366cbed152e45d50fb16d062"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17cede42366cbed152e45d50fb16d062">parseTypeIdName</a> (const char *name)</td></tr>
<tr class="separator:a17cede42366cbed152e45d50fb16d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a685956d19cc067c95ae2abed5c621" id="r_a70a685956d19cc067c95ae2abed5c621"><td class="memTemplParams" colspan="2"><a id="a70a685956d19cc067c95ae2abed5c621" name="a70a685956d19cc067c95ae2abed5c621"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70a685956d19cc067c95ae2abed5c621"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>alwaysFalse</b> ()</td></tr>
<tr class="separator:a70a685956d19cc067c95ae2abed5c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfd07a246bca8b3fc3f3e243aaea23a" id="r_aebfd07a246bca8b3fc3f3e243aaea23a"><td class="memTemplParams" colspan="2"><a id="aebfd07a246bca8b3fc3f3e243aaea23a" name="aebfd07a246bca8b3fc3f3e243aaea23a"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1HasEnumName.html">HasEnumName</a>&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aebfd07a246bca8b3fc3f3e243aaea23a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enumName</b> ()</td></tr>
<tr class="separator:aebfd07a246bca8b3fc3f3e243aaea23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6b8dfc1fe3a44825c0a2dbbc2ae65a" id="r_aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Callback &gt; </td></tr>
<tr class="memitem:aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb6b8dfc1fe3a44825c0a2dbbc2ae65a">forEach</a> (const Iterable &amp;iterable, Callback &amp;&amp;callback)</td></tr>
<tr class="separator:aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5152f1acc0ccd5f17aef14a459df80b0" id="r_a5152f1acc0ccd5f17aef14a459df80b0"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Callback , typename OnDoneCallback &gt; </td></tr>
<tr class="memitem:a5152f1acc0ccd5f17aef14a459df80b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5152f1acc0ccd5f17aef14a459df80b0">forEachParallelAsync</a> (const Iterable &amp;iterable, Callback &amp;&amp;callback, size_t jobs, OnDoneCallback &amp;&amp;onTaskDone)</td></tr>
<tr class="separator:a5152f1acc0ccd5f17aef14a459df80b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67d76735eef23f9b566af1e6cadeff4" id="r_aa67d76735eef23f9b566af1e6cadeff4"><td class="memTemplParams" colspan="2"><a id="aa67d76735eef23f9b566af1e6cadeff4" name="aa67d76735eef23f9b566af1e6cadeff4"></a>
template&lt;typename Iterable , typename Callback &gt; </td></tr>
<tr class="memitem:aa67d76735eef23f9b566af1e6cadeff4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachParallelAsync</b> (const Iterable &amp;iterable, Callback &amp;&amp;callback, size_t jobs=0)</td></tr>
<tr class="separator:aa67d76735eef23f9b566af1e6cadeff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ba8edf9868ee32bb79ba5f1c1b114" id="r_adc3ba8edf9868ee32bb79ba5f1c1b114"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Callback &gt; </td></tr>
<tr class="memitem:adc3ba8edf9868ee32bb79ba5f1c1b114"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc3ba8edf9868ee32bb79ba5f1c1b114">forEachParallel</a> (const Iterable &amp;iterable, Callback &amp;&amp;callback, size_t jobs=0)</td></tr>
<tr class="separator:adc3ba8edf9868ee32bb79ba5f1c1b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b94d32a4f96dd412446b35fa058db6" id="r_a32b94d32a4f96dd412446b35fa058db6"><td class="memTemplParams" colspan="2"><a id="a32b94d32a4f96dd412446b35fa058db6" name="a32b94d32a4f96dd412446b35fa058db6"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:a32b94d32a4f96dd412446b35fa058db6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_argument</b> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a32b94d32a4f96dd412446b35fa058db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f343736e8083a8b38183038511368" id="r_a259f343736e8083a8b38183038511368"><td class="memTemplParams" colspan="2"><a id="a259f343736e8083a8b38183038511368" name="a259f343736e8083a8b38183038511368"></a>
template&lt;typename F , typename TupleType &gt; </td></tr>
<tr class="memitem:a259f343736e8083a8b38183038511368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_in_tuple</b> (F &amp;&amp;f, TupleType &amp;&amp;t)</td></tr>
<tr class="separator:a259f343736e8083a8b38183038511368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3c6a37ecf5dc4e89d4a99bd930f53" id="r_a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memTemplParams" colspan="2"><a id="a9bc3c6a37ecf5dc4e89d4a99bd930f53" name="a9bc3c6a37ecf5dc4e89d4a99bd930f53"></a>
template&lt;typename F , typename TupleType1 , typename TupleType2 &gt; </td></tr>
<tr class="memitem:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_in_tuple</b> (F &amp;&amp;f, TupleType1 &amp;&amp;t1, TupleType2 &amp;&amp;t2)</td></tr>
<tr class="separator:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca164bcff0db4b93cbc9de0eb812b2" id="r_a37ca164bcff0db4b93cbc9de0eb812b2"><td class="memItemLeft" align="right" valign="top"><a id="a37ca164bcff0db4b93cbc9de0eb812b2" name="a37ca164bcff0db4b93cbc9de0eb812b2"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_kilobytes</b> (size_t bytes)</td></tr>
<tr class="separator:a37ca164bcff0db4b93cbc9de0eb812b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d30c3f086e87522149945a4ffe73745" id="r_a1d30c3f086e87522149945a4ffe73745"><td class="memItemLeft" align="right" valign="top"><a id="a1d30c3f086e87522149945a4ffe73745" name="a1d30c3f086e87522149945a4ffe73745"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_megabytes</b> (size_t bytes)</td></tr>
<tr class="separator:a1d30c3f086e87522149945a4ffe73745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeca1d139ecb3cd31fc924e613bebc7" id="r_a4aeca1d139ecb3cd31fc924e613bebc7"><td class="memItemLeft" align="right" valign="top"><a id="a4aeca1d139ecb3cd31fc924e613bebc7" name="a4aeca1d139ecb3cd31fc924e613bebc7"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kilobytes_to_bytes</b> (size_t bytes)</td></tr>
<tr class="separator:a4aeca1d139ecb3cd31fc924e613bebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b4ec57df08fccd6dbeb93edd64614a" id="r_ae1b4ec57df08fccd6dbeb93edd64614a"><td class="memItemLeft" align="right" valign="top"><a id="ae1b4ec57df08fccd6dbeb93edd64614a" name="ae1b4ec57df08fccd6dbeb93edd64614a"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>megabytes_to_bytes</b> (size_t bytes)</td></tr>
<tr class="separator:ae1b4ec57df08fccd6dbeb93edd64614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0faf2bd22d3779355b4b8db67f3915" id="r_aed0faf2bd22d3779355b4b8db67f3915"><td class="memItemLeft" align="right" valign="top"><a id="aed0faf2bd22d3779355b4b8db67f3915" name="aed0faf2bd22d3779355b4b8db67f3915"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatBytesToString</b> (size_t bytes)</td></tr>
<tr class="separator:aed0faf2bd22d3779355b4b8db67f3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e029c8ccf362d845dfa9362adada1" id="r_acf3e029c8ccf362d845dfa9362adada1"><td class="memTemplParams" colspan="2"><a id="acf3e029c8ccf362d845dfa9362adada1" name="acf3e029c8ccf362d845dfa9362adada1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf3e029c8ccf362d845dfa9362adada1"><td class="memTemplItemLeft" align="right" valign="top">constexpr NumericType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getNumericType</b> ()</td></tr>
<tr class="separator:acf3e029c8ccf362d845dfa9362adada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f94054887b47451f416e2b60f9d248c" id="r_a5f94054887b47451f416e2b60f9d248c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API NumericType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f94054887b47451f416e2b60f9d248c">commonNumericType</a> (std::span&lt; const <a class="el" href="classinviwo_1_1DataFormatBase.html">DataFormatBase</a> * &gt; formats)</td></tr>
<tr class="separator:a5f94054887b47451f416e2b60f9d248c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b656c765eccf8074aa2adde7b031b09" id="r_a8b656c765eccf8074aa2adde7b031b09"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b656c765eccf8074aa2adde7b031b09">commonFormatPrecision</a> (std::span&lt; const <a class="el" href="classinviwo_1_1DataFormatBase.html">DataFormatBase</a> * &gt; formats)</td></tr>
<tr class="separator:a8b656c765eccf8074aa2adde7b031b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5780feabad27a979c9c92bc67cf6ada2" id="r_a5780feabad27a979c9c92bc67cf6ada2"><td class="memTemplParams" colspan="2"><a id="a5780feabad27a979c9c92bc67cf6ada2" name="a5780feabad27a979c9c92bc67cf6ada2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5780feabad27a979c9c92bc67cf6ada2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const T &amp;v)</td></tr>
<tr class="separator:a5780feabad27a979c9c92bc67cf6ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46823dad226364774c3e7f3b30ca21e9" id="r_a46823dad226364774c3e7f3b30ca21e9"><td class="memTemplParams" colspan="2"><a id="a46823dad226364774c3e7f3b30ca21e9" name="a46823dad226364774c3e7f3b30ca21e9"></a>
template&lt;glm::length_t L, typename T , glm::qualifier Q&gt; </td></tr>
<tr class="memitem:a46823dad226364774c3e7f3b30ca21e9"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; L, bool, Q &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const glm::vec&lt; L, T, Q &gt; &amp;x)</td></tr>
<tr class="separator:a46823dad226364774c3e7f3b30ca21e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc3d300d9eae79274e06a2ea8a5325" id="r_a47fc3d300d9eae79274e06a2ea8a5325"><td class="memTemplParams" colspan="2"><a id="a47fc3d300d9eae79274e06a2ea8a5325" name="a47fc3d300d9eae79274e06a2ea8a5325"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const T &amp;v)</td></tr>
<tr class="separator:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c6a37fda50958cd9ff741f12929524" id="r_a31c6a37fda50958cd9ff741f12929524"><td class="memTemplParams" colspan="2"><a id="a31c6a37fda50958cd9ff741f12929524" name="a31c6a37fda50958cd9ff741f12929524"></a>
template&lt;glm::length_t L, typename T , glm::qualifier Q&gt; </td></tr>
<tr class="memitem:a31c6a37fda50958cd9ff741f12929524"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; L, bool, Q &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const glm::vec&lt; L, T, Q &gt; &amp;x)</td></tr>
<tr class="separator:a31c6a37fda50958cd9ff741f12929524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fab874f7e075134d5dba1055797290" id="r_a95fab874f7e075134d5dba1055797290"><td class="memTemplParams" colspan="2"><a id="a95fab874f7e075134d5dba1055797290" name="a95fab874f7e075134d5dba1055797290"></a>
template&lt;class U , class T , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a95fab874f7e075134d5dba1055797290"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (T x, U init, BinaryOperation op)</td></tr>
<tr class="separator:a95fab874f7e075134d5dba1055797290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fefaba9a22bd05d70015036da90d4c" id="r_ad4fefaba9a22bd05d70015036da90d4c"><td class="memTemplParams" colspan="2"><a id="ad4fefaba9a22bd05d70015036da90d4c" name="ad4fefaba9a22bd05d70015036da90d4c"></a>
template&lt;glm::length_t L, class U , glm::qualifier Q, template&lt; glm::length_t, typename, glm::qualifier &gt; class vecType, class BinaryOperation &gt; </td></tr>
<tr class="memitem:ad4fefaba9a22bd05d70015036da90d4c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; vecType&lt; L, U, Q &gt; &gt;::value==1, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (const vecType&lt; L, U, Q &gt; &amp;x, U init, BinaryOperation op)</td></tr>
<tr class="separator:ad4fefaba9a22bd05d70015036da90d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7500ff0b335d6beee4027e7b13f97581" id="r_a7500ff0b335d6beee4027e7b13f97581"><td class="memTemplParams" colspan="2"><a id="a7500ff0b335d6beee4027e7b13f97581" name="a7500ff0b335d6beee4027e7b13f97581"></a>
template&lt;glm::length_t C, glm::length_t R, class U , glm::qualifier Q, template&lt; glm::length_t, glm::length_t, typename, glm::qualifier &gt; class vecType, class BinaryOperation &gt; </td></tr>
<tr class="memitem:a7500ff0b335d6beee4027e7b13f97581"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; vecType&lt; C, R, U, Q &gt; &gt;::value==2, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (const vecType&lt; C, R, U, Q &gt; &amp;x, U init, BinaryOperation op)</td></tr>
<tr class="separator:a7500ff0b335d6beee4027e7b13f97581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d0254070f7fb9aec6ff895d4a0bdc" id="r_a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memTemplParams" colspan="2"><a id="a325d0254070f7fb9aec6ff895d4a0bdc" name="a325d0254070f7fb9aec6ff895d4a0bdc"></a>
template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memTemplItemLeft" align="right" valign="top">Type1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invertY</b> (Type1 vec, Type2 dim)</td></tr>
<tr class="separator:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca39adef75ff36c5b3846a86e67269f" id="r_afca39adef75ff36c5b3846a86e67269f"><td class="memTemplParams" colspan="2"><a id="afca39adef75ff36c5b3846a86e67269f" name="afca39adef75ff36c5b3846a86e67269f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca39adef75ff36c5b3846a86e67269f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all</b> (const T &amp;t)</td></tr>
<tr class="separator:afca39adef75ff36c5b3846a86e67269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a5e593ad97ae54ea8fe10fb4e88e2f" id="r_a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memItemLeft" align="right" valign="top"><a id="a45a5e593ad97ae54ea8fe10fb4e88e2f" name="a45a5e593ad97ae54ea8fe10fb4e88e2f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all</b> (const bool &amp;t)</td></tr>
<tr class="separator:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe8554ac4434ebd0a96ebc1427b44b0" id="r_a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memTemplParams" colspan="2"><a id="a1fe8554ac4434ebd0a96ebc1427b44b0" name="a1fe8554ac4434ebd0a96ebc1427b44b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any</b> (const T &amp;t)</td></tr>
<tr class="separator:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee2ac139048aa0bc7f4d823ba6c26a4" id="r_a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memItemLeft" align="right" valign="top"><a id="a7ee2ac139048aa0bc7f4d823ba6c26a4" name="a7ee2ac139048aa0bc7f4d823ba6c26a4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any</b> (const bool &amp;t)</td></tr>
<tr class="separator:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b594a5638571d9e20783d8843f3c38" id="r_ad2b594a5638571d9e20783d8843f3c38"><td class="memTemplParams" colspan="2">template&lt;typename M , typename T  = typename M::value_type&gt; </td></tr>
<tr class="memitem:ad2b594a5638571d9e20783d8843f3c38"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2b594a5638571d9e20783d8843f3c38">filled</a> (T v)</td></tr>
<tr class="separator:ad2b594a5638571d9e20783d8843f3c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39455e5bf0802a86ac661f5cd43a2c96" id="r_a39455e5bf0802a86ac661f5cd43a2c96"><td class="memTemplParams" colspan="2"><a id="a39455e5bf0802a86ac661f5cd43a2c96" name="a39455e5bf0802a86ac661f5cd43a2c96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39455e5bf0802a86ac661f5cd43a2c96"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>epsilon</b> ()</td></tr>
<tr class="separator:a39455e5bf0802a86ac661f5cd43a2c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5743b44930aa236ce672a2a8d90075b5" id="r_a5743b44930aa236ce672a2a8d90075b5"><td class="memTemplParams" colspan="2"><a id="a5743b44930aa236ce672a2a8d90075b5" name="a5743b44930aa236ce672a2a8d90075b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5743b44930aa236ce672a2a8d90075b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>almostEqual</b> (const T &amp;x, const T &amp;y, int ulp=2)</td></tr>
<tr class="separator:a5743b44930aa236ce672a2a8d90075b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c1f79e8a30e77236196866d6aeb76b" id="r_a60c1f79e8a30e77236196866d6aeb76b"><td class="memTemplParams" colspan="2"><a id="a60c1f79e8a30e77236196866d6aeb76b" name="a60c1f79e8a30e77236196866d6aeb76b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60c1f79e8a30e77236196866d6aeb76b"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; 3, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transformPos</b> (const glm::mat&lt; 4, 4, T &gt; &amp;m, const glm::vec&lt; 3, T &gt; &amp;pos)</td></tr>
<tr class="separator:a60c1f79e8a30e77236196866d6aeb76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6526ab9d0876b578cfdccf0b1db7cbdc" id="r_a6526ab9d0876b578cfdccf0b1db7cbdc"><td class="memTemplParams" colspan="2"><a id="a6526ab9d0876b578cfdccf0b1db7cbdc" name="a6526ab9d0876b578cfdccf0b1db7cbdc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6526ab9d0876b578cfdccf0b1db7cbdc"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; 3, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transformNormal</b> (const glm::mat&lt; 4, 4, T &gt; &amp;modelViewMatrix, const glm::vec&lt; 3, T &gt; &amp;normal)</td></tr>
<tr class="separator:a6526ab9d0876b578cfdccf0b1db7cbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141644d95fac699b26e542dd8e9a06a" id="r_ad141644d95fac699b26e542dd8e9a06a"><td class="memTemplParams" colspan="2"><a id="ad141644d95fac699b26e542dd8e9a06a" name="ad141644d95fac699b26e542dd8e9a06a"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad141644d95fac699b26e542dd8e9a06a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (T &amp;elem, size_t) -&gt; T &amp;</td></tr>
<tr class="separator:ad141644d95fac699b26e542dd8e9a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e69e5cb6a27439895b97689f5f3f2ed" id="r_a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memTemplParams" colspan="2"><a id="a0e69e5cb6a27439895b97689f5f3f2ed" name="a0e69e5cb6a27439895b97689f5f3f2ed"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (const T &amp;elem, size_t i) -&gt; const typename T::value_type &amp;</td></tr>
<tr class="separator:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c813b4a28f97e89951e116d28a6664" id="r_a43c813b4a28f97e89951e116d28a6664"><td class="memTemplParams" colspan="2"><a id="a43c813b4a28f97e89951e116d28a6664" name="a43c813b4a28f97e89951e116d28a6664"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a43c813b4a28f97e89951e116d28a6664"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (T &amp;elem, size_t, size_t) -&gt; T &amp;</td></tr>
<tr class="separator:a43c813b4a28f97e89951e116d28a6664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3d34285fc06bf52759afd757fb61f" id="r_a05c3d34285fc06bf52759afd757fb61f"><td class="memTemplParams" colspan="2"><a id="a05c3d34285fc06bf52759afd757fb61f" name="a05c3d34285fc06bf52759afd757fb61f"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a05c3d34285fc06bf52759afd757fb61f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (const T &amp;elem, size_t i, size_t j) -&gt; const typename T::value_type &amp;</td></tr>
<tr class="separator:a05c3d34285fc06bf52759afd757fb61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4537176d57eb71d886558508d777f0b" id="r_af4537176d57eb71d886558508d777f0b"><td class="memTemplParams" colspan="2"><a id="af4537176d57eb71d886558508d777f0b" name="af4537176d57eb71d886558508d777f0b"></a>
template&lt;typename To  = double, typename From &gt; </td></tr>
<tr class="memitem:af4537176d57eb71d886558508d777f0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm_convert</b> (From x)</td></tr>
<tr class="separator:af4537176d57eb71d886558508d777f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2852cc61fd430ce9ac2abefc1c7edf56" id="r_a2852cc61fd430ce9ac2abefc1c7edf56"><td class="memTemplParams" colspan="2"><a id="a2852cc61fd430ce9ac2abefc1c7edf56" name="a2852cc61fd430ce9ac2abefc1c7edf56"></a>
template&lt;typename To  = double, typename From &gt; </td></tr>
<tr class="memitem:a2852cc61fd430ce9ac2abefc1c7edf56"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm_convert_normalized</b> (From x)</td></tr>
<tr class="separator:a2852cc61fd430ce9ac2abefc1c7edf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ca9372bd3a12d9a2579ac7c99c890" id="r_a903ca9372bd3a12d9a2579ac7c99c890"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a903ca9372bd3a12d9a2579ac7c99c890"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a903ca9372bd3a12d9a2579ac7c99c890">hash_combine</a> (std::size_t &amp;seed, const T &amp;v) noexcept</td></tr>
<tr class="separator:a903ca9372bd3a12d9a2579ac7c99c890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e9ce120322b1c4a80d7b5a15dda1f" id="r_afa0e9ce120322b1c4a80d7b5a15dda1f"><td class="memTemplParams" colspan="2"><a id="afa0e9ce120322b1c4a80d7b5a15dda1f" name="afa0e9ce120322b1c4a80d7b5a15dda1f"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afa0e9ce120322b1c4a80d7b5a15dda1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixel</b> (const size2_t dims, C callback)</td></tr>
<tr class="separator:afa0e9ce120322b1c4a80d7b5a15dda1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8843b349d3a16c4bc14bb9f2604229" id="r_adf8843b349d3a16c4bc14bb9f2604229"><td class="memTemplParams" colspan="2"><a id="adf8843b349d3a16c4bc14bb9f2604229" name="adf8843b349d3a16c4bc14bb9f2604229"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:adf8843b349d3a16c4bc14bb9f2604229"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixel</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &amp;layer, C callback)</td></tr>
<tr class="separator:adf8843b349d3a16c4bc14bb9f2604229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf7f75ddf74603a9c1d22f1dd14f06f" id="r_aacf7f75ddf74603a9c1d22f1dd14f06f"><td class="memTemplParams" colspan="2"><a id="aacf7f75ddf74603a9c1d22f1dd14f06f" name="aacf7f75ddf74603a9c1d22f1dd14f06f"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:aacf7f75ddf74603a9c1d22f1dd14f06f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixelParallel</b> (const size2_t dims, C callback, size_t jobs=0)</td></tr>
<tr class="separator:aacf7f75ddf74603a9c1d22f1dd14f06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed8f6b8d9311afc3ee6ee2f112b3e5b" id="r_afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memTemplParams" colspan="2"><a id="afed8f6b8d9311afc3ee6ee2f112b3e5b" name="afed8f6b8d9311afc3ee6ee2f112b3e5b"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixelParallel</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &amp;layer, C callback, size_t jobs=0)</td></tr>
<tr class="separator:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f5062b65dcfe3b90585892491ae766" id="r_aa6f5062b65dcfe3b90585892491ae766"><td class="memItemLeft" align="right" valign="top"><a id="aa6f5062b65dcfe3b90585892491ae766" name="aa6f5062b65dcfe3b90585892491ae766"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipLayerVertical</b> (<a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:aa6f5062b65dcfe3b90585892491ae766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bbe63ea03b1e65d776a1ec7e01e2c1" id="r_af1bbe63ea03b1e65d776a1ec7e01e2c1"><td class="memItemLeft" align="right" valign="top"><a id="af1bbe63ea03b1e65d776a1ec7e01e2c1" name="af1bbe63ea03b1e65d776a1ec7e01e2c1"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipLayerHorizontal</b> (<a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:af1bbe63ea03b1e65d776a1ec7e01e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f880ffbf2501e300a9ad61c94bdc13e" id="r_a4f880ffbf2501e300a9ad61c94bdc13e"><td class="memItemLeft" align="right" valign="top"><a id="a4f880ffbf2501e300a9ad61c94bdc13e" name="a4f880ffbf2501e300a9ad61c94bdc13e"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipImageVertical</b> (<a class="el" href="classinviwo_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:a4f880ffbf2501e300a9ad61c94bdc13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50f0d2c5925c59ac8a1ba911492586c" id="r_af50f0d2c5925c59ac8a1ba911492586c"><td class="memItemLeft" align="right" valign="top"><a id="af50f0d2c5925c59ac8a1ba911492586c" name="af50f0d2c5925c59ac8a1ba911492586c"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipImageHorizontal</b> (<a class="el" href="classinviwo_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:af50f0d2c5925c59ac8a1ba911492586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc379ba38f17b9b6764e03c78aaa6eb1" id="r_acc379ba38f17b9b6764e03c78aaa6eb1"><td class="memItemLeft" align="right" valign="top"><a id="acc379ba38f17b9b6764e03c78aaa6eb1" name="acc379ba38f17b9b6764e03c78aaa6eb1"></a>
IVW_CORE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readImageFromDisk</b> (std::string filename)</td></tr>
<tr class="separator:acc379ba38f17b9b6764e03c78aaa6eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246294ce0a3b7487f492874591b7841" id="r_af246294ce0a3b7487f492874591b7841"><td class="memTemplParams" colspan="2"><a id="af246294ce0a3b7487f492874591b7841" name="af246294ce0a3b7487f492874591b7841"></a>
template&lt;size_t N, typename IndexType  = size_t&gt; </td></tr>
<tr class="memitem:af246294ce0a3b7487f492874591b7841"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeIndexMapper</b> (const Vector&lt; N, IndexType &gt; &amp;dim)</td></tr>
<tr class="separator:af246294ce0a3b7487f492874591b7841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a518b92960df1752bebaa80ec50c61" id="r_a95a518b92960df1752bebaa80ec50c61"><td class="memTemplParams" colspan="2">template&lt;bool PropagateConst = true, typename Iter &gt; </td></tr>
<tr class="memitem:a95a518b92960df1752bebaa80ec50c61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a>&lt; Iter, PropagateConst &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95a518b92960df1752bebaa80ec50c61">makeIndirectIterator</a> (Iter iter) noexcept(std::is_nothrow_move_constructible_v&lt; Iter &gt;)</td></tr>
<tr class="separator:a95a518b92960df1752bebaa80ec50c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f14f5355cd5f4226b2ed543111a88a5" id="r_a6f14f5355cd5f4226b2ed543111a88a5"><td class="memTemplParams" colspan="2"><a id="a6f14f5355cd5f4226b2ed543111a88a5" name="a6f14f5355cd5f4226b2ed543111a88a5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f14f5355cd5f4226b2ed543111a88a5"><td class="memTemplItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>classIdentifier</b> ()</td></tr>
<tr class="separator:a6f14f5355cd5f4226b2ed543111a88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2d0b4fcb0533981da56e4e1dfdf8db" id="r_aee2d0b4fcb0533981da56e4e1dfdf8db"><td class="memTemplParams" colspan="2"><a id="aee2d0b4fcb0533981da56e4e1dfdf8db" name="aee2d0b4fcb0533981da56e4e1dfdf8db"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee2d0b4fcb0533981da56e4e1dfdf8db"><td class="memTemplItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataName</b> ()</td></tr>
<tr class="separator:aee2d0b4fcb0533981da56e4e1dfdf8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43295d437e6b3ac2ddf5953617696232" id="r_a43295d437e6b3ac2ddf5953617696232"><td class="memTemplParams" colspan="2"><a id="a43295d437e6b3ac2ddf5953617696232" name="a43295d437e6b3ac2ddf5953617696232"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43295d437e6b3ac2ddf5953617696232"><td class="memTemplItemLeft" align="right" valign="top">uvec3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>colorCode</b> ()</td></tr>
<tr class="separator:a43295d437e6b3ac2ddf5953617696232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c8d9edb1b87b683609454a60e7dde" id="r_aef0c8d9edb1b87b683609454a60e7dde"><td class="memTemplParams" colspan="2"><a id="aef0c8d9edb1b87b683609454a60e7dde" name="aef0c8d9edb1b87b683609454a60e7dde"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef0c8d9edb1b87b683609454a60e7dde"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_info</b> (const T *data)</td></tr>
<tr class="separator:aef0c8d9edb1b87b683609454a60e7dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea670d98ef52707b5b30f1a36b333da" id="r_abea670d98ef52707b5b30f1a36b333da"><td class="memTemplParams" colspan="2"><a id="abea670d98ef52707b5b30f1a36b333da" name="abea670d98ef52707b5b30f1a36b333da"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abea670d98ef52707b5b30f1a36b333da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1Document.html">Document</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>info</b> (const T &amp;data)</td></tr>
<tr class="separator:abea670d98ef52707b5b30f1a36b333da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f91d2006f1843504325bd721bbe515d" id="r_a5f91d2006f1843504325bd721bbe515d"><td class="memTemplParams" colspan="2"><a id="a5f91d2006f1843504325bd721bbe515d" name="a5f91d2006f1843504325bd721bbe515d"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a5f91d2006f1843504325bd721bbe515d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (Iter begin, Iter end)</td></tr>
<tr class="separator:a5f91d2006f1843504325bd721bbe515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7bbfcbfd1f31c50e554f0867860c79" id="r_aff7bbfcbfd1f31c50e554f0867860c79"><td class="memTemplParams" colspan="2"><a id="aff7bbfcbfd1f31c50e554f0867860c79" name="aff7bbfcbfd1f31c50e554f0867860c79"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aff7bbfcbfd1f31c50e554f0867860c79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (std::pair&lt; Iter, Iter &gt; const &amp;x)</td></tr>
<tr class="separator:aff7bbfcbfd1f31c50e554f0867860c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073bf64ff0dacce0c04d82ad13ff7cd9" id="r_a073bf64ff0dacce0c04d82ad13ff7cd9"><td class="memTemplParams" colspan="2"><a id="a073bf64ff0dacce0c04d82ad13ff7cd9" name="a073bf64ff0dacce0c04d82ad13ff7cd9"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a073bf64ff0dacce0c04d82ad13ff7cd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; typename Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (Container &amp;c)</td></tr>
<tr class="separator:a073bf64ff0dacce0c04d82ad13ff7cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b35cf2b4ff3575e9e49a95b9a3226e" id="r_a01b35cf2b4ff3575e9e49a95b9a3226e"><td class="memTemplParams" colspan="2"><a id="a01b35cf2b4ff3575e9e49a95b9a3226e" name="a01b35cf2b4ff3575e9e49a95b9a3226e"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a01b35cf2b4ff3575e9e49a95b9a3226e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; typename Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (const Container &amp;c)</td></tr>
<tr class="separator:a01b35cf2b4ff3575e9e49a95b9a3226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffe4e0cdc4f21f1460209c2e91e3cc1" id="r_a1ffe4e0cdc4f21f1460209c2e91e3cc1"><td class="memItemLeft" align="right" valign="top"><a id="a1ffe4e0cdc4f21f1460209c2e91e3cc1" name="a1ffe4e0cdc4f21f1460209c2e91e3cc1"></a>
void IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>configureCodePage</b> ()</td></tr>
<tr class="separator:a1ffe4e0cdc4f21f1460209c2e91e3cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969a21a4a5700b83983fd809c3a644a7" id="r_a969a21a4a5700b83983fd809c3a644a7"><td class="memItemLeft" align="right" valign="top"><a id="a969a21a4a5700b83983fd809c3a644a7" name="a969a21a4a5700b83983fd809c3a644a7"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (<a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a> context, std::string_view message, LogLevel level=LogLevel::Info, LogAudience audience=LogAudience::Developer)</td></tr>
<tr class="separator:a969a21a4a5700b83983fd809c3a644a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9c8ecb238bf5f82d5929d6e01db80d" id="r_add9c8ecb238bf5f82d5929d6e01db80d"><td class="memItemLeft" align="right" valign="top"><a id="add9c8ecb238bf5f82d5929d6e01db80d" name="add9c8ecb238bf5f82d5929d6e01db80d"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (<a class="el" href="classinviwo_1_1Logger.html">Logger</a> *logger, <a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a> context, std::string_view message, LogLevel level=LogLevel::Info, LogAudience audience=LogAudience::Developer)</td></tr>
<tr class="separator:add9c8ecb238bf5f82d5929d6e01db80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefacea9da9a4d2da2cd86fe21609108" id="r_aeefacea9da9a4d2da2cd86fe21609108"><td class="memTemplParams" colspan="2"><a id="aeefacea9da9a4d2da2cd86fe21609108" name="aeefacea9da9a4d2da2cd86fe21609108"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aeefacea9da9a4d2da2cd86fe21609108"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log</b> (<a class="el" href="classinviwo_1_1SourceContext.html">SourceContext</a> context, LogLevel level, LogAudience audience, fmt::format_string&lt; Args... &gt; format, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aeefacea9da9a4d2da2cd86fe21609108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad647d1457abea781ce1fe6c99cf9062d" id="r_ad647d1457abea781ce1fe6c99cf9062d"><td class="memTemplParams" colspan="2"><a id="ad647d1457abea781ce1fe6c99cf9062d" name="ad647d1457abea781ce1fe6c99cf9062d"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad647d1457abea781ce1fe6c99cf9062d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>logInfo</b> (<a class="el" href="classinviwo_1_1SourceContext.html">SourceContext</a> context, fmt::format_string&lt; Args... &gt; format, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad647d1457abea781ce1fe6c99cf9062d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635de1219b5347c2a0df3f86360aa3de" id="r_a635de1219b5347c2a0df3f86360aa3de"><td class="memTemplParams" colspan="2"><a id="a635de1219b5347c2a0df3f86360aa3de" name="a635de1219b5347c2a0df3f86360aa3de"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a635de1219b5347c2a0df3f86360aa3de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>logWarn</b> (<a class="el" href="classinviwo_1_1SourceContext.html">SourceContext</a> context, fmt::format_string&lt; Args... &gt; format, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a635de1219b5347c2a0df3f86360aa3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4806374488b6791f8c3197711a39094b" id="r_a4806374488b6791f8c3197711a39094b"><td class="memTemplParams" colspan="2"><a id="a4806374488b6791f8c3197711a39094b" name="a4806374488b6791f8c3197711a39094b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4806374488b6791f8c3197711a39094b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>logError</b> (<a class="el" href="classinviwo_1_1SourceContext.html">SourceContext</a> context, fmt::format_string&lt; Args... &gt; format, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a4806374488b6791f8c3197711a39094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a1e17c4af2f7dbff848e8b84486236" id="r_a77a1e17c4af2f7dbff848e8b84486236"><td class="memItemLeft" align="right" valign="top"><a id="a77a1e17c4af2f7dbff848e8b84486236" name="a77a1e17c4af2f7dbff848e8b84486236"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1ModuleManager.html">ModuleManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleManager</b> ()</td></tr>
<tr class="separator:a77a1e17c4af2f7dbff848e8b84486236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3712a04b10829a246838433a10cde6" id="r_a9e3712a04b10829a246838433a10cde6"><td class="memItemLeft" align="right" valign="top"><a id="a9e3712a04b10829a246838433a10cde6" name="a9e3712a04b10829a246838433a10cde6"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1ModuleManager.html">ModuleManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleManager</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a9e3712a04b10829a246838433a10cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899b626bb11facb96ac3f3fdccfa1062" id="r_a899b626bb11facb96ac3f3fdccfa1062"><td class="memItemLeft" align="right" valign="top"><a id="a899b626bb11facb96ac3f3fdccfa1062" name="a899b626bb11facb96ac3f3fdccfa1062"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleByIdentifier</b> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>)</td></tr>
<tr class="separator:a899b626bb11facb96ac3f3fdccfa1062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ab1a630e63e0fb54cd74c2fd5363c3" id="r_aa4ab1a630e63e0fb54cd74c2fd5363c3"><td class="memItemLeft" align="right" valign="top"><a id="aa4ab1a630e63e0fb54cd74c2fd5363c3" name="aa4ab1a630e63e0fb54cd74c2fd5363c3"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleByIdentifier</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>)</td></tr>
<tr class="separator:aa4ab1a630e63e0fb54cd74c2fd5363c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860f231522db52669f687eb284c24bd4" id="r_a860f231522db52669f687eb284c24bd4"><td class="memItemLeft" align="right" valign="top"><a id="a860f231522db52669f687eb284c24bd4" name="a860f231522db52669f687eb284c24bd4"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfModules</b> ()</td></tr>
<tr class="separator:a860f231522db52669f687eb284c24bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c5e8b0bd913cb52232fc473b09778f" id="r_a55c5e8b0bd913cb52232fc473b09778f"><td class="memItemLeft" align="right" valign="top"><a id="a55c5e8b0bd913cb52232fc473b09778f" name="a55c5e8b0bd913cb52232fc473b09778f"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfModules</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a55c5e8b0bd913cb52232fc473b09778f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66c784367358904bf1e6b116e50b885" id="r_aa66c784367358904bf1e6b116e50b885"><td class="memItemLeft" align="right" valign="top"><a id="aa66c784367358904bf1e6b116e50b885" name="aa66c784367358904bf1e6b116e50b885"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleByIndex</b> (size_t index)</td></tr>
<tr class="separator:aa66c784367358904bf1e6b116e50b885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af394b1251e7bf7f582d12cda768a1dfc" id="r_af394b1251e7bf7f582d12cda768a1dfc"><td class="memItemLeft" align="right" valign="top"><a id="af394b1251e7bf7f582d12cda768a1dfc" name="af394b1251e7bf7f582d12cda768a1dfc"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleByIndex</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, size_t index)</td></tr>
<tr class="separator:af394b1251e7bf7f582d12cda768a1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fe1665b10171457b63f4f37ba7a2e7" id="r_a19fe1665b10171457b63f4f37ba7a2e7"><td class="memItemLeft" align="right" valign="top"><a id="a19fe1665b10171457b63f4f37ba7a2e7" name="a19fe1665b10171457b63f4f37ba7a2e7"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getModulePath</b> (<a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *module)</td></tr>
<tr class="separator:a19fe1665b10171457b63f4f37ba7a2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db106165139c6f6f07d8ad89555a27b" id="r_a6db106165139c6f6f07d8ad89555a27b"><td class="memItemLeft" align="right" valign="top"><a id="a6db106165139c6f6f07d8ad89555a27b" name="a6db106165139c6f6f07d8ad89555a27b"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getModulePath</b> (<a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *module, ModulePath pathType)</td></tr>
<tr class="separator:a6db106165139c6f6f07d8ad89555a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03965ae6be1bd4270e8d4eaba85eb02b" id="r_a03965ae6be1bd4270e8d4eaba85eb02b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03965ae6be1bd4270e8d4eaba85eb02b">getModulePath</a> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, ModulePath pathType)</td></tr>
<tr class="memdesc:a03965ae6be1bd4270e8d4eaba85eb02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the path for a specific type located within the requested module  <br /></td></tr>
<tr class="separator:a03965ae6be1bd4270e8d4eaba85eb02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af3081ac4f0d91dee50c2fcfe91be9" id="r_a23af3081ac4f0d91dee50c2fcfe91be9"><td class="memItemLeft" align="right" valign="top"><a id="a23af3081ac4f0d91dee50c2fcfe91be9" name="a23af3081ac4f0d91dee50c2fcfe91be9"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getModulePath</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, ModulePath pathType)</td></tr>
<tr class="separator:a23af3081ac4f0d91dee50c2fcfe91be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2362077265ae910b0245de9fe3ca3231" id="r_a2362077265ae910b0245de9fe3ca3231"><td class="memItemLeft" align="right" valign="top"><a id="a2362077265ae910b0245de9fe3ca3231" name="a2362077265ae910b0245de9fe3ca3231"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getModulePath</b> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>)</td></tr>
<tr class="separator:a2362077265ae910b0245de9fe3ca3231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb98486a7e90613dfe879b14abd30e6" id="r_adfb98486a7e90613dfe879b14abd30e6"><td class="memItemLeft" align="right" valign="top"><a id="adfb98486a7e90613dfe879b14abd30e6" name="adfb98486a7e90613dfe879b14abd30e6"></a>
IVW_CORE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><b>getModulePath</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>)</td></tr>
<tr class="separator:adfb98486a7e90613dfe879b14abd30e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279574ee6793f5170cac05c64ca97e2" id="r_a6279574ee6793f5170cac05c64ca97e2"><td class="memTemplParams" colspan="2"><a id="a6279574ee6793f5170cac05c64ca97e2" name="a6279574ee6793f5170cac05c64ca97e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6279574ee6793f5170cac05c64ca97e2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getModuleByType</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a6279574ee6793f5170cac05c64ca97e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc204f3a2aad2feed2708e407b351756" id="r_adc204f3a2aad2feed2708e407b351756"><td class="memTemplParams" colspan="2"><a id="adc204f3a2aad2feed2708e407b351756" name="adc204f3a2aad2feed2708e407b351756"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adc204f3a2aad2feed2708e407b351756"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getModuleByType</b> ()</td></tr>
<tr class="separator:adc204f3a2aad2feed2708e407b351756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721fe3b2ce0d411ffcffee6e563357bd" id="r_a721fe3b2ce0d411ffcffee6e563357bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721fe3b2ce0d411ffcffee6e563357bd"><td class="memTemplItemLeft" align="right" valign="top">std::filesystem::path&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a721fe3b2ce0d411ffcffee6e563357bd">getModulePath</a> (ModulePath pathType)</td></tr>
<tr class="memdesc:a721fe3b2ce0d411ffcffee6e563357bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the path for a specific type located within the requested module of type T  <br /></td></tr>
<tr class="separator:a721fe3b2ce0d411ffcffee6e563357bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e47acd8f3f7ac23878bb39ddafdc7e1" id="r_a2e47acd8f3f7ac23878bb39ddafdc7e1"><td class="memTemplParams" colspan="2"><a id="a2e47acd8f3f7ac23878bb39ddafdc7e1" name="a2e47acd8f3f7ac23878bb39ddafdc7e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e47acd8f3f7ac23878bb39ddafdc7e1"><td class="memTemplItemLeft" align="right" valign="top">std::filesystem::path&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getModulePath</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, ModulePath pathType)</td></tr>
<tr class="separator:a2e47acd8f3f7ac23878bb39ddafdc7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0fd3611aa8a9a7c2e3dbf98335146c" id="r_afa0fd3611aa8a9a7c2e3dbf98335146c"><td class="memTemplParams" colspan="2"><a id="afa0fd3611aa8a9a7c2e3dbf98335146c" name="afa0fd3611aa8a9a7c2e3dbf98335146c"></a>
template&lt;class charT , class traits , class DelimT &gt; </td></tr>
<tr class="memitem:afa0fd3611aa8a9a7c2e3dbf98335146c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1util_1_1ostream__joiner.html">ostream_joiner</a>&lt; std::decay_t&lt; DelimT &gt;, charT, traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_ostream_joiner</b> (std::basic_ostream&lt; charT, traits &gt; &amp;os, DelimT &amp;&amp;delimiter)</td></tr>
<tr class="separator:afa0fd3611aa8a9a7c2e3dbf98335146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515b33c203ea126830f4bb9238bcaf1" id="r_a7515b33c203ea126830f4bb9238bcaf1"><td class="memTemplParams" colspan="2"><a id="a7515b33c203ea126830f4bb9238bcaf1" name="a7515b33c203ea126830f4bb9238bcaf1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7515b33c203ea126830f4bb9238bcaf1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetValue</b> (T &amp;t, T value)</td></tr>
<tr class="separator:a7515b33c203ea126830f4bb9238bcaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71ef5ebf3e6127ca2a819ef1ed62926" id="r_af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memTemplParams" colspan="2"><a id="af71ef5ebf3e6127ca2a819ef1ed62926" name="af71ef5ebf3e6127ca2a819ef1ed62926"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memTemplItemLeft" align="right" valign="top">OnScopeExit::ExitAction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RevertValue</b> (T &amp;t)</td></tr>
<tr class="separator:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538a9a4720640e9bb18b5b8a2000cb83" id="r_a538a9a4720640e9bb18b5b8a2000cb83"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a538a9a4720640e9bb18b5b8a2000cb83">getLibrarySearchPaths</a> ()</td></tr>
<tr class="memdesc:a538a9a4720640e9bb18b5b8a2000cb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns paths to search for module libraries. All platforms: executable directory and application modules directory (AppData/Inviwo/modules on windows). Platform dependent search directories: OSX: DYLD_LIBRARY_PATH UNIX: LD_LIBRARY_PATH/LD_RUN_PATH, RPATH and "executable directory
/../../lib".  <br /></td></tr>
<tr class="separator:a538a9a4720640e9bb18b5b8a2000cb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4805855bc6f8370faf1d0a4fcba862b" id="r_aa4805855bc6f8370faf1d0a4fcba862b"><td class="memTemplParams" colspan="2"><a id="aa4805855bc6f8370faf1d0a4fcba862b" name="aa4805855bc6f8370faf1d0a4fcba862b"></a>
template&lt;typename Derived , typename Base , typename Del &gt; </td></tr>
<tr class="memitem:aa4805855bc6f8370faf1d0a4fcba862b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived, Del &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_unique_ptr_cast</b> (std::unique_ptr&lt; Base, Del &gt; &amp;&amp;p)</td></tr>
<tr class="separator:aa4805855bc6f8370faf1d0a4fcba862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aee9509dafb895ed476086c7842d34" id="r_a10aee9509dafb895ed476086c7842d34"><td class="memTemplParams" colspan="2"><a id="a10aee9509dafb895ed476086c7842d34" name="a10aee9509dafb895ed476086c7842d34"></a>
template&lt;typename Derived , typename Base , typename Del &gt; </td></tr>
<tr class="memitem:a10aee9509dafb895ed476086c7842d34"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived, Del &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_unique_ptr_cast</b> (std::unique_ptr&lt; Base, Del &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a10aee9509dafb895ed476086c7842d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6b59173be1397d3042c99557326482" id="r_a3a6b59173be1397d3042c99557326482"><td class="memTemplParams" colspan="2"><a id="a3a6b59173be1397d3042c99557326482" name="a3a6b59173be1397d3042c99557326482"></a>
template&lt;typename Derived , typename Base &gt; </td></tr>
<tr class="memitem:a3a6b59173be1397d3042c99557326482"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_unique_ptr_cast</b> (std::unique_ptr&lt; Base, std::default_delete&lt; Base &gt; &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a3a6b59173be1397d3042c99557326482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7408d8a59968f771b7ad3dc0c75f28" id="r_a4c7408d8a59968f771b7ad3dc0c75f28"><td class="memTemplParams" colspan="2"><a id="a4c7408d8a59968f771b7ad3dc0c75f28" name="a4c7408d8a59968f771b7ad3dc0c75f28"></a>
template&lt;std::size_t N, typename Index  = size_t, typename Functor &gt; </td></tr>
<tr class="memitem:a4c7408d8a59968f771b7ad3dc0c75f28"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_array</b> (Functor &amp;&amp;func) noexcept -&gt; std::array&lt; decltype(func(std::declval&lt; Index &gt;())), N &gt;</td></tr>
<tr class="separator:a4c7408d8a59968f771b7ad3dc0c75f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8b12fa242507b1725c301a4ef5714e" id="r_a2e8b12fa242507b1725c301a4ef5714e"><td class="memTemplParams" colspan="2"><a id="a2e8b12fa242507b1725c301a4ef5714e" name="a2e8b12fa242507b1725c301a4ef5714e"></a>
template&lt;typename Common , typename... Ts&gt; </td></tr>
<tr class="memitem:a2e8b12fa242507b1725c301a4ef5714e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ref</b> (Ts &amp;... args)</td></tr>
<tr class="separator:a2e8b12fa242507b1725c301a4ef5714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90888f794252ba3891f368137a67369d" id="r_a90888f794252ba3891f368137a67369d"><td class="memTemplParams" colspan="2"><a id="a90888f794252ba3891f368137a67369d" name="a90888f794252ba3891f368137a67369d"></a>
template&lt;typename T , typename std::enable_if&lt;!std::is_abstract&lt; T &gt;::value &amp;&amp;std::is_default_constructible&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a90888f794252ba3891f368137a67369d"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultConstructType</b> ()</td></tr>
<tr class="separator:a90888f794252ba3891f368137a67369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b52a4904b65ef59d70ebf2b2b0ad7b0" id="r_a8b52a4904b65ef59d70ebf2b2b0ad7b0"><td class="memTemplParams" colspan="2"><a id="a8b52a4904b65ef59d70ebf2b2b0ad7b0" name="a8b52a4904b65ef59d70ebf2b2b0ad7b0"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a8b52a4904b65ef59d70ebf2b2b0ad7b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>overloaded</b> (Ts...) -&gt; overloaded&lt; Ts... &gt;</td></tr>
<tr class="separator:a8b52a4904b65ef59d70ebf2b2b0ad7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81e9808c5ba9826b5771e2542490bf" id="r_abf81e9808c5ba9826b5771e2542490bf"><td class="memTemplParams" colspan="2"><a id="abf81e9808c5ba9826b5771e2542490bf" name="abf81e9808c5ba9826b5771e2542490bf"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abf81e9808c5ba9826b5771e2542490bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_remove</b> (T &amp;cont, const V &amp;elem) -&gt; decltype(std::distance(std::declval&lt; T &gt;().begin(), std::declval&lt; T &gt;().end()))</td></tr>
<tr class="separator:abf81e9808c5ba9826b5771e2542490bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5262199109900b1b041fd1bb14a585f" id="r_af5262199109900b1b041fd1bb14a585f"><td class="memTemplParams" colspan="2"><a id="af5262199109900b1b041fd1bb14a585f" name="af5262199109900b1b041fd1bb14a585f"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:af5262199109900b1b041fd1bb14a585f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_remove_if</b> (T &amp;cont, Pred pred) -&gt; decltype(std::distance(std::declval&lt; T &gt;().begin(), std::declval&lt; T &gt;().end()))</td></tr>
<tr class="separator:af5262199109900b1b041fd1bb14a585f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212b8323ef0cad0985bb8032a8c3e32" id="r_a2212b8323ef0cad0985bb8032a8c3e32"><td class="memTemplParams" colspan="2"><a id="a2212b8323ef0cad0985bb8032a8c3e32" name="a2212b8323ef0cad0985bb8032a8c3e32"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_erase</b> (T &amp;cont)</td></tr>
<tr class="separator:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d14f127305d858d416c2fdb0c4ec0f" id="r_a81d14f127305d858d416c2fdb0c4ec0f"><td class="memTemplParams" colspan="2"><a id="a81d14f127305d858d416c2fdb0c4ec0f" name="a81d14f127305d858d416c2fdb0c4ec0f"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_erase_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439e115005151ce337820ffa1246e38" id="r_a5439e115005151ce337820ffa1246e38"><td class="memTemplParams" colspan="2"><a id="a5439e115005151ce337820ffa1246e38" name="a5439e115005151ce337820ffa1246e38"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a5439e115005151ce337820ffa1246e38"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_erase_remove_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a5439e115005151ce337820ffa1246e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba2e79134e4bf5de2c2851f3ddbabb1" id="r_a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memTemplParams" colspan="2"><a id="a4ba2e79134e4bf5de2c2851f3ddbabb1" name="a4ba2e79134e4bf5de2c2851f3ddbabb1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>push_back_unique</b> (T &amp;cont, typename T::value_type elem)</td></tr>
<tr class="separator:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea31612c6c30e23896ee3f18ee729c66" id="r_aea31612c6c30e23896ee3f18ee729c66"><td class="memTemplParams" colspan="2"><a id="aea31612c6c30e23896ee3f18ee729c66" name="aea31612c6c30e23896ee3f18ee729c66"></a>
template&lt;typename Dst , typename... Srcs&gt; </td></tr>
<tr class="memitem:aea31612c6c30e23896ee3f18ee729c66"><td class="memTemplItemLeft" align="right" valign="top">Dst &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append</b> (Dst &amp;dest, Srcs &amp;&amp;... sources)</td></tr>
<tr class="separator:aea31612c6c30e23896ee3f18ee729c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3403811241ba0b1d202ae0548baa272" id="r_ac3403811241ba0b1d202ae0548baa272"><td class="memTemplParams" colspan="2"><a id="ac3403811241ba0b1d202ae0548baa272" name="ac3403811241ba0b1d202ae0548baa272"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ac3403811241ba0b1d202ae0548baa272"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ac3403811241ba0b1d202ae0548baa272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb1874215836798aa939a09ea7097e5" id="r_a6cb1874215836798aa939a09ea7097e5"><td class="memTemplParams" colspan="2"><a id="a6cb1874215836798aa939a09ea7097e5" name="a6cb1874215836798aa939a09ea7097e5"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a6cb1874215836798aa939a09ea7097e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (T &amp;cont, Pred pred) -&gt; typename T::iterator</td></tr>
<tr class="separator:a6cb1874215836798aa939a09ea7097e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e5dd33fbb9abc8d28e1e74f78233e0" id="r_ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memTemplParams" colspan="2"><a id="ae8e5dd33fbb9abc8d28e1e74f78233e0" name="ae8e5dd33fbb9abc8d28e1e74f78233e0"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (const T &amp;cont, Pred pred) -&gt; typename T::const_iterator</td></tr>
<tr class="separator:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade96273c6f72f177a872f872e22091c0" id="r_ade96273c6f72f177a872f872e22091c0"><td class="memTemplParams" colspan="2"><a id="ade96273c6f72f177a872f872e22091c0" name="ade96273c6f72f177a872f872e22091c0"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ade96273c6f72f177a872f872e22091c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ade96273c6f72f177a872f872e22091c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f54391ec0db5815036c778ed412346" id="r_ab1f54391ec0db5815036c778ed412346"><td class="memTemplParams" colspan="2"><a id="ab1f54391ec0db5815036c778ed412346" name="ab1f54391ec0db5815036c778ed412346"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:ab1f54391ec0db5815036c778ed412346"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:ab1f54391ec0db5815036c778ed412346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae770415d5ba00c86cf182d333590ac06" id="r_ae770415d5ba00c86cf182d333590ac06"><td class="memTemplParams" colspan="2"><a id="ae770415d5ba00c86cf182d333590ac06" name="ae770415d5ba00c86cf182d333590ac06"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ae770415d5ba00c86cf182d333590ac06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ae770415d5ba00c86cf182d333590ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a93edbea65cb8ae18addd0dcc04b1" id="r_a959a93edbea65cb8ae18addd0dcc04b1"><td class="memTemplParams" colspan="2"><a id="a959a93edbea65cb8ae18addd0dcc04b1" name="a959a93edbea65cb8ae18addd0dcc04b1"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_if</b> (const T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071781f9ac07a9a1b432fc2aec6388ee" id="r_a071781f9ac07a9a1b432fc2aec6388ee"><td class="memTemplParams" colspan="2"><a id="a071781f9ac07a9a1b432fc2aec6388ee" name="a071781f9ac07a9a1b432fc2aec6388ee"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if_or_null</b> (T &amp;cont, P pred) -&gt; typename T::value_type</td></tr>
<tr class="separator:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d7b74f00e72f7b4556af25b050a092" id="r_a49d7b74f00e72f7b4556af25b050a092"><td class="memTemplParams" colspan="2"><a id="a49d7b74f00e72f7b4556af25b050a092" name="a49d7b74f00e72f7b4556af25b050a092"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a49d7b74f00e72f7b4556af25b050a092"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_or_null</b> (T &amp;cont, const V &amp;elem) -&gt; typename T::value_type</td></tr>
<tr class="separator:a49d7b74f00e72f7b4556af25b050a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad093bf8f1f594c0f814c6154fb59e39c" id="r_ad093bf8f1f594c0f814c6154fb59e39c"><td class="memTemplParams" colspan="2"><a id="ad093bf8f1f594c0f814c6154fb59e39c" name="ad093bf8f1f594c0f814c6154fb59e39c"></a>
template&lt;typename T , typename V , typename Callable &gt; </td></tr>
<tr class="memitem:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_or_null</b> (T &amp;cont, const V &amp;elem, Callable f) -&gt; typename T::value_type</td></tr>
<tr class="separator:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111c6325641f7d9c5bf18a934e5290c7" id="r_a111c6325641f7d9c5bf18a934e5290c7"><td class="memTemplParams" colspan="2"><a id="a111c6325641f7d9c5bf18a934e5290c7" name="a111c6325641f7d9c5bf18a934e5290c7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a111c6325641f7d9c5bf18a934e5290c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_key</b> (T &amp;map, const typename T::key_type &amp;key)</td></tr>
<tr class="separator:a111c6325641f7d9c5bf18a934e5290c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee41d732a5626da3a086161c7d83c33" id="r_a1ee41d732a5626da3a086161c7d83c33"><td class="memTemplParams" colspan="2"><a id="a1ee41d732a5626da3a086161c7d83c33" name="a1ee41d732a5626da3a086161c7d83c33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ee41d732a5626da3a086161c7d83c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_unique</b> (T &amp;map, const typename T::key_type &amp;key, typename T::mapped_type &amp;value)</td></tr>
<tr class="separator:a1ee41d732a5626da3a086161c7d83c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1bd66e291bc8e17a45faf11b8587bb" id="r_a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memTemplParams" colspan="2"><a id="a8d1bd66e291bc8e17a45faf11b8587bb" name="a8d1bd66e291bc8e17a45faf11b8587bb"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_find_or_null</b> (T &amp;cont, const V &amp;elem) -&gt; typename T::mapped_type</td></tr>
<tr class="separator:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca73a0b954191f4d56f2859cf136f81" id="r_a6ca73a0b954191f4d56f2859cf136f81"><td class="memTemplParams" colspan="2"><a id="a6ca73a0b954191f4d56f2859cf136f81" name="a6ca73a0b954191f4d56f2859cf136f81"></a>
template&lt;typename T , typename V , typename Callable &gt; </td></tr>
<tr class="memitem:a6ca73a0b954191f4d56f2859cf136f81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_find_or_null</b> (T &amp;cont, const V &amp;elem, Callable f) -&gt; typename std::invoke_result_t&lt; Callable, typename T::mapped_type &gt;</td></tr>
<tr class="separator:a6ca73a0b954191f4d56f2859cf136f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19583b6a36283c058dd0dbc54373094f" id="r_a19583b6a36283c058dd0dbc54373094f"><td class="memTemplParams" colspan="2"><a id="a19583b6a36283c058dd0dbc54373094f" name="a19583b6a36283c058dd0dbc54373094f"></a>
template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a19583b6a36283c058dd0dbc54373094f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_of</b> (InputIter begin, InputIter end, UnaryPredicate pred)</td></tr>
<tr class="separator:a19583b6a36283c058dd0dbc54373094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee64649b8ea8ed565e9597534fce8326" id="r_aee64649b8ea8ed565e9597534fce8326"><td class="memTemplParams" colspan="2"><a id="aee64649b8ea8ed565e9597534fce8326" name="aee64649b8ea8ed565e9597534fce8326"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aee64649b8ea8ed565e9597534fce8326"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:aee64649b8ea8ed565e9597534fce8326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa4c49d2b4045a2ec2a28ee9be815a" id="r_a1caa4c49d2b4045a2ec2a28ee9be815a"><td class="memTemplParams" colspan="2"><a id="a1caa4c49d2b4045a2ec2a28ee9be815a" name="a1caa4c49d2b4045a2ec2a28ee9be815a"></a>
template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a1caa4c49d2b4045a2ec2a28ee9be815a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_of</b> (InputIter begin, InputIter end, UnaryPredicate pred)</td></tr>
<tr class="separator:a1caa4c49d2b4045a2ec2a28ee9be815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58a2f08d57fc0419b60673c3f62469" id="r_acc58a2f08d57fc0419b60673c3f62469"><td class="memTemplParams" colspan="2"><a id="acc58a2f08d57fc0419b60673c3f62469" name="acc58a2f08d57fc0419b60673c3f62469"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:acc58a2f08d57fc0419b60673c3f62469"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:acc58a2f08d57fc0419b60673c3f62469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85268c5944ad9fd579980101fa02bcd" id="r_ac85268c5944ad9fd579980101fa02bcd"><td class="memTemplParams" colspan="2"><a id="ac85268c5944ad9fd579980101fa02bcd" name="ac85268c5944ad9fd579980101fa02bcd"></a>
template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac85268c5944ad9fd579980101fa02bcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>none_of</b> (InputIter begin, InputIter end, UnaryPredicate pred)</td></tr>
<tr class="separator:ac85268c5944ad9fd579980101fa02bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f62920005713409e889688968eb74" id="r_a778f62920005713409e889688968eb74"><td class="memTemplParams" colspan="2"><a id="a778f62920005713409e889688968eb74" name="a778f62920005713409e889688968eb74"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a778f62920005713409e889688968eb74"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>none_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:a778f62920005713409e889688968eb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47943383fe847434783771ad699cbb7" id="r_ae47943383fe847434783771ad699cbb7"><td class="memTemplParams" colspan="2"><a id="ae47943383fe847434783771ad699cbb7" name="ae47943383fe847434783771ad699cbb7"></a>
template&lt;typename Iter , typename Proj  = identity&gt; </td></tr>
<tr class="memitem:ae47943383fe847434783771ad699cbb7"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_not_equal</b> (Iter begin, Iter end, Proj proj={})</td></tr>
<tr class="separator:ae47943383fe847434783771ad699cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea3b690dfcdeda7ee4c0a5c54926945" id="r_a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memTemplParams" colspan="2"><a id="a9ea3b690dfcdeda7ee4c0a5c54926945" name="a9ea3b690dfcdeda7ee4c0a5c54926945"></a>
template&lt;typename T , typename OutIt , typename P &gt; </td></tr>
<tr class="memitem:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memTemplItemLeft" align="right" valign="top">OutIt&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (const T &amp;cont, OutIt out, P pred)</td></tr>
<tr class="separator:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72545927f4c67d0c29ddf1fab7768ad8" id="r_a72545927f4c67d0c29ddf1fab7768ad8"><td class="memTemplParams" colspan="2"><a id="a72545927f4c67d0c29ddf1fab7768ad8" name="a72545927f4c67d0c29ddf1fab7768ad8"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (const T &amp;cont, P pred) -&gt; std::vector&lt; typename T::value_type &gt;</td></tr>
<tr class="separator:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef553126a137991f8617700fe144f6" id="r_a23ef553126a137991f8617700fe144f6"><td class="memTemplParams" colspan="2"><a id="a23ef553126a137991f8617700fe144f6" name="a23ef553126a137991f8617700fe144f6"></a>
template&lt;typename T , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a23ef553126a137991f8617700fe144f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (const T &amp;cont, UnaryOperation op) -&gt; std::vector&lt; std::invoke_result_t&lt; UnaryOperation, const typename T::value_type &gt; &gt;</td></tr>
<tr class="separator:a23ef553126a137991f8617700fe144f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8002915caf2929e669c07a259ff36fb1" id="r_a8002915caf2929e669c07a259ff36fb1"><td class="memTemplParams" colspan="2"><a id="a8002915caf2929e669c07a259ff36fb1" name="a8002915caf2929e669c07a259ff36fb1"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a8002915caf2929e669c07a259ff36fb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordering</b> (T &amp;cont, Pred pred) -&gt; std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:a8002915caf2929e669c07a259ff36fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4401cb675aec808de01a4e7a9f552f1" id="r_aa4401cb675aec808de01a4e7a9f552f1"><td class="memTemplParams" colspan="2"><a id="aa4401cb675aec808de01a4e7a9f552f1" name="aa4401cb675aec808de01a4e7a9f552f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4401cb675aec808de01a4e7a9f552f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordering</b> (T &amp;cont) -&gt; std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:aa4401cb675aec808de01a4e7a9f552f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7679ac4f77483edefc2dc236495b625" id="r_aa7679ac4f77483edefc2dc236495b625"><td class="memTemplParams" colspan="2"><a id="aa7679ac4f77483edefc2dc236495b625" name="aa7679ac4f77483edefc2dc236495b625"></a>
template&lt;typename Generator &gt; </td></tr>
<tr class="memitem:aa7679ac4f77483edefc2dc236495b625"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>table</b> (Generator gen, int start, int end, int step=1) -&gt; std::vector&lt; decltype(gen(std::declval&lt; int &gt;()))&gt;</td></tr>
<tr class="separator:aa7679ac4f77483edefc2dc236495b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255656e04e9caab0092cefb2387b522c" id="r_a255656e04e9caab0092cefb2387b522c"><td class="memTemplParams" colspan="2">template&lt;class T , typename Tuple , size_t count = 0&gt; </td></tr>
<tr class="memitem:a255656e04e9caab0092cefb2387b522c"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a255656e04e9caab0092cefb2387b522c">index_of</a> ()</td></tr>
<tr class="separator:a255656e04e9caab0092cefb2387b522c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ffacb1ddf668f23cac00ffca4071a" id="r_a144ffacb1ddf668f23cac00ffca4071a"><td class="memTemplParams" colspan="2">template&lt;class T , typename Tuple , size_t count = 0&gt; </td></tr>
<tr class="memitem:a144ffacb1ddf668f23cac00ffca4071a"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a144ffacb1ddf668f23cac00ffca4071a">index_of_derived</a> ()</td></tr>
<tr class="separator:a144ffacb1ddf668f23cac00ffca4071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd7c9fa30cdd956764cfe090ff6a4bb" id="r_acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memTemplParams" colspan="2"><a id="acdd7c9fa30cdd956764cfe090ff6a4bb" name="acdd7c9fa30cdd956764cfe090ff6a4bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_future_ready</b> (const std::future&lt; T &gt; &amp;future)</td></tr>
<tr class="separator:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac562f60680204dda73a7d29d9c9ddb24" id="r_ac562f60680204dda73a7d29d9c9ddb24"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac562f60680204dda73a7d29d9c9ddb24">toWstring</a> (std::string_view str)</td></tr>
<tr class="memdesc:ac562f60680204dda73a7d29d9c9ddb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the given std::string to std::wstring. On Windows, MultiByteToWideChar is used for this conversion assuming utf8 encoding. Otherwise, std::mbsrtowcs is used.  <br /></td></tr>
<tr class="separator:ac562f60680204dda73a7d29d9c9ddb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ec5e6658368eb78ce7b3161c63eddb" id="r_a53ec5e6658368eb78ce7b3161c63eddb"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ec5e6658368eb78ce7b3161c63eddb">fromWstring</a> (std::wstring_view str)</td></tr>
<tr class="memdesc:a53ec5e6658368eb78ce7b3161c63eddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the given std::wstring to std::string. On Windows, WideCharToMultiByte is used for this conversion assuming utf8 encoding. Otherwise, std::wcsrtombs is used.  <br /></td></tr>
<tr class="separator:a53ec5e6658368eb78ce7b3161c63eddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040967fe9b1828c138864fcff6d60c0d" id="r_a040967fe9b1828c138864fcff6d60c0d"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a040967fe9b1828c138864fcff6d60c0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a040967fe9b1828c138864fcff6d60c0d">forEachStringPart</a> (std::string_view str, std::string_view sep, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a040967fe9b1828c138864fcff6d60c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on each part of the string after splitting by sep.  <br /></td></tr>
<tr class="separator:a040967fe9b1828c138864fcff6d60c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68531c2a1a0d7b50fbcd32b4ab6d03a2" id="r_a68531c2a1a0d7b50fbcd32b4ab6d03a2"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68531c2a1a0d7b50fbcd32b4ab6d03a2">splitByFirst</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:a68531c2a1a0d7b50fbcd32b4ab6d03a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the first instance of a delimiter.  <br /></td></tr>
<tr class="separator:a68531c2a1a0d7b50fbcd32b4ab6d03a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e4709f37d1f58ead6f6bb699964102" id="r_a72e4709f37d1f58ead6f6bb699964102"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72e4709f37d1f58ead6f6bb699964102">splitByFirst</a> (std::string_view str, std::string_view delimiter)</td></tr>
<tr class="memdesc:a72e4709f37d1f58ead6f6bb699964102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the first instance of a delimiter.  <br /></td></tr>
<tr class="separator:a72e4709f37d1f58ead6f6bb699964102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062e820ba75f7fb44e8b149e52dd979" id="r_a7062e820ba75f7fb44e8b149e52dd979"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7062e820ba75f7fb44e8b149e52dd979">splitByLast</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:a7062e820ba75f7fb44e8b149e52dd979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the last instance of a delimiter.  <br /></td></tr>
<tr class="separator:a7062e820ba75f7fb44e8b149e52dd979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22420f375af97c3654f65bd70c7df79c" id="r_a22420f375af97c3654f65bd70c7df79c"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22420f375af97c3654f65bd70c7df79c">splitByLast</a> (std::string_view str, std::string_view delimiter)</td></tr>
<tr class="memdesc:a22420f375af97c3654f65bd70c7df79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the last instance of a delimiter.  <br /></td></tr>
<tr class="separator:a22420f375af97c3654f65bd70c7df79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab608fdeb665bcddf5e9821006487364b" id="r_ab608fdeb665bcddf5e9821006487364b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab608fdeb665bcddf5e9821006487364b">splitString</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:ab608fdeb665bcddf5e9821006487364b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb.  <br /></td></tr>
<tr class="separator:ab608fdeb665bcddf5e9821006487364b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018c12bda5703660547faff1bd31b8b9" id="r_a018c12bda5703660547faff1bd31b8b9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a018c12bda5703660547faff1bd31b8b9">splitStringView</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:a018c12bda5703660547faff1bd31b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb.  <br /></td></tr>
<tr class="separator:a018c12bda5703660547faff1bd31b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3562b94700f15c08e99b826745258a" id="r_aeb3562b94700f15c08e99b826745258a"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3562b94700f15c08e99b826745258a">trim</a> (std::string_view str) noexcept</td></tr>
<tr class="memdesc:aeb3562b94700f15c08e99b826745258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">trims <code>str</code> from beginning and end by removing white spaces  <br /></td></tr>
<tr class="separator:aeb3562b94700f15c08e99b826745258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bf0cc28f51cabb7d36e15c61129f7c" id="r_ab6bf0cc28f51cabb7d36e15c61129f7c"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6bf0cc28f51cabb7d36e15c61129f7c">ltrim</a> (std::string_view str) noexcept</td></tr>
<tr class="memdesc:ab6bf0cc28f51cabb7d36e15c61129f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">trims <code>str</code> from beginning removing white spaces  <br /></td></tr>
<tr class="separator:ab6bf0cc28f51cabb7d36e15c61129f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababf20580e98b848eaffd93c087fedb2" id="r_ababf20580e98b848eaffd93c087fedb2"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ababf20580e98b848eaffd93c087fedb2">rtrim</a> (std::string_view str) noexcept</td></tr>
<tr class="memdesc:ababf20580e98b848eaffd93c087fedb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">trims <code>str</code> from end by removing white spaces  <br /></td></tr>
<tr class="separator:ababf20580e98b848eaffd93c087fedb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72163c26b092ba2ad01a8ba8af763d59" id="r_a72163c26b092ba2ad01a8ba8af763d59"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72163c26b092ba2ad01a8ba8af763d59">iCaseEndsWith</a> (std::string_view str, std::string_view suffix)</td></tr>
<tr class="memdesc:a72163c26b092ba2ad01a8ba8af763d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if provided string ends with suffix using case insensitive equal comparison.  <br /></td></tr>
<tr class="separator:a72163c26b092ba2ad01a8ba8af763d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b234248fa0f75afa5d053118ec319a" id="r_aa0b234248fa0f75afa5d053118ec319a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b234248fa0f75afa5d053118ec319a">elideLines</a> (std::string_view str, std::string_view abbrev=&quot;...&quot;, size_t maxLineLength=500)</td></tr>
<tr class="memdesc:aa0b234248fa0f75afa5d053118ec319a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elide parts of lines in <code>str</code> which are longer than <code>maxLineLength</code> and append <code>abbrev</code> instead.  <br /></td></tr>
<tr class="separator:aa0b234248fa0f75afa5d053118ec319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7447a59e98c79adcb132a0d5318badc0" id="r_a7447a59e98c79adcb132a0d5318badc0"><td class="memItemLeft" align="right" valign="top"><a id="a7447a59e98c79adcb132a0d5318badc0" name="a7447a59e98c79adcb132a0d5318badc0"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>urlEncodeTo</b> (std::string_view text, <a class="el" href="structinviwo_1_1StrBuffer.html">StrBuffer</a> &amp;strBuffer)</td></tr>
<tr class="separator:a7447a59e98c79adcb132a0d5318badc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139147c9ad3222c2474c569fb3378ba0" id="r_a139147c9ad3222c2474c569fb3378ba0"><td class="memItemLeft" align="right" valign="top"><a id="a139147c9ad3222c2474c569fb3378ba0" name="a139147c9ad3222c2474c569fb3378ba0"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>htmlEncodeTo</b> (std::string_view data, <a class="el" href="structinviwo_1_1StrBuffer.html">StrBuffer</a> &amp;strBuffer)</td></tr>
<tr class="separator:a139147c9ad3222c2474c569fb3378ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305dcf9354ab8fdd582061e8186fb721" id="r_a305dcf9354ab8fdd582061e8186fb721"><td class="memItemLeft" align="right" valign="top"><a id="a305dcf9354ab8fdd582061e8186fb721" name="a305dcf9354ab8fdd582061e8186fb721"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>urlEncode</b> (std::string_view text)</td></tr>
<tr class="separator:a305dcf9354ab8fdd582061e8186fb721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f9833eb188a10608194ca675005df7" id="r_ac3f9833eb188a10608194ca675005df7"><td class="memItemLeft" align="right" valign="top"><a id="ac3f9833eb188a10608194ca675005df7" name="ac3f9833eb188a10608194ca675005df7"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>htmlEncode</b> (std::string_view data)</td></tr>
<tr class="separator:ac3f9833eb188a10608194ca675005df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484dd85ff9c63315cc81ab5564f16aed" id="r_a484dd85ff9c63315cc81ab5564f16aed"><td class="memItemLeft" align="right" valign="top"><a id="a484dd85ff9c63315cc81ab5564f16aed" name="a484dd85ff9c63315cc81ab5564f16aed"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>setThreadDescription</b> (const std::string &amp;desc)</td></tr>
<tr class="separator:a484dd85ff9c63315cc81ab5564f16aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85adb784f1a9346f8446eb496a7762b9" id="r_a85adb784f1a9346f8446eb496a7762b9"><td class="memItemLeft" align="right" valign="top"><a id="a85adb784f1a9346f8446eb496a7762b9" name="a85adb784f1a9346f8446eb496a7762b9"></a>
IVW_CORE_API int&#160;</td><td class="memItemRight" valign="bottom"><b>getPid</b> ()</td></tr>
<tr class="separator:a85adb784f1a9346f8446eb496a7762b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6687e17bbb178967a4cf238e4121297a" id="r_a6687e17bbb178967a4cf238e4121297a"><td class="memItemLeft" align="right" valign="top"><a id="a6687e17bbb178967a4cf238e4121297a" name="a6687e17bbb178967a4cf238e4121297a"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadPool</b> ()</td></tr>
<tr class="separator:a6687e17bbb178967a4cf238e4121297a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54baec08c2b599f8a7295383c70ba20d" id="r_a54baec08c2b599f8a7295383c70ba20d"><td class="memItemLeft" align="right" valign="top"><a id="a54baec08c2b599f8a7295383c70ba20d" name="a54baec08c2b599f8a7295383c70ba20d"></a>
IVW_CORE_API <a class="el" href="classinviwo_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadPool</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a54baec08c2b599f8a7295383c70ba20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3389cb64e5315f8fc6fabc672c2bb5" id="r_aec3389cb64e5315f8fc6fabc672c2bb5"><td class="memItemLeft" align="right" valign="top"><a id="aec3389cb64e5315f8fc6fabc672c2bb5" name="aec3389cb64e5315f8fc6fabc672c2bb5"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>waitForPool</b> ()</td></tr>
<tr class="separator:aec3389cb64e5315f8fc6fabc672c2bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cc747b32612a18b5b970a8538f096f" id="r_ac9cc747b32612a18b5b970a8538f096f"><td class="memItemLeft" align="right" valign="top"><a id="ac9cc747b32612a18b5b970a8538f096f" name="ac9cc747b32612a18b5b970a8538f096f"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>waitForPool</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:ac9cc747b32612a18b5b970a8538f096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecff695e76cf6899ab41c76c5a63d074" id="r_aecff695e76cf6899ab41c76c5a63d074"><td class="memItemLeft" align="right" valign="top"><a id="aecff695e76cf6899ab41c76c5a63d074" name="aecff695e76cf6899ab41c76c5a63d074"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>processFront</b> ()</td></tr>
<tr class="separator:aecff695e76cf6899ab41c76c5a63d074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671396a2814015b6998ce766b6d6e44b" id="r_a671396a2814015b6998ce766b6d6e44b"><td class="memItemLeft" align="right" valign="top"><a id="a671396a2814015b6998ce766b6d6e44b" name="a671396a2814015b6998ce766b6d6e44b"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>processFront</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a671396a2814015b6998ce766b6d6e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702e21fe04fa35dfbb9d289debe3728a" id="r_a702e21fe04fa35dfbb9d289debe3728a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a702e21fe04fa35dfbb9d289debe3728a">getPoolSize</a> ()</td></tr>
<tr class="separator:a702e21fe04fa35dfbb9d289debe3728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ed24099e63d110c28edc17c29a9c92" id="r_a62ed24099e63d110c28edc17c29a9c92"><td class="memTemplParams" colspan="2"><a id="a62ed24099e63d110c28edc17c29a9c92" name="a62ed24099e63d110c28edc17c29a9c92"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:a62ed24099e63d110c28edc17c29a9c92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dispatchPool</b> (F &amp;&amp;f, Args &amp;&amp;... args) -&gt; std::future&lt; std::invoke_result_t&lt; F, Args... &gt; &gt;</td></tr>
<tr class="separator:a62ed24099e63d110c28edc17c29a9c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4efd441f72b321a7e729fc6d28ad8a2" id="r_aa4efd441f72b321a7e729fc6d28ad8a2"><td class="memTemplParams" colspan="2"><a id="aa4efd441f72b321a7e729fc6d28ad8a2" name="aa4efd441f72b321a7e729fc6d28ad8a2"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:aa4efd441f72b321a7e729fc6d28ad8a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dispatchPool</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, F &amp;&amp;f, Args &amp;&amp;... args) -&gt; std::future&lt; std::invoke_result_t&lt; F, Args... &gt; &gt;</td></tr>
<tr class="separator:aa4efd441f72b321a7e729fc6d28ad8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fd3e125dc4bed056d4c4d129961ada" id="r_a29fd3e125dc4bed056d4c4d129961ada"><td class="memItemLeft" align="right" valign="top"><a id="a29fd3e125dc4bed056d4c4d129961ada" name="a29fd3e125dc4bed056d4c4d129961ada"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>dispatchFrontAndForget</b> (std::function&lt; void()&gt; fun)</td></tr>
<tr class="separator:a29fd3e125dc4bed056d4c4d129961ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1c83a13e5301d211f289f4d5f1ed84" id="r_a6b1c83a13e5301d211f289f4d5f1ed84"><td class="memItemLeft" align="right" valign="top"><a id="a6b1c83a13e5301d211f289f4d5f1ed84" name="a6b1c83a13e5301d211f289f4d5f1ed84"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>dispatchFrontAndForget</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, std::function&lt; void()&gt; fun)</td></tr>
<tr class="separator:a6b1c83a13e5301d211f289f4d5f1ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6a76a519059d7529d2d736d69374a4" id="r_a2e6a76a519059d7529d2d736d69374a4"><td class="memTemplParams" colspan="2"><a id="a2e6a76a519059d7529d2d736d69374a4" name="a2e6a76a519059d7529d2d736d69374a4"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:a2e6a76a519059d7529d2d736d69374a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dispatchFront</b> (F &amp;&amp;f, Args &amp;&amp;... args) -&gt; std::future&lt; std::invoke_result_t&lt; F, Args... &gt; &gt;</td></tr>
<tr class="separator:a2e6a76a519059d7529d2d736d69374a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab1a4d1ea36498c01992c64069797aa" id="r_a4ab1a4d1ea36498c01992c64069797aa"><td class="memTemplParams" colspan="2"><a id="a4ab1a4d1ea36498c01992c64069797aa" name="a4ab1a4d1ea36498c01992c64069797aa"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:a4ab1a4d1ea36498c01992c64069797aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dispatchFront</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, F &amp;&amp;f, Args &amp;&amp;... args) -&gt; std::future&lt; std::invoke_result_t&lt; F, Args... &gt; &gt;</td></tr>
<tr class="separator:a4ab1a4d1ea36498c01992c64069797aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d2b2443c5b46240122de8b5dd5b400" id="r_a86d2b2443c5b46240122de8b5dd5b400"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86d2b2443c5b46240122de8b5dd5b400">getDefaultTimerThread</a> ()</td></tr>
<tr class="separator:a86d2b2443c5b46240122de8b5dd5b400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5d945da868ca74124adefa308b6188" id="r_a8d5d945da868ca74124adefa308b6188"><td class="memTemplParams" colspan="2"><a id="a8d5d945da868ca74124adefa308b6188" name="a8d5d945da868ca74124adefa308b6188"></a>
template&lt;typename <a class="el" href="classinviwo_1_1Transform.html">Transform</a> , typename Iter &gt; </td></tr>
<tr class="memitem:a8d5d945da868ca74124adefa308b6188"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTransformIterator</b> (<a class="el" href="classinviwo_1_1Transform.html">Transform</a> &amp;&amp;transform, Iter iter)</td></tr>
<tr class="separator:a8d5d945da868ca74124adefa308b6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a69ca9ecd046dc3fbb980c8d48ae9a" id="r_ab3a69ca9ecd046dc3fbb980c8d48ae9a"><td class="memTemplParams" colspan="2"><a id="ab3a69ca9ecd046dc3fbb980c8d48ae9a" name="ab3a69ca9ecd046dc3fbb980c8d48ae9a"></a>
template&lt;typename Range , typename <a class="el" href="classinviwo_1_1Transform.html">Transform</a> &gt; </td></tr>
<tr class="memitem:ab3a69ca9ecd046dc3fbb980c8d48ae9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transformRange</b> (Range &amp;range, <a class="el" href="classinviwo_1_1Transform.html">Transform</a> &amp;&amp;transform)</td></tr>
<tr class="separator:ab3a69ca9ecd046dc3fbb980c8d48ae9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9043d4a86a79be19df535ce9731f0153" id="r_a9043d4a86a79be19df535ce9731f0153"><td class="memTemplParams" colspan="2">template&lt;typename... A, typename F &gt; </td></tr>
<tr class="memitem:a9043d4a86a79be19df535ce9731f0153"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9043d4a86a79be19df535ce9731f0153">is_callable_with</a> (F &amp;&amp;)</td></tr>
<tr class="separator:a9043d4a86a79be19df535ce9731f0153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3a0ae0e3b7f2982ed95511e8fd53ac" id="r_a8f3a0ae0e3b7f2982ed95511e8fd53ac"><td class="memItemLeft" align="right" valign="top"><a id="a8f3a0ae0e3b7f2982ed95511e8fd53ac" name="a8f3a0ae0e3b7f2982ed95511e8fd53ac"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveNetwork</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::string_view filename)</td></tr>
<tr class="separator:a8f3a0ae0e3b7f2982ed95511e8fd53ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55634906692128ae4219d7f6397d80e" id="r_af55634906692128ae4219d7f6397d80e"><td class="memItemLeft" align="right" valign="top"><a id="af55634906692128ae4219d7f6397d80e" name="af55634906692128ae4219d7f6397d80e"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveAllCanvases</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, const std::filesystem::path &amp;dir, std::string_view name=&quot;UPN&quot;, std::string_view ext=&quot;.png&quot;, bool onlyActiveCanvases=false)</td></tr>
<tr class="separator:af55634906692128ae4219d7f6397d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40eb018880e2f5c6f66452163325611" id="r_aa40eb018880e2f5c6f66452163325611"><td class="memItemLeft" align="right" valign="top"><a id="aa40eb018880e2f5c6f66452163325611" name="aa40eb018880e2f5c6f66452163325611"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidIdentifierCharacter</b> (char c, std::string_view extra=&quot;&quot;)</td></tr>
<tr class="separator:aa40eb018880e2f5c6f66452163325611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a22c0c040b8e54cdb5bd3d4896a698" id="r_a84a22c0c040b8e54cdb5bd3d4896a698"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a22c0c040b8e54cdb5bd3d4896a698">validateIdentifier</a> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, std::string_view type, <a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a> context)</td></tr>
<tr class="separator:a84a22c0c040b8e54cdb5bd3d4896a698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1641752b9b6ec1384f983f1f7b86a9" id="r_a2a1641752b9b6ec1384f983f1f7b86a9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a1641752b9b6ec1384f983f1f7b86a9">findUniqueIdentifier</a> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, std::function&lt; bool(std::string_view)&gt; isUnique, std::string_view sep=&quot; &quot;)</td></tr>
<tr class="separator:a2a1641752b9b6ec1384f983f1f7b86a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287fded47920b2a0e2dada11249da84" id="r_a9287fded47920b2a0e2dada11249da84"><td class="memItemLeft" align="right" valign="top"><a id="a9287fded47920b2a0e2dada11249da84" name="a9287fded47920b2a0e2dada11249da84"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>cleanIdentifier</b> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, std::string_view extra=&quot;&quot;)</td></tr>
<tr class="separator:a9287fded47920b2a0e2dada11249da84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9540b524a4db813530dfad0a0e19e883" id="r_a9540b524a4db813530dfad0a0e19e883"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9540b524a4db813530dfad0a0e19e883">stripModuleFileNameDecoration</a> (const std::filesystem::path &amp;filePath)</td></tr>
<tr class="memdesc:a9540b524a4db813530dfad0a0e19e883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes inviwo-module from module library file name. Turns "/path/to/inviwo-module-yourmodule.dll" into "yourmodule". Returns filename without extension if inviwo-module was not found.  <br /></td></tr>
<tr class="separator:a9540b524a4db813530dfad0a0e19e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96dd02792cfa20cef05e9d001b497b" id="r_a7a96dd02792cfa20cef05e9d001b497b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a96dd02792cfa20cef05e9d001b497b">stripIdentifier</a> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>)</td></tr>
<tr class="separator:a7a96dd02792cfa20cef05e9d001b497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08654e337b9b5894672a1b218f5b9a31" id="r_a08654e337b9b5894672a1b218f5b9a31"><td class="memTemplParams" colspan="2"><a id="a08654e337b9b5894672a1b218f5b9a31" name="a08654e337b9b5894672a1b218f5b9a31"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a08654e337b9b5894672a1b218f5b9a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>show</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a08654e337b9b5894672a1b218f5b9a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84700445b4e279e926156e7539163a11" id="r_a84700445b4e279e926156e7539163a11"><td class="memTemplParams" colspan="2"><a id="a84700445b4e279e926156e7539163a11" name="a84700445b4e279e926156e7539163a11"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a84700445b4e279e926156e7539163a11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hide</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a84700445b4e279e926156e7539163a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7437319dfe415d9e61f70fd1e4bc7981" id="r_a7437319dfe415d9e61f70fd1e4bc7981"><td class="memTemplParams" colspan="2"><a id="a7437319dfe415d9e61f70fd1e4bc7981" name="a7437319dfe415d9e61f70fd1e4bc7981"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a7437319dfe415d9e61f70fd1e4bc7981"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxel</b> (const size3_t dims, C callback)</td></tr>
<tr class="separator:a7437319dfe415d9e61f70fd1e4bc7981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d5b4f91c4ac3ca3d914354878b1601" id="r_ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memTemplParams" colspan="2"><a id="ad6d5b4f91c4ac3ca3d914354878b1601" name="ad6d5b4f91c4ac3ca3d914354878b1601"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxel</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &amp;v, C callback)</td></tr>
<tr class="separator:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddb074a2060ace9bb2c3e1700eb0159" id="r_afddb074a2060ace9bb2c3e1700eb0159"><td class="memTemplParams" colspan="2"><a id="afddb074a2060ace9bb2c3e1700eb0159" name="afddb074a2060ace9bb2c3e1700eb0159"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afddb074a2060ace9bb2c3e1700eb0159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxelParallel</b> (const size3_t dims, C callback, size_t jobs=0)</td></tr>
<tr class="separator:afddb074a2060ace9bb2c3e1700eb0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d81aad86b9c7cb3348b7e57305d8a2" id="r_a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memTemplParams" colspan="2"><a id="a13d81aad86b9c7cb3348b7e57305d8a2" name="a13d81aad86b9c7cb3348b7e57305d8a2"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxelParallel</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &amp;v, C callback, size_t jobs=0)</td></tr>
<tr class="separator:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21747890a13398b588966f5f1ac24e3" id="r_af21747890a13398b588966f5f1ac24e3"><td class="memItemLeft" align="right" valign="top"><a id="af21747890a13398b588966f5f1ac24e3" name="af21747890a13398b588966f5f1ac24e3"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasTimestamps</b> (const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;seq, bool checkfirstonly=true)</td></tr>
<tr class="separator:af21747890a13398b588966f5f1ac24e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b5c04235da80135b0cd245c6ae8fcc" id="r_a59b5c04235da80135b0cd245c6ae8fcc"><td class="memItemLeft" align="right" valign="top"><a id="a59b5c04235da80135b0cd245c6ae8fcc" name="a59b5c04235da80135b0cd245c6ae8fcc"></a>
IVW_CORE_API std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTimestampRange</b> (const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;seq, bool sorted=true)</td></tr>
<tr class="separator:a59b5c04235da80135b0cd245c6ae8fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d0dfdfd2b73cefab3f93eb01c63ade" id="r_a98d0dfdfd2b73cefab3f93eb01c63ade"><td class="memItemLeft" align="right" valign="top"><a id="a98d0dfdfd2b73cefab3f93eb01c63ade" name="a98d0dfdfd2b73cefab3f93eb01c63ade"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSorted</b> (const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;seq)</td></tr>
<tr class="separator:a98d0dfdfd2b73cefab3f93eb01c63ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba6db9dcbcedd225e39d3363c37ff72" id="r_acba6db9dcbcedd225e39d3363c37ff72"><td class="memItemLeft" align="right" valign="top"><a id="acba6db9dcbcedd225e39d3363c37ff72" name="acba6db9dcbcedd225e39d3363c37ff72"></a>
<a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>sortSequence</b> (const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;seq)</td></tr>
<tr class="separator:acba6db9dcbcedd225e39d3363c37ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b8f74c672f9e9e089d7acbfd5fcc7d" id="r_a27b8f74c672f9e9e089d7acbfd5fcc7d"><td class="memItemLeft" align="right" valign="top"><a id="a27b8f74c672f9e9e089d7acbfd5fcc7d" name="a27b8f74c672f9e9e089d7acbfd5fcc7d"></a>
IVW_CORE_API std::pair&lt; std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;, std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVolumesForTimestep</b> (const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;seq, double t, bool sorted=true)</td></tr>
<tr class="separator:a27b8f74c672f9e9e089d7acbfd5fcc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7900b05fb6df45e1763810596feeeb3" id="r_ad7900b05fb6df45e1763810596feeeb3"><td class="memItemLeft" align="right" valign="top"><a id="ad7900b05fb6df45e1763810596feeeb3" name="ad7900b05fb6df45e1763810596feeeb3"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasTimestamp</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;vol)</td></tr>
<tr class="separator:ad7900b05fb6df45e1763810596feeeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d5b92c4c6a3d17f5d860517d98cb7e" id="r_a59d5b92c4c6a3d17f5d860517d98cb7e"><td class="memItemLeft" align="right" valign="top"><a id="a59d5b92c4c6a3d17f5d860517d98cb7e" name="a59d5b92c4c6a3d17f5d860517d98cb7e"></a>
double IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getTimestamp</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;vol)</td></tr>
<tr class="separator:a59d5b92c4c6a3d17f5d860517d98cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f6fe2283af95ca86e331a61dba4d69" id="r_af4f6fe2283af95ca86e331a61dba4d69"><td class="memItemLeft" align="right" valign="top"><a id="af4f6fe2283af95ca86e331a61dba4d69" name="af4f6fe2283af95ca86e331a61dba4d69"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasMargins</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:af4f6fe2283af95ca86e331a61dba4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0ff59bd90d37ed4d9bef5a3f6295e2" id="r_a3b0ff59bd90d37ed4d9bef5a3f6295e2"><td class="memItemLeft" align="right" valign="top"><a id="a3b0ff59bd90d37ed4d9bef5a3f6295e2" name="a3b0ff59bd90d37ed4d9bef5a3f6295e2"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>isBricked</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a3b0ff59bd90d37ed4d9bef5a3f6295e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97bfd32f7b2c3dcbb9e6e288fa4b4b9" id="r_af97bfd32f7b2c3dcbb9e6e288fa4b4b9"><td class="memItemLeft" align="right" valign="top"><a id="af97bfd32f7b2c3dcbb9e6e288fa4b4b9" name="af97bfd32f7b2c3dcbb9e6e288fa4b4b9"></a>
size3_t IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getBrickDimensions</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:af97bfd32f7b2c3dcbb9e6e288fa4b4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694731debfdf03c3fe12fd45f760e22" id="r_a2694731debfdf03c3fe12fd45f760e22"><td class="memItemLeft" align="right" valign="top">std::pair&lt; vec3, vec3 &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2694731debfdf03c3fe12fd45f760e22">getVolumeMargins</a> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="memdesc:a2694731debfdf03c3fe12fd45f760e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the margins of a volume, in normalized texture coordinates [0,1]  <br /></td></tr>
<tr class="separator:a2694731debfdf03c3fe12fd45f760e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73ec645cb3206ba1ffd1d9bea0747ee" id="r_ab73ec645cb3206ba1ffd1d9bea0747ee"><td class="memItemLeft" align="right" valign="top">size3_t IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab73ec645cb3206ba1ffd1d9bea0747ee">getVolumeDimensions</a> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="memdesc:ab73ec645cb3206ba1ffd1d9bea0747ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the true volume dimensions considering volume margins and bricking  <br /></td></tr>
<tr class="separator:ab73ec645cb3206ba1ffd1d9bea0747ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fde21434664ba9e965614cfdf7890fc" id="r_a4fde21434664ba9e965614cfdf7890fc"><td class="memItemLeft" align="right" valign="top">double IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fde21434664ba9e965614cfdf7890fc">voxelVolume</a> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="memdesc:a4fde21434664ba9e965614cfdf7890fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the volume of a single voxel, taking the basis and the dimensions into account The units of the result is in the unit as the basis vectors ^3  <br /></td></tr>
<tr class="separator:a4fde21434664ba9e965614cfdf7890fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec11e63479fff3c005d159414687d4e" id="r_a2ec11e63479fff3c005d159414687d4e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a2ec11e63479fff3c005d159414687d4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ec11e63479fff3c005d159414687d4e">zip</a> (T &amp;&amp;... args) -&gt; <a class="el" href="structinviwo_1_1util_1_1detailzip_1_1zipper.html">detailzip::zipper</a>&lt; T... &gt;</td></tr>
<tr class="separator:a2ec11e63479fff3c005d159414687d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa566d97b543e2bdded79bb2a50c33bb0" id="r_aa566d97b543e2bdded79bb2a50c33bb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa566d97b543e2bdded79bb2a50c33bb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa566d97b543e2bdded79bb2a50c33bb0">make_sequence</a> (const T &amp;begin, const T &amp;end, const T &amp;inc=T{1}) -&gt; <a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a>&lt; T &gt;</td></tr>
<tr class="separator:aa566d97b543e2bdded79bb2a50c33bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787f4da3b201153820af19c27c2a7fac" id="r_a787f4da3b201153820af19c27c2a7fac"><td class="memTemplParams" colspan="2">template&lt;typename TIndex  = size_t, typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a787f4da3b201153820af19c27c2a7fac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a787f4da3b201153820af19c27c2a7fac">enumerate</a> (T &amp;&amp;cont, Ts &amp;&amp;... conts)</td></tr>
<tr class="separator:a787f4da3b201153820af19c27c2a7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0496423a4f27e0f0c4ae09cbeb08b43" id="r_ad0496423a4f27e0f0c4ae09cbeb08b43"><td class="memItemLeft" align="right" valign="top"><a id="ad0496423a4f27e0f0c4ae09cbeb08b43" name="ad0496423a4f27e0f0c4ae09cbeb08b43"></a>
IVW_SYS_API std::vector&lt; <a class="el" href="classinviwo_1_1ModuleContainer.html">ModuleContainer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleContainersImpl</b> (<a class="el" href="classinviwo_1_1ModuleManager.html">ModuleManager</a> &amp;moduleManager, std::span&lt; const std::filesystem::path &gt; searchPaths)</td></tr>
<tr class="separator:ad0496423a4f27e0f0c4ae09cbeb08b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07275a1f0e6e27335cca6d9205599804" id="r_a07275a1f0e6e27335cca6d9205599804"><td class="memTemplParams" colspan="2"><a id="a07275a1f0e6e27335cca6d9205599804" name="a07275a1f0e6e27335cca6d9205599804"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a07275a1f0e6e27335cca6d9205599804"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classinviwo_1_1ModuleContainer.html">inviwo::ModuleContainer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getModuleContainers</b> (<a class="el" href="classinviwo_1_1ModuleManager.html">ModuleManager</a> &amp;moduleManager, Args &amp;&amp;... searchPaths)</td></tr>
<tr class="separator:a07275a1f0e6e27335cca6d9205599804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bda5f1fd4e0b90cadd1fc1e65f584a" id="r_a35bda5f1fd4e0b90cadd1fc1e65f584a"><td class="memTemplParams" colspan="2"><a id="a35bda5f1fd4e0b90cadd1fc1e65f584a" name="a35bda5f1fd4e0b90cadd1fc1e65f584a"></a>
template&lt;typename <a class="el" href="namespaceinviwo.html#a0780518930e4f82763044068321c57f4ad7778d0c64b6ba21494c97f77a66885a">Filter</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a35bda5f1fd4e0b90cadd1fc1e65f584a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>registerModulesFiltered</b> (<a class="el" href="classinviwo_1_1ModuleManager.html">ModuleManager</a> &amp;moduleManager, <a class="el" href="namespaceinviwo.html#a0780518930e4f82763044068321c57f4ad7778d0c64b6ba21494c97f77a66885a">Filter</a> &amp;&amp;filter, Args &amp;&amp;... searchPaths)</td></tr>
<tr class="separator:a35bda5f1fd4e0b90cadd1fc1e65f584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092b66526a3e179e894d3f4deabce351" id="r_a092b66526a3e179e894d3f4deabce351"><td class="memTemplParams" colspan="2"><a id="a092b66526a3e179e894d3f4deabce351" name="a092b66526a3e179e894d3f4deabce351"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a092b66526a3e179e894d3f4deabce351"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>registerModules</b> (<a class="el" href="classinviwo_1_1ModuleManager.html">ModuleManager</a> &amp;moduleManager, Args &amp;&amp;... searchPaths)</td></tr>
<tr class="separator:a092b66526a3e179e894d3f4deabce351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e7bd2ae4735fa0fdbbfb8d3e0d5b28" id="r_a35e7bd2ae4735fa0fdbbfb8d3e0d5b28"><td class="memItemLeft" align="right" valign="top"><a id="a35e7bd2ae4735fa0fdbbfb8d3e0d5b28" name="a35e7bd2ae4735fa0fdbbfb8d3e0d5b28"></a>
void IVW_QTEDITOR_API&#160;</td><td class="memItemRight" valign="bottom"><b>insertNetworkForData</b> (const std::filesystem::path &amp;dataFile, <a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *net, bool alwaysFirst=false, bool onlySource=false, QWidget *parent=nullptr)</td></tr>
<tr class="separator:a35e7bd2ae4735fa0fdbbfb8d3e0d5b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaefd44a8fc7b7156c27f830e98ace1" id="r_a0aaefd44a8fc7b7156c27f830e98ace1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TRAMrep &gt; <br />
requires requires(T data) { typename T::repr; std::is_base_of_v&lt;typename T::repr, TRAMrep&gt;; data.template getRepresentation&lt;TRAMrep&gt;(); }</td></tr>
<tr class="memitem:a0aaefd44a8fc7b7156c27f830e98ace1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0aaefd44a8fc7b7156c27f830e98ace1">combineChannels</a> (const std::array&lt; <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; T &gt;, 4 &gt; &amp;sources, const std::array&lt; int, 4 &gt; &amp;selectedPortChannels)</td></tr>
<tr class="separator:a0aaefd44a8fc7b7156c27f830e98ace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048b0cf2e27625499d9ac8e03af03d6" id="r_aa048b0cf2e27625499d9ac8e03af03d6"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa048b0cf2e27625499d9ac8e03af03d6">isConvex</a> (const std::vector&lt; T &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aa048b0cf2e27625499d9ac8e03af03d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given polygon is convex  <br /></td></tr>
<tr class="separator:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193aac2254d9cc5b5b1029995323d957" id="r_a193aac2254d9cc5b5b1029995323d957"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a193aac2254d9cc5b5b1029995323d957"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a193aac2254d9cc5b5b1029995323d957">isInside</a> (const std::vector&lt; T &gt; &amp;hull, const T &amp;p)</td></tr>
<tr class="memdesc:a193aac2254d9cc5b5b1029995323d957"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a given point lies within the convex hull  <br /></td></tr>
<tr class="separator:a193aac2254d9cc5b5b1029995323d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba0bfadae887301565e97b98483268b" id="r_aaba0bfadae887301565e97b98483268b"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aaba0bfadae887301565e97b98483268b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaba0bfadae887301565e97b98483268b">getArea</a> (const std::vector&lt; T &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aaba0bfadae887301565e97b98483268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the area of a convex polygon  <br /></td></tr>
<tr class="separator:aaba0bfadae887301565e97b98483268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6356ee05cfde312881b948335bf689b" id="r_ab6356ee05cfde312881b948335bf689b"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab6356ee05cfde312881b948335bf689b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6356ee05cfde312881b948335bf689b">convexHull</a> (const std::vector&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ab6356ee05cfde312881b948335bf689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the complex hull from a given set of 2D points using the Monotone Chain algorithm, i.e. Andrew's convex hull algorithm  <br /></td></tr>
<tr class="separator:ab6356ee05cfde312881b948335bf689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1da85e48a030a3838781befc1b58a6" id="r_abd1da85e48a030a3838781befc1b58a6"><td class="memItemLeft" align="right" valign="top"><a id="abd1da85e48a030a3838781befc1b58a6" name="abd1da85e48a030a3838781befc1b58a6"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; IVW_MODULE_BASE_API&#160;</td><td class="memItemRight" valign="bottom"><b>convertHullToMesh</b> (const std::vector&lt; vec2 &gt; &amp;hull, bool useIndices=false)</td></tr>
<tr class="separator:abd1da85e48a030a3838781befc1b58a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180d75d9fae76897cebcd13a17c666d7" id="r_a180d75d9fae76897cebcd13a17c666d7"><td class="memItemLeft" align="right" valign="top"><a id="a180d75d9fae76897cebcd13a17c666d7" name="a180d75d9fae76897cebcd13a17c666d7"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeMinMax</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a180d75d9fae76897cebcd13a17c666d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ecdc3de3734eea621ffa06153b4ad4" id="r_ad1ecdc3de3734eea621ffa06153b4ad4"><td class="memItemLeft" align="right" valign="top"><a id="ad1ecdc3de3734eea621ffa06153b4ad4" name="ad1ecdc3de3734eea621ffa06153b4ad4"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>layerMinMax</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:ad1ecdc3de3734eea621ffa06153b4ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d2d204238b274711ad05bb7d99e24b" id="r_a40d2d204238b274711ad05bb7d99e24b"><td class="memItemLeft" align="right" valign="top"><a id="a40d2d204238b274711ad05bb7d99e24b" name="a40d2d204238b274711ad05bb7d99e24b"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bufferMinMax</b> (const <a class="el" href="classinviwo_1_1BufferRAM.html">BufferRAM</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a40d2d204238b274711ad05bb7d99e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d02461aeec59fc568a1edca407e77d" id="r_a66d02461aeec59fc568a1edca407e77d"><td class="memItemLeft" align="right" valign="top"><a id="a66d02461aeec59fc568a1edca407e77d" name="a66d02461aeec59fc568a1edca407e77d"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeMinMax</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a66d02461aeec59fc568a1edca407e77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe170b7ad56521599a2f3e401de8392" id="r_aafe170b7ad56521599a2f3e401de8392"><td class="memItemLeft" align="right" valign="top"><a id="aafe170b7ad56521599a2f3e401de8392" name="aafe170b7ad56521599a2f3e401de8392"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>layerMinMax</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:aafe170b7ad56521599a2f3e401de8392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f84d47c526824246291b92b4c281959" id="r_a3f84d47c526824246291b92b4c281959"><td class="memItemLeft" align="right" valign="top"><a id="a3f84d47c526824246291b92b4c281959" name="a3f84d47c526824246291b92b4c281959"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bufferMinMax</b> (const <a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> *buffer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a3f84d47c526824246291b92b4c281959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49e61ebf3b11c94b3497f88bb454634" id="r_ae49e61ebf3b11c94b3497f88bb454634"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ae49e61ebf3b11c94b3497f88bb454634"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae49e61ebf3b11c94b3497f88bb454634">dataMinMax</a> (const ValueType *data, size_t size, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:ae49e61ebf3b11c94b3497f88bb454634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dfea83005204a1c4beaa3714c38e74" id="r_a90dfea83005204a1c4beaa3714c38e74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a90dfea83005204a1c4beaa3714c38e74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90dfea83005204a1c4beaa3714c38e74">layerRAMDistanceTransform</a> (const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 2, U &gt; basis, const size2_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:a90dfea83005204a1c4beaa3714c38e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197ca54aa9430e796e41f223f577635" id="r_aa197ca54aa9430e796e41f223f577635"><td class="memTemplParams" colspan="2"><a id="aa197ca54aa9430e796e41f223f577635" name="aa197ca54aa9430e796e41f223f577635"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa197ca54aa9430e796e41f223f577635"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerRAMDistanceTransform</b> (const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 2, U &gt; basis, const size2_t upsample)</td></tr>
<tr class="separator:aa197ca54aa9430e796e41f223f577635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f9879e82cc4d9c7eb77c2724b2d019" id="r_a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memTemplParams" colspan="2"><a id="a26f9879e82cc4d9c7eb77c2724b2d019" name="a26f9879e82cc4d9c7eb77c2724b2d019"></a>
template&lt;typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae4dea32beba341f6b624c183d07277" id="r_aaae4dea32beba341f6b624c183d07277"><td class="memTemplParams" colspan="2"><a id="aaae4dea32beba341f6b624c183d07277" name="aaae4dea32beba341f6b624c183d07277"></a>
template&lt;typename U , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:aaae4dea32beba341f6b624c183d07277"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, double threshold, bool normalize, bool flip, bool square, double scale, ProgressCallback callback)</td></tr>
<tr class="separator:aaae4dea32beba341f6b624c183d07277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf8c62d442b8dd2f6be424f09404859" id="r_a6cf8c62d442b8dd2f6be424f09404859"><td class="memTemplParams" colspan="2"><a id="a6cf8c62d442b8dd2f6be424f09404859" name="a6cf8c62d442b8dd2f6be424f09404859"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6cf8c62d442b8dd2f6be424f09404859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, double threshold, bool normalize, bool flip, bool square, double scale)</td></tr>
<tr class="separator:a6cf8c62d442b8dd2f6be424f09404859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36aead3fc89df1f8274c4a4ad543f2b" id="r_ab36aead3fc89df1f8274c4a4ad543f2b"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab36aead3fc89df1f8274c4a4ad543f2b">layerSubSet</a> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *in, ivec2 offset, size2_t <a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a>, bool clampBorderOutsideImage=false)</td></tr>
<tr class="memdesc:ab36aead3fc89df1f8274c4a4ad543f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a subregion from a layer and returns it as a new layer  <br /></td></tr>
<tr class="separator:ab36aead3fc89df1f8274c4a4ad543f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11440c1b6dc927f82d4ff5fd673d2ea9" id="r_a11440c1b6dc927f82d4ff5fd673d2ea9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11440c1b6dc927f82d4ff5fd673d2ea9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11440c1b6dc927f82d4ff5fd673d2ea9">typedLayerSubSet</a> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *in, ivec2 offset, size2_t <a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a>, bool clampBorderOutsideImage=false)</td></tr>
<tr class="memdesc:a11440c1b6dc927f82d4ff5fd673d2ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a subregion from a layer and converts it into a new layer  <br /></td></tr>
<tr class="separator:a11440c1b6dc927f82d4ff5fd673d2ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7308adb6800d1ef047b11afba120051" id="r_af7308adb6800d1ef047b11afba120051"><td class="memTemplParams" colspan="2"><a id="af7308adb6800d1ef047b11afba120051" name="af7308adb6800d1ef047b11afba120051"></a>
template&lt;typename T , typename OutIt &gt; </td></tr>
<tr class="memitem:af7308adb6800d1ef047b11afba120051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generatePoints</b> (OutIt outIt, std::variant&lt; <a class="el" href="structinviwo_1_1util_1_1Grid3DPointGeneration.html">Grid3DPointGeneration</a>, <a class="el" href="structinviwo_1_1util_1_1RandomCubicalPointGeneration.html">RandomCubicalPointGeneration</a>, <a class="el" href="structinviwo_1_1util_1_1RandomSphericalPointGeneration.html">RandomSphericalPointGeneration</a> &gt; opts)</td></tr>
<tr class="separator:af7308adb6800d1ef047b11afba120051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a4886800ee3ba916742c7158b183d4" id="r_ae4a4886800ee3ba916742c7158b183d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4a4886800ee3ba916742c7158b183d4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae4a4886800ee3ba916742c7158b183d4">haltonSequence</a> (size_t n, size_t base)</td></tr>
<tr class="separator:ae4a4886800ee3ba916742c7158b183d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae998c98a827c0d18229a6f1775ff0a8f" id="r_ae998c98a827c0d18229a6f1775ff0a8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae998c98a827c0d18229a6f1775ff0a8f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae998c98a827c0d18229a6f1775ff0a8f">haltonSequence</a> (size2_t dims, size_t numberOfPoints, size_t baseX=2, size_t baseY=3)</td></tr>
<tr class="separator:ae998c98a827c0d18229a6f1775ff0a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5a54031ffd03ed97bb957ca8f522d3" id="r_aec5a54031ffd03ed97bb957ca8f522d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec5a54031ffd03ed97bb957ca8f522d3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec5a54031ffd03ed97bb957ca8f522d3">haltonSequence</a> (size3_t dims, size_t numberOfPoints, size_t baseX=2, size_t baseY=3, size_t baseZ=5)</td></tr>
<tr class="separator:aec5a54031ffd03ed97bb957ca8f522d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2f672f99a31ee8b19f6f40fa768cb" id="r_a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48b2f672f99a31ee8b19f6f40fa768cb">randomSequence</a> (T *data, size_t numberOfElements, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe4e9668671b9b73896e7d737763045" id="r_aebe4e9668671b9b73896e7d737763045"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:aebe4e9668671b9b73896e7d737763045"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebe4e9668671b9b73896e7d737763045">randomSequence</a> (std::span&lt; T &gt; data, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:aebe4e9668671b9b73896e7d737763045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab539d0cecda1edf6ee5ecfe6949f38d5" id="r_ab539d0cecda1edf6ee5ecfe6949f38d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:ab539d0cecda1edf6ee5ecfe6949f38d5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab539d0cecda1edf6ee5ecfe6949f38d5">randomLayerRAM</a> (size2_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:ab539d0cecda1edf6ee5ecfe6949f38d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb28155c56d675b83c5dc803d0a844a1" id="r_acb28155c56d675b83c5dc803d0a844a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:acb28155c56d675b83c5dc803d0a844a1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb28155c56d675b83c5dc803d0a844a1">randomLayer</a> (size2_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:acb28155c56d675b83c5dc803d0a844a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27779344a8c3a59f6cb41222bea0b8e2" id="r_a27779344a8c3a59f6cb41222bea0b8e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a27779344a8c3a59f6cb41222bea0b8e2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27779344a8c3a59f6cb41222bea0b8e2">randomVolume</a> (size3_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a27779344a8c3a59f6cb41222bea0b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a361515d9e7661be39f493d796dca6" id="r_a35a361515d9e7661be39f493d796dca6"><td class="memTemplParams" colspan="2">template&lt;typename Rand  = std::mt19937&gt; </td></tr>
<tr class="memitem:a35a361515d9e7661be39f493d796dca6"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a35a361515d9e7661be39f493d796dca6">perlinNoise</a> (size2_t dims, float persistence, size_t startLevel, size_t endLevel, Rand &amp;randomNumberGenerator=Rand())</td></tr>
<tr class="separator:a35a361515d9e7661be39f493d796dca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b0885e5f02bce9ed3ef708fe9ff059" id="r_a71b0885e5f02bce9ed3ef708fe9ff059"><td class="memTemplParams" colspan="2">template&lt;typename Rand  = std::mt19937&gt; </td></tr>
<tr class="memitem:a71b0885e5f02bce9ed3ef708fe9ff059"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71b0885e5f02bce9ed3ef708fe9ff059">poissonDisk</a> (size2_t dims, size_t poissonDotsAlongX, size_t maxPoints, Rand &amp;randomNumberGenerator=Rand())</td></tr>
<tr class="separator:a71b0885e5f02bce9ed3ef708fe9ff059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bec0b925a8be26aebea592ce1b00fd2" id="r_a5bec0b925a8be26aebea592ce1b00fd2"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bec0b925a8be26aebea592ce1b00fd2">marchingcubes</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback=std::function&lt; void(float)&gt;(), std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback=[](const size3_t &amp;) { return true;})</td></tr>
<tr class="separator:a5bec0b925a8be26aebea592ce1b00fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264903a207983c82b75a97aaa2a69545" id="r_a264903a207983c82b75a97aaa2a69545"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a264903a207983c82b75a97aaa2a69545">marchingCubesOpt</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback=nullptr, std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback=nullptr)</td></tr>
<tr class="separator:a264903a207983c82b75a97aaa2a69545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c658162fd0c9fb67eb70cfd537e52" id="r_ad05c658162fd0c9fb67eb70cfd537e52"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad05c658162fd0c9fb67eb70cfd537e52">marchingtetrahedron</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color=vec4(1.0f), bool invert=false, bool enclose=true, std::function&lt; void(float)&gt; progressCallback=std::function&lt; void(float)&gt;(), std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback=[](const size3_t &amp;) { return true;})</td></tr>
<tr class="separator:ad05c658162fd0c9fb67eb70cfd537e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a40a272e79f771e627d2865ad5c61d3" id="r_a9a40a272e79f771e627d2865ad5c61d3"><td class="memItemLeft" align="right" valign="top"><a id="a9a40a272e79f771e627d2865ad5c61d3" name="a9a40a272e79f771e627d2865ad5c61d3"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curlVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume)</td></tr>
<tr class="separator:a9a40a272e79f771e627d2865ad5c61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868dce49fd3bb5fe1e00ae21741e17df" id="r_a868dce49fd3bb5fe1e00ae21741e17df"><td class="memItemLeft" align="right" valign="top"><a id="a868dce49fd3bb5fe1e00ae21741e17df" name="a868dce49fd3bb5fe1e00ae21741e17df"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curlVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:a868dce49fd3bb5fe1e00ae21741e17df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c2e18ffbb9555e3e09fa311430f8eb" id="r_ae2c2e18ffbb9555e3e09fa311430f8eb"><td class="memItemLeft" align="right" valign="top"><a id="ae2c2e18ffbb9555e3e09fa311430f8eb" name="ae2c2e18ffbb9555e3e09fa311430f8eb"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>divergenceVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:ae2c2e18ffbb9555e3e09fa311430f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060da6b81ba276eccef48950775f5d0" id="r_a4060da6b81ba276eccef48950775f5d0"><td class="memItemLeft" align="right" valign="top"><a id="a4060da6b81ba276eccef48950775f5d0" name="a4060da6b81ba276eccef48950775f5d0"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>divergenceVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume)</td></tr>
<tr class="separator:a4060da6b81ba276eccef48950775f5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b4e4950c7c433f359ad1e2e32c8ac" id="r_af36b4e4950c7c433f359ad1e2e32c8ac"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:af36b4e4950c7c433f359ad1e2e32c8ac"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af36b4e4950c7c433f359ad1e2e32c8ac">generateVolume</a> (const size3_t &amp;dimensions, const mat3 &amp;basis, Functor &amp;&amp;function)</td></tr>
<tr class="separator:af36b4e4950c7c433f359ad1e2e32c8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb99c263ef07f00a0892cf1d9610d15" id="r_a5bb99c263ef07f00a0892cf1d9610d15"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a5bb99c263ef07f00a0892cf1d9610d15"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bb99c263ef07f00a0892cf1d9610d15">makeSingleVoxelVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a5bb99c263ef07f00a0892cf1d9610d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351bc675bcbde3fa893929b312a1b276" id="r_a351bc675bcbde3fa893929b312a1b276"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a351bc675bcbde3fa893929b312a1b276"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a351bc675bcbde3fa893929b312a1b276">makeSphericalVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a351bc675bcbde3fa893929b312a1b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5167c56b9fc5c53f102462d89bbf1f11" id="r_a5167c56b9fc5c53f102462d89bbf1f11"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a5167c56b9fc5c53f102462d89bbf1f11"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5167c56b9fc5c53f102462d89bbf1f11">makeRippleVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a5167c56b9fc5c53f102462d89bbf1f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab618818fcbf3c386f0f07928ce06821f" id="r_ab618818fcbf3c386f0f07928ce06821f"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:ab618818fcbf3c386f0f07928ce06821f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab618818fcbf3c386f0f07928ce06821f">makeMarchingCubeVolume</a> (const size_t &amp;index)</td></tr>
<tr class="separator:ab618818fcbf3c386f0f07928ce06821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fdb400eaf78b7f8917d0c208296133" id="r_ac4fdb400eaf78b7f8917d0c208296133"><td class="memItemLeft" align="right" valign="top"><a id="ac4fdb400eaf78b7f8917d0c208296133" name="ac4fdb400eaf78b7f8917d0c208296133"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gradientVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, int channel)</td></tr>
<tr class="separator:ac4fdb400eaf78b7f8917d0c208296133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a8c467e8ff8b7198cb16f4bacb6755" id="r_af6a8c467e8ff8b7198cb16f4bacb6755"><td class="memItemLeft" align="right" valign="top"><a id="af6a8c467e8ff8b7198cb16f4bacb6755" name="af6a8c467e8ff8b7198cb16f4bacb6755"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeLaplacian</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, VolumeLaplacianPostProcessing postProcessing, double scale)</td></tr>
<tr class="separator:af6a8c467e8ff8b7198cb16f4bacb6755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21094bd4eae6e9a668b25cf52d70fa2c" id="r_a21094bd4eae6e9a668b25cf52d70fa2c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a21094bd4eae6e9a668b25cf52d70fa2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21094bd4eae6e9a668b25cf52d70fa2c">volumeRAMDistanceTransform</a> (const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 3, U &gt; &amp;basis, const size3_t &amp;upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback progress)</td></tr>
<tr class="separator:a21094bd4eae6e9a668b25cf52d70fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000dfa6514e8260281ffb35ee10253c5" id="r_a000dfa6514e8260281ffb35ee10253c5"><td class="memTemplParams" colspan="2"><a id="a000dfa6514e8260281ffb35ee10253c5" name="a000dfa6514e8260281ffb35ee10253c5"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a000dfa6514e8260281ffb35ee10253c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeRAMDistanceTransform</b> (const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 3, U &gt; &amp;basis, const size3_t &amp;upsample)</td></tr>
<tr class="separator:a000dfa6514e8260281ffb35ee10253c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bdfc957fafc066dc99603d09301321" id="r_a86bdfc957fafc066dc99603d09301321"><td class="memTemplParams" colspan="2"><a id="a86bdfc957fafc066dc99603d09301321" name="a86bdfc957fafc066dc99603d09301321"></a>
template&lt;typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a86bdfc957fafc066dc99603d09301321"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t &amp;upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback progress)</td></tr>
<tr class="separator:a86bdfc957fafc066dc99603d09301321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaad1951b0feb8062e21fba6d4d3c862" id="r_abaad1951b0feb8062e21fba6d4d3c862"><td class="memTemplParams" colspan="2"><a id="abaad1951b0feb8062e21fba6d4d3c862" name="abaad1951b0feb8062e21fba6d4d3c862"></a>
template&lt;typename U , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:abaad1951b0feb8062e21fba6d4d3c862"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t &amp;upsample, double threshold, bool normalize, bool flip, bool square, double scale, ProgressCallback progress)</td></tr>
<tr class="separator:abaad1951b0feb8062e21fba6d4d3c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fcc3980d8e07d143351b3964765eef" id="r_a37fcc3980d8e07d143351b3964765eef"><td class="memTemplParams" colspan="2"><a id="a37fcc3980d8e07d143351b3964765eef" name="a37fcc3980d8e07d143351b3964765eef"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a37fcc3980d8e07d143351b3964765eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t &amp;upsample, double threshold, bool normalize, bool flip, bool square, double scale)</td></tr>
<tr class="separator:a37fcc3980d8e07d143351b3964765eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ff91fe7e398366d3653bb8145922a4" id="r_aa6ff91fe7e398366d3653bb8145922a4"><td class="memItemLeft" align="right" valign="top"><a id="aa6ff91fe7e398366d3653bb8145922a4" name="aa6ff91fe7e398366d3653bb8145922a4"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeSubSample</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *in, size3_t factors)</td></tr>
<tr class="separator:aa6ff91fe7e398366d3653bb8145922a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a19842e043a90aa4498f0e706a0510" id="r_a46a19842e043a90aa4498f0e706a0510"><td class="memItemLeft" align="right" valign="top"><a id="a46a19842e043a90aa4498f0e706a0510" name="a46a19842e043a90aa4498f0e706a0510"></a>
IVW_MODULE_BASE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>volumeSignificantVoxels</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a46a19842e043a90aa4498f0e706a0510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9402f8b933d12f71410d3cc938691e9" id="r_aa9402f8b933d12f71410d3cc938691e9"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9402f8b933d12f71410d3cc938691e9">voronoiSegmentation</a> (const size3_t volumeDimensions, const mat4 &amp;indexToDataMatrix, const mat4 &amp;dataToModelMatrix, const std::vector&lt; std::pair&lt; uint32_t, vec3 &gt; &gt; &amp;seedPointsWithIndices, const Wrapping3D &amp;wrapping, const std::optional&lt; std::vector&lt; float &gt; &gt; &amp;weights)</td></tr>
<tr class="separator:aa9402f8b933d12f71410d3cc938691e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcff2c39824635da98bc8944a01ce1a" id="r_a0bcff2c39824635da98bc8944a01ce1a"><td class="memItemLeft" align="right" valign="top"><a id="a0bcff2c39824635da98bc8944a01ce1a" name="a0bcff2c39824635da98bc8944a01ce1a"></a>
IVW_MODULE_BASE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>writeDatVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;data, const std::filesystem::path &amp;filePath, Overwrite overwrite=Overwrite::No)</td></tr>
<tr class="separator:a0bcff2c39824635da98bc8944a01ce1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366b7461e603c7bb7bf6dd161a6ddd8e" id="r_a366b7461e603c7bb7bf6dd161a6ddd8e"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a366b7461e603c7bb7bf6dd161a6ddd8e">writeIvfVolumeSequence</a> (const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;volumes, std::string_view name, const std::filesystem::path &amp;path, std::string_view relativePathToElements=&quot;&quot;, Overwrite overwrite=Overwrite::Yes)</td></tr>
<tr class="memdesc:a366b7461e603c7bb7bf6dd161a6ddd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a volume sequence to disk.  <br /></td></tr>
<tr class="separator:a366b7461e603c7bb7bf6dd161a6ddd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06301c3bfc8c4686b656864c8c1439d" id="r_ab06301c3bfc8c4686b656864c8c1439d"><td class="memItemLeft" align="right" valign="top"><a id="ab06301c3bfc8c4686b656864c8c1439d" name="ab06301c3bfc8c4686b656864c8c1439d"></a>
IVW_MODULE_BASE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>writeIvfVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;data, const std::filesystem::path &amp;filePath, Overwrite overwrite=Overwrite::No)</td></tr>
<tr class="separator:ab06301c3bfc8c4686b656864c8c1439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851de99b7e0ac552532a3aaeed25e3d9" id="r_a851de99b7e0ac552532a3aaeed25e3d9"><td class="memItemLeft" align="right" valign="top"><a id="a851de99b7e0ac552532a3aaeed25e3d9" name="a851de99b7e0ac552532a3aaeed25e3d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateReaderFromFile</b> (const <a class="el" href="classinviwo_1_1FileProperty.html">FileProperty</a> &amp;filePath, <a class="el" href="classinviwo_1_1OptionProperty.html">OptionProperty</a>&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;extensions)</td></tr>
<tr class="separator:a851de99b7e0ac552532a3aaeed25e3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fc0b7ffa7cb2fc59de89c5392a5980" id="r_aa8fc0b7ffa7cb2fc59de89c5392a5980"><td class="memTemplParams" colspan="2"><a id="aa8fc0b7ffa7cb2fc59de89c5392a5980" name="aa8fc0b7ffa7cb2fc59de89c5392a5980"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aa8fc0b7ffa7cb2fc59de89c5392a5980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateFilenameFilters</b> (const <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> &amp;rf, <a class="el" href="classinviwo_1_1FileProperty.html">FileProperty</a> &amp;filePath, <a class="el" href="classinviwo_1_1OptionProperty.html">OptionProperty</a>&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;optionProperty)</td></tr>
<tr class="separator:aa8fc0b7ffa7cb2fc59de89c5392a5980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa788814c50164c72361d1e694439182c" id="r_aa788814c50164c72361d1e694439182c"><td class="memTemplParams" colspan="2"><a id="aa788814c50164c72361d1e694439182c" name="aa788814c50164c72361d1e694439182c"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa788814c50164c72361d1e694439182c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm2eigen</b> (const T &amp;elem) -&gt; Eigen::Matrix&lt; typename T::value_type, <a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T, 0 &gt;::value, 1 &gt;</td></tr>
<tr class="separator:aa788814c50164c72361d1e694439182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a657c60e875cedc887757eed4e19ad7" id="r_a8a657c60e875cedc887757eed4e19ad7"><td class="memTemplParams" colspan="2"><a id="a8a657c60e875cedc887757eed4e19ad7" name="a8a657c60e875cedc887757eed4e19ad7"></a>
template&lt;typename T , unsigned Rows, unsigned Cols, typename std::enable_if&lt;(Rows &gt;=2 &amp;&amp;Rows&lt;=4 &amp;&amp;Cols &gt;=2 &amp;&amp;Cols&lt;=4), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8a657c60e875cedc887757eed4e19ad7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen2glm</b> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="separator:a8a657c60e875cedc887757eed4e19ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bf79aba70128387f4271031a7d37d9" id="r_ab2bf79aba70128387f4271031a7d37d9"><td class="memTemplParams" colspan="2"><a id="ab2bf79aba70128387f4271031a7d37d9" name="ab2bf79aba70128387f4271031a7d37d9"></a>
template&lt;typename T , unsigned Rows, unsigned Cols, typename std::enable_if&lt;(Cols &gt;=2 &amp;&amp;Cols&lt;=4 &amp;&amp;Rows==1), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab2bf79aba70128387f4271031a7d37d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen2glm</b> (const Eigen::Matrix&lt; T, Cols, Cols &gt; &amp;m)</td></tr>
<tr class="separator:ab2bf79aba70128387f4271031a7d37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520165892abd0e5fdde34d66c53448a9" id="r_a520165892abd0e5fdde34d66c53448a9"><td class="memTemplParams" colspan="2"><a id="a520165892abd0e5fdde34d66c53448a9" name="a520165892abd0e5fdde34d66c53448a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a520165892abd0e5fdde34d66c53448a9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigenMatToImage</b> (const T &amp;m, bool flipY=false, std::string name=&quot;&quot;)</td></tr>
<tr class="separator:a520165892abd0e5fdde34d66c53448a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1e0f2ae3a7b52b3a951b6fff0411b2" id="r_a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_FONTRENDERING_API <a class="el" href="structinviwo_1_1TextTextureObject.html">TextTextureObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1e0f2ae3a7b52b3a951b6fff0411b2">createTextTextureObject</a> (<a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;textRenderer, std::string text, vec4 fontColor, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; tex=nullptr)</td></tr>
<tr class="memdesc:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture with rendered text for a given string including its bounding box.  <br /></td></tr>
<tr class="separator:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7100edcb0e8721bc861233332b7d2c" id="r_a4b7100edcb0e8721bc861233332b7d2c"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_FONTRENDERING_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b7100edcb0e8721bc861233332b7d2c">createTextTexture</a> (<a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;textRenderer, std::string text, vec4 fontColor, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; tex=nullptr)</td></tr>
<tr class="memdesc:a4b7100edcb0e8721bc861233332b7d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture with rendered text for a given string.  <br /></td></tr>
<tr class="separator:a4b7100edcb0e8721bc861233332b7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9c6d9a11c0384e31ffbcdc2fdf83a3" id="r_a9d9c6d9a11c0384e31ffbcdc2fdf83a3"><td class="memItemLeft" align="right" valign="top"><a id="a9d9c6d9a11c0384e31ffbcdc2fdf83a3" name="a9d9c6d9a11c0384e31ffbcdc2fdf83a3"></a>
IVW_MODULE_GLFW_API MouseButton&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMouseButton</b> (int mouseButtonGLFW)</td></tr>
<tr class="separator:a9d9c6d9a11c0384e31ffbcdc2fdf83a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721227f550ec8159e81af51df349b5cb" id="r_a721227f550ec8159e81af51df349b5cb"><td class="memItemLeft" align="right" valign="top"><a id="a721227f550ec8159e81af51df349b5cb" name="a721227f550ec8159e81af51df349b5cb"></a>
IVW_MODULE_GLFW_API MouseState&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMouseState</b> (int mouseStateGLFW)</td></tr>
<tr class="separator:a721227f550ec8159e81af51df349b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05df5a637223f4c690d7d136137daff7" id="r_a05df5a637223f4c690d7d136137daff7"><td class="memItemLeft" align="right" valign="top"><a id="a05df5a637223f4c690d7d136137daff7" name="a05df5a637223f4c690d7d136137daff7"></a>
IVW_MODULE_GLFW_API KeyModifiers&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWModifiers</b> (int modifiersGLFW)</td></tr>
<tr class="separator:a05df5a637223f4c690d7d136137daff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6451925eaf258ea3a2a0532025dce" id="r_ad5d6451925eaf258ea3a2a0532025dce"><td class="memItemLeft" align="right" valign="top"><a id="ad5d6451925eaf258ea3a2a0532025dce" name="ad5d6451925eaf258ea3a2a0532025dce"></a>
IVW_MODULE_GLFW_API KeyState&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMKeyState</b> (int actionGLFW)</td></tr>
<tr class="separator:ad5d6451925eaf258ea3a2a0532025dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750cb44109ec8f9e4e82c4eca174a17f" id="r_a750cb44109ec8f9e4e82c4eca174a17f"><td class="memItemLeft" align="right" valign="top"><a id="a750cb44109ec8f9e4e82c4eca174a17f" name="a750cb44109ec8f9e4e82c4eca174a17f"></a>
IVW_MODULE_GLFW_API IvwKey&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMKey</b> (int keyGLFW)</td></tr>
<tr class="separator:a750cb44109ec8f9e4e82c4eca174a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1e393c6d76cb9610473161c31af319" id="r_a1f1e393c6d76cb9610473161c31af319"><td class="memItemLeft" align="right" valign="top"><a id="a1f1e393c6d76cb9610473161c31af319" name="a1f1e393c6d76cb9610473161c31af319"></a>
IVW_MODULE_QTWIDGETS_API IvwKey&#160;</td><td class="memItemRight" valign="bottom"><b>mapKeyFromQt</b> (const QKeyEvent *keyevent)</td></tr>
<tr class="separator:a1f1e393c6d76cb9610473161c31af319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31935311aa385c7be386842692bb1d71" id="r_a31935311aa385c7be386842692bb1d71"><td class="memItemLeft" align="right" valign="top"><a id="a31935311aa385c7be386842692bb1d71" name="a31935311aa385c7be386842692bb1d71"></a>
IVW_MODULE_QTWIDGETS_API ModifierAction&#160;</td><td class="memItemRight" valign="bottom"><b>getModifierAction</b> (Qt::KeyboardModifiers modifiers)</td></tr>
<tr class="separator:a31935311aa385c7be386842692bb1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f38b5e8688ab35d2adc3f29daafda0d" id="r_a2f38b5e8688ab35d2adc3f29daafda0d"><td class="memItemLeft" align="right" valign="top"><a id="a2f38b5e8688ab35d2adc3f29daafda0d" name="a2f38b5e8688ab35d2adc3f29daafda0d"></a>
IVW_MODULE_QTWIDGETS_API MouseCursor&#160;</td><td class="memItemRight" valign="bottom"><b>fromCursorShape</b> (const Qt::CursorShape cursor)</td></tr>
<tr class="separator:a2f38b5e8688ab35d2adc3f29daafda0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71be815e81cb5f54def2620dfa51d12" id="r_ac71be815e81cb5f54def2620dfa51d12"><td class="memItemLeft" align="right" valign="top"><a id="ac71be815e81cb5f54def2620dfa51d12" name="ac71be815e81cb5f54def2620dfa51d12"></a>
IVW_MODULE_QTWIDGETS_API Qt::CursorShape&#160;</td><td class="memItemRight" valign="bottom"><b>toCursorShape</b> (const MouseCursor cursor)</td></tr>
<tr class="separator:ac71be815e81cb5f54def2620dfa51d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0d09b6d1537336c6e8271dcd557c93" id="r_aed0d09b6d1537336c6e8271dcd557c93"><td class="memTemplParams" colspan="2"><a id="aed0d09b6d1537336c6e8271dcd557c93" name="aed0d09b6d1537336c6e8271dcd557c93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed0d09b6d1537336c6e8271dcd557c93"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spherical</b> (T val)</td></tr>
<tr class="separator:aed0d09b6d1537336c6e8271dcd557c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90162d1deee488866fd8a45d341ef3e" id="r_af90162d1deee488866fd8a45d341ef3e"><td class="memTemplParams" colspan="2"><a id="af90162d1deee488866fd8a45d341ef3e" name="af90162d1deee488866fd8a45d341ef3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af90162d1deee488866fd8a45d341ef3e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>euclidean</b> (T val)</td></tr>
<tr class="separator:af90162d1deee488866fd8a45d341ef3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4897a3d44e5783c20282e56a1a2a47" id="r_a2e4897a3d44e5783c20282e56a1a2a47"><td class="memTemplParams" colspan="2"><a id="a2e4897a3d44e5783c20282e56a1a2a47" name="a2e4897a3d44e5783c20282e56a1a2a47"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a2e4897a3d44e5783c20282e56a1a2a47"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_qptr</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a2e4897a3d44e5783c20282e56a1a2a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9a27c97b0b7391d9538f03a329b4d0" id="r_afd9a27c97b0b7391d9538f03a329b4d0"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1TransferFunction.html">TransferFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9a27c97b0b7391d9538f03a329b4d0">importTransferFunctionDialog</a> (QWidget *parent=nullptr)</td></tr>
<tr class="memdesc:afd9a27c97b0b7391d9538f03a329b4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to import a <a class="el" href="classinviwo_1_1TransferFunction.html" title="data structure for holding 1D transfer function data">TransferFunction</a> from a file.  <br /></td></tr>
<tr class="separator:afd9a27c97b0b7391d9538f03a329b4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7336f466792bdd174b745bd6285048bc" id="r_a7336f466792bdd174b745bd6285048bc"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7336f466792bdd174b745bd6285048bc">exportTransferFunctionDialog</a> (const <a class="el" href="classinviwo_1_1TransferFunction.html">TransferFunction</a> &amp;tf, QWidget *parent=nullptr)</td></tr>
<tr class="memdesc:a7336f466792bdd174b745bd6285048bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to export a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> to a file.  <br /></td></tr>
<tr class="separator:a7336f466792bdd174b745bd6285048bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36a5eb1a40ce3beee139b0564980a54" id="r_af36a5eb1a40ce3beee139b0564980a54"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1IsoValueCollection.html">IsoValueCollection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36a5eb1a40ce3beee139b0564980a54">importIsoValueCollectionDialog</a> (QWidget *parent=nullptr)</td></tr>
<tr class="memdesc:af36a5eb1a40ce3beee139b0564980a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to import a <a class="el" href="classinviwo_1_1IsoValueCollection.html" title="data structure representing isovalues">IsoValueCollection</a> from a file.  <br /></td></tr>
<tr class="separator:af36a5eb1a40ce3beee139b0564980a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754bddb595bebae365189d7de121ec9a" id="r_a754bddb595bebae365189d7de121ec9a"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a754bddb595bebae365189d7de121ec9a">exportIsoValueCollectionDialog</a> (const <a class="el" href="classinviwo_1_1IsoValueCollection.html">IsoValueCollection</a> &amp;iso, QWidget *parent=nullptr)</td></tr>
<tr class="memdesc:a754bddb595bebae365189d7de121ec9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to export a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> to a file.  <br /></td></tr>
<tr class="separator:a754bddb595bebae365189d7de121ec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416c8d9416964edc5a92908f30761f6f" id="r_a416c8d9416964edc5a92908f30761f6f"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API QMenu *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416c8d9416964edc5a92908f30761f6f">addTFPresetsMenu</a> (QWidget *parent, QMenu *menu, <a class="el" href="classinviwo_1_1TransferFunctionProperty.html">TransferFunctionProperty</a> *property)</td></tr>
<tr class="memdesc:a416c8d9416964edc5a92908f30761f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a submenu containing entries for TF presets of all transfer functions found in the path <code>PathType::TransferFunctions</code>. Upon selecting a menu entry, the respective preset will be loaded by <code>property</code>. The submenu will be disabled if <code>property</code> is read-only.  <br /></td></tr>
<tr class="separator:a416c8d9416964edc5a92908f30761f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a47074b1152f84ef78728a58c5dfadc" id="r_a8a47074b1152f84ef78728a58c5dfadc"><td class="memItemLeft" align="right" valign="top"><a id="a8a47074b1152f84ef78728a58c5dfadc" name="a8a47074b1152f84ef78728a58c5dfadc"></a>
IVW_MODULE_QTWIDGETS_API QMenu *&#160;</td><td class="memItemRight" valign="bottom"><b>addTFColorbrewerPresetsMenu</b> (QWidget *parent, QMenu *menu, <a class="el" href="classinviwo_1_1TransferFunctionProperty.html">TransferFunctionProperty</a> *property)</td></tr>
<tr class="separator:a8a47074b1152f84ef78728a58c5dfadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993ef3397d70d4fb0b6e6656eafc07da" id="r_a993ef3397d70d4fb0b6e6656eafc07da"><td class="memItemLeft" align="right" valign="top"><a id="a993ef3397d70d4fb0b6e6656eafc07da" name="a993ef3397d70d4fb0b6e6656eafc07da"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>encode</b> (const std::vector&lt; SgctCommand &gt; &amp;commands) -&gt; std::vector&lt; std::byte &gt;</td></tr>
<tr class="separator:a993ef3397d70d4fb0b6e6656eafc07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9edb527d7dc8f8b29c18606a66f4e6" id="r_aea9edb527d7dc8f8b29c18606a66f4e6"><td class="memItemLeft" align="right" valign="top"><a id="aea9edb527d7dc8f8b29c18606a66f4e6" name="aea9edb527d7dc8f8b29c18606a66f4e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>decode</b> (const std::vector&lt; std::byte &gt; &amp;bytes, std::vector&lt; SgctCommand &gt; &amp;commands)</td></tr>
<tr class="separator:aea9edb527d7dc8f8b29c18606a66f4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eac5edc8e0eebb1b6f03a9ff1e4a66" id="r_a10eac5edc8e0eebb1b6f03a9ff1e4a66"><td class="memItemLeft" align="right" valign="top"><a id="a10eac5edc8e0eebb1b6f03a9ff1e4a66" name="a10eac5edc8e0eebb1b6f03a9ff1e4a66"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>sgctToInviwo</b> (sgct::Log::Level level) -&gt; inviwo::LogLevel</td></tr>
<tr class="separator:a10eac5edc8e0eebb1b6f03a9ff1e4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1587f7d20a684086041c0b7bc6533f" id="r_ade1587f7d20a684086041c0b7bc6533f"><td class="memItemLeft" align="right" valign="top"><a id="ade1587f7d20a684086041c0b7bc6533f" name="ade1587f7d20a684086041c0b7bc6533f"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (const <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:ade1587f7d20a684086041c0b7bc6533f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75398e19046de300d6ea0cb727a87794" id="r_a75398e19046de300d6ea0cb727a87794"><td class="memItemLeft" align="right" valign="top"><a id="a75398e19046de300d6ea0cb727a87794" name="a75398e19046de300d6ea0cb727a87794"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (const <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:a75398e19046de300d6ea0cb727a87794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976d5326c5647d7a9063209eee9ca75c" id="r_a976d5326c5647d7a9063209eee9ca75c"><td class="memItemLeft" align="right" valign="top"><a id="a976d5326c5647d7a9063209eee9ca75c" name="a976d5326c5647d7a9063209eee9ca75c"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a976d5326c5647d7a9063209eee9ca75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd7dfed95f3b9fcc29d2421e3d69f3" id="r_adcbd7dfed95f3b9fcc29d2421e3d69f3"><td class="memItemLeft" align="right" valign="top"><a id="adcbd7dfed95f3b9fcc29d2421e3d69f3" name="adcbd7dfed95f3b9fcc29d2421e3d69f3"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:adcbd7dfed95f3b9fcc29d2421e3d69f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5aa12285d95c1792955d4c32de5b29" id="r_a6a5aa12285d95c1792955d4c32de5b29"><td class="memItemLeft" align="right" valign="top"><a id="a6a5aa12285d95c1792955d4c32de5b29" name="a6a5aa12285d95c1792955d4c32de5b29"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (const <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a6a5aa12285d95c1792955d4c32de5b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d946d516e1f1f4aaf698472e30486c" id="r_aa9d946d516e1f1f4aaf698472e30486c"><td class="memItemLeft" align="right" valign="top"><a id="aa9d946d516e1f1f4aaf698472e30486c" name="aa9d946d516e1f1f4aaf698472e30486c"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (const <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:aa9d946d516e1f1f4aaf698472e30486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b08c3d3861ad6c1820ef8bda2a11d3" id="r_a79b08c3d3861ad6c1820ef8bda2a11d3"><td class="memItemLeft" align="right" valign="top"><a id="a79b08c3d3861ad6c1820ef8bda2a11d3" name="a79b08c3d3861ad6c1820ef8bda2a11d3"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a79b08c3d3861ad6c1820ef8bda2a11d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8cf4d5c05f1080f751a389346a2ef7" id="r_a8b8cf4d5c05f1080f751a389346a2ef7"><td class="memItemLeft" align="right" valign="top"><a id="a8b8cf4d5c05f1080f751a389346a2ef7" name="a8b8cf4d5c05f1080f751a389346a2ef7"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:a8b8cf4d5c05f1080f751a389346a2ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9375ead98669b8a4b58850f90bdd4248" id="r_a9375ead98669b8a4b58850f90bdd4248"><td class="memItemLeft" align="right" valign="top">void IVW_MODULE_VOLUME_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9375ead98669b8a4b58850f90bdd4248">remap</a> (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume, const std::vector&lt; int &gt; &amp;src, const std::vector&lt; int &gt; &amp;dst, int missingValue, bool useMissingValue)</td></tr>
<tr class="separator:a9375ead98669b8a4b58850f90bdd4248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa77c5fb17124dd9cfba51391fd9e0b52" id="r_aa77c5fb17124dd9cfba51391fd9e0b52"><td class="memItemLeft" align="right" valign="top"><a id="aa77c5fb17124dd9cfba51391fd9e0b52" name="aa77c5fb17124dd9cfba51391fd9e0b52"></a>
constexpr std::array&lt; std::string_view, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>defaultAxesNames</b> = {&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;t&quot;}</td></tr>
<tr class="separator:aa77c5fb17124dd9cfba51391fd9e0b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b407ab7fe241ff85c95d78cd2d440d" id="r_a56b407ab7fe241ff85c95d78cd2d440d"><td class="memItemLeft" align="right" valign="top"><a id="a56b407ab7fe241ff85c95d78cd2d440d" name="a56b407ab7fe241ff85c95d78cd2d440d"></a>
constexpr std::array&lt; Unit, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>defaultAxesUnits</b> = {Unit{}, Unit{}, Unit{}, Unit{}}</td></tr>
<tr class="separator:a56b407ab7fe241ff85c95d78cd2d440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d951ef356d1f9ac02d3028302f9d1c" id="r_a75d951ef356d1f9ac02d3028302f9d1c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d951ef356d1f9ac02d3028302f9d1c">defaultIdGetter</a></td></tr>
<tr class="separator:a75d951ef356d1f9ac02d3028302f9d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcd5c22b1d7609d0bfa1ac9c2366137" id="r_a5bcd5c22b1d7609d0bfa1ac9c2366137"><td class="memTemplParams" colspan="2"><a id="a5bcd5c22b1d7609d0bfa1ac9c2366137" name="a5bcd5c22b1d7609d0bfa1ac9c2366137"></a>
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a5bcd5c22b1d7609d0bfa1ac9c2366137"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_v</b> = is_detected&lt;Op, Args...&gt;::value</td></tr>
<tr class="separator:a5bcd5c22b1d7609d0bfa1ac9c2366137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c054be71dbad108fc08c950133f5d8" id="r_a97c054be71dbad108fc08c950133f5d8"><td class="memTemplParams" colspan="2"><a id="a97c054be71dbad108fc08c950133f5d8" name="a97c054be71dbad108fc08c950133f5d8"></a>
template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a97c054be71dbad108fc08c950133f5d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact_v</b> = is_detected_exact&lt;Expected, Op, Args...&gt;::value</td></tr>
<tr class="separator:a97c054be71dbad108fc08c950133f5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60aebc069e6ffb95eec6e91c1b8473d" id="r_ab60aebc069e6ffb95eec6e91c1b8473d"><td class="memTemplParams" colspan="2"><a id="ab60aebc069e6ffb95eec6e91c1b8473d" name="ab60aebc069e6ffb95eec6e91c1b8473d"></a>
template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:ab60aebc069e6ffb95eec6e91c1b8473d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible_v</b> = is_detected_convertible&lt;To, Op, Args...&gt;::value</td></tr>
<tr class="separator:ab60aebc069e6ffb95eec6e91c1b8473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12d5bc485266c852e507c1982cff076" id="r_ae12d5bc485266c852e507c1982cff076"><td class="memTemplParams" colspan="2"><a id="ae12d5bc485266c852e507c1982cff076" name="ae12d5bc485266c852e507c1982cff076"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12d5bc485266c852e507c1982cff076"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_floating_point_v</b> = <a class="el" href="structinviwo_1_1util_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae12d5bc485266c852e507c1982cff076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4ef5c894b02633e6ff1d61f57fd6b" id="r_abea4ef5c894b02633e6ff1d61f57fd6b"><td class="memTemplParams" colspan="2"><a id="abea4ef5c894b02633e6ff1d61f57fd6b" name="abea4ef5c894b02633e6ff1d61f57fd6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abea4ef5c894b02633e6ff1d61f57fd6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_v</b> = <a class="el" href="structinviwo_1_1util_1_1rank.html">rank</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abea4ef5c894b02633e6ff1d61f57fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10a8a24583b2bd0047115a9e370bef6" id="r_ab10a8a24583b2bd0047115a9e370bef6"><td class="memTemplParams" colspan="2"><a id="ab10a8a24583b2bd0047115a9e370bef6" name="ab10a8a24583b2bd0047115a9e370bef6"></a>
template&lt;class T , unsigned N = 0&gt; </td></tr>
<tr class="memitem:ab10a8a24583b2bd0047115a9e370bef6"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extent_v</b> = <a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a>&lt;T, N&gt;::value</td></tr>
<tr class="separator:ab10a8a24583b2bd0047115a9e370bef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177809ac774c60ba26acf2a0434f1dd" id="r_a2177809ac774c60ba26acf2a0434f1dd"><td class="memTemplParams" colspan="2"><a id="a2177809ac774c60ba26acf2a0434f1dd" name="a2177809ac774c60ba26acf2a0434f1dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2177809ac774c60ba26acf2a0434f1dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_extent_v</b> = <a class="el" href="structinviwo_1_1util_1_1flat__extent.html">flat_extent</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a2177809ac774c60ba26acf2a0434f1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6f2c783a1cc78c23c5060fc9e8425e" id="r_a6c6f2c783a1cc78c23c5060fc9e8425e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6f2c783a1cc78c23c5060fc9e8425e">fmtHelp</a></td></tr>
<tr class="separator:a6c6f2c783a1cc78c23c5060fc9e8425e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49245a6e71202c206adbbffe5301690e" id="r_a49245a6e71202c206adbbffe5301690e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49245a6e71202c206adbbffe5301690e">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; &amp;layer)</td></tr>
<tr class="separator:a49245a6e71202c206adbbffe5301690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab279fda2d5e97b698c1c269a30ea6314" id="r_ab279fda2d5e97b698c1c269a30ea6314"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab279fda2d5e97b698c1c269a30ea6314">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a>, 0 &gt; &amp;layers)</td></tr>
<tr class="separator:ab279fda2d5e97b698c1c269a30ea6314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3328efd9d49b9501846901e6814187d6" id="r_a3328efd9d49b9501846901e6814187d6"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3328efd9d49b9501846901e6814187d6">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a>, 0, true &gt; &amp;layers)</td></tr>
<tr class="separator:a3328efd9d49b9501846901e6814187d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe50ae518a474b7e03b565b029df8e8" id="r_a1fe50ae518a474b7e03b565b029df8e8"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe50ae518a474b7e03b565b029df8e8">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; &amp;layer)</td></tr>
<tr class="separator:a1fe50ae518a474b7e03b565b029df8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49a23359f08fa4d30f61fc0c56de5a" id="r_a1b49a23359f08fa4d30f61fc0c56de5a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b49a23359f08fa4d30f61fc0c56de5a">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;mesh)</td></tr>
<tr class="separator:a1b49a23359f08fa4d30f61fc0c56de5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9ff4b80212faa99dda24be3fd6639c" id="r_abf9ff4b80212faa99dda24be3fd6639c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf9ff4b80212faa99dda24be3fd6639c">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a>, 0 &gt; &amp;meshes)</td></tr>
<tr class="separator:abf9ff4b80212faa99dda24be3fd6639c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518e5ae03c40b276fc39d55e2cacfc11" id="r_a518e5ae03c40b276fc39d55e2cacfc11"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a518e5ae03c40b276fc39d55e2cacfc11">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a>, 0, true &gt; &amp;meshes)</td></tr>
<tr class="separator:a518e5ae03c40b276fc39d55e2cacfc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09c288eeb600394bd546b3def257fb3" id="r_ab09c288eeb600394bd546b3def257fb3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09c288eeb600394bd546b3def257fb3">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;mesh)</td></tr>
<tr class="separator:ab09c288eeb600394bd546b3def257fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd152d8abef09fe85cd9d03d7e5d91d" id="r_abdd152d8abef09fe85cd9d03d7e5d91d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdd152d8abef09fe85cd9d03d7e5d91d">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:abdd152d8abef09fe85cd9d03d7e5d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301a4dd68ec13be8ccacafeaa3d5d23c" id="r_a301a4dd68ec13be8ccacafeaa3d5d23c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301a4dd68ec13be8ccacafeaa3d5d23c">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &gt; &amp;volumes)</td></tr>
<tr class="separator:a301a4dd68ec13be8ccacafeaa3d5d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8a1d3278dcc2b4114beb5d398959b" id="r_a34f8a1d3278dcc2b4114beb5d398959b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f8a1d3278dcc2b4114beb5d398959b">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a34f8a1d3278dcc2b4114beb5d398959b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f3306477d0aadf1371e6953688b1e" id="r_afa4f3306477d0aadf1371e6953688b1e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa4f3306477d0aadf1371e6953688b1e">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &gt; &amp;volumes)</td></tr>
<tr class="separator:afa4f3306477d0aadf1371e6953688b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f62084032e77eedb915e4960d3b04e1" id="r_a2f62084032e77eedb915e4960d3b04e1"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f62084032e77eedb915e4960d3b04e1">getCameraFactory</a> ()</td></tr>
<tr class="separator:a2f62084032e77eedb915e4960d3b04e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d921b209846ad190d508fda7a6fa5c0" id="r_a0d921b209846ad190d508fda7a6fa5c0"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d921b209846ad190d508fda7a6fa5c0">getCameraFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a0d921b209846ad190d508fda7a6fa5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970a97747e74096b1d8edbeb3a04b24c" id="r_a970a97747e74096b1d8edbeb3a04b24c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a970a97747e74096b1d8edbeb3a04b24c">getCameraFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a970a97747e74096b1d8edbeb3a04b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15da526769c7e6cfac443da69fbeb01" id="r_aa15da526769c7e6cfac443da69fbeb01"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa15da526769c7e6cfac443da69fbeb01">getCameraFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:aa15da526769c7e6cfac443da69fbeb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade202b1479ea75f08cf1453041653d71" id="r_ade202b1479ea75f08cf1453041653d71"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade202b1479ea75f08cf1453041653d71">getDataReaderFactory</a> ()</td></tr>
<tr class="separator:ade202b1479ea75f08cf1453041653d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb89ce7475c175642c1af64b4968977e" id="r_abb89ce7475c175642c1af64b4968977e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb89ce7475c175642c1af64b4968977e">getDataReaderFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:abb89ce7475c175642c1af64b4968977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f4b42cd6cd39b83dc90c559fa6bb0e" id="r_ab4f4b42cd6cd39b83dc90c559fa6bb0e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4f4b42cd6cd39b83dc90c559fa6bb0e">getDataReaderFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ab4f4b42cd6cd39b83dc90c559fa6bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dde0363ab2471e96be96369d165121" id="r_a45dde0363ab2471e96be96369d165121"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45dde0363ab2471e96be96369d165121">getDataReaderFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a45dde0363ab2471e96be96369d165121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af791b6c40d260174cfe13d1b910a2997" id="r_af791b6c40d260174cfe13d1b910a2997"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af791b6c40d260174cfe13d1b910a2997">getDataWriterFactory</a> ()</td></tr>
<tr class="separator:af791b6c40d260174cfe13d1b910a2997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10f29c6754fa85df59d5733cc2fe575" id="r_ad10f29c6754fa85df59d5733cc2fe575"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad10f29c6754fa85df59d5733cc2fe575">getDataWriterFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:ad10f29c6754fa85df59d5733cc2fe575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde0f16b84fba22f20ff5f4decb2886" id="r_aedde0f16b84fba22f20ff5f4decb2886"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedde0f16b84fba22f20ff5f4decb2886">getDataWriterFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:aedde0f16b84fba22f20ff5f4decb2886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218c489b7b18b032fe820723a6763220" id="r_a218c489b7b18b032fe820723a6763220"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218c489b7b18b032fe820723a6763220">getDataWriterFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a218c489b7b18b032fe820723a6763220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddd3009e57cad26baf545989a534a83" id="r_adddd3009e57cad26baf545989a534a83"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adddd3009e57cad26baf545989a534a83">getDialogFactory</a> ()</td></tr>
<tr class="separator:adddd3009e57cad26baf545989a534a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e23f2ba516c17cafc8332c363ddf20" id="r_ae9e23f2ba516c17cafc8332c363ddf20"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e23f2ba516c17cafc8332c363ddf20">getDialogFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:ae9e23f2ba516c17cafc8332c363ddf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f2666044e4fc6a71095773d48cff0c" id="r_a69f2666044e4fc6a71095773d48cff0c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f2666044e4fc6a71095773d48cff0c">getDialogFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a69f2666044e4fc6a71095773d48cff0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186c1e11a68572b7b72f108e6dbe1938" id="r_a186c1e11a68572b7b72f108e6dbe1938"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a186c1e11a68572b7b72f108e6dbe1938">getDialogFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a186c1e11a68572b7b72f108e6dbe1938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c2e1caf7ae7eb2ed27584c20c8882c" id="r_af3c2e1caf7ae7eb2ed27584c20c8882c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3c2e1caf7ae7eb2ed27584c20c8882c">getMeshDrawerFactory</a> ()</td></tr>
<tr class="separator:af3c2e1caf7ae7eb2ed27584c20c8882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d03cd82ba9e0c25d55d56f84182db58" id="r_a4d03cd82ba9e0c25d55d56f84182db58"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d03cd82ba9e0c25d55d56f84182db58">getMeshDrawerFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a4d03cd82ba9e0c25d55d56f84182db58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebb0173adbe89836698e846ded2bc33" id="r_aaebb0173adbe89836698e846ded2bc33"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaebb0173adbe89836698e846ded2bc33">getMeshDrawerFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:aaebb0173adbe89836698e846ded2bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca24404f35e96d489dae994fcbaec7b2" id="r_aca24404f35e96d489dae994fcbaec7b2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca24404f35e96d489dae994fcbaec7b2">getMeshDrawerFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:aca24404f35e96d489dae994fcbaec7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4215ec03970d45f9aa9821701d6159" id="r_aec4215ec03970d45f9aa9821701d6159"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec4215ec03970d45f9aa9821701d6159">getMetaDataFactory</a> ()</td></tr>
<tr class="separator:aec4215ec03970d45f9aa9821701d6159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59492d6e149b187c8a8514f9260bab9d" id="r_a59492d6e149b187c8a8514f9260bab9d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59492d6e149b187c8a8514f9260bab9d">getMetaDataFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a59492d6e149b187c8a8514f9260bab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b0438bcba0a5ff305142481e6d940a" id="r_a00b0438bcba0a5ff305142481e6d940a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00b0438bcba0a5ff305142481e6d940a">getMetaDataFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a00b0438bcba0a5ff305142481e6d940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b7960202bcd6a57324a5533026576" id="r_a0d5b7960202bcd6a57324a5533026576"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d5b7960202bcd6a57324a5533026576">getMetaDataFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a0d5b7960202bcd6a57324a5533026576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb37235946d4585a005b69fb8d3108ae" id="r_aeb37235946d4585a005b69fb8d3108ae"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb37235946d4585a005b69fb8d3108ae">getInportFactory</a> ()</td></tr>
<tr class="separator:aeb37235946d4585a005b69fb8d3108ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64aafb2b90aff39a7de052c44c6fd6" id="r_ace64aafb2b90aff39a7de052c44c6fd6"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace64aafb2b90aff39a7de052c44c6fd6">getInportFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:ace64aafb2b90aff39a7de052c44c6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf592017e46c128612fba4707622ad2" id="r_a5bf592017e46c128612fba4707622ad2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf592017e46c128612fba4707622ad2">getInportFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a5bf592017e46c128612fba4707622ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce439b90c0fdfa31bf496f9e079901f" id="r_a8ce439b90c0fdfa31bf496f9e079901f"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce439b90c0fdfa31bf496f9e079901f">getInportFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a8ce439b90c0fdfa31bf496f9e079901f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225f353c2a283f7b1ebdb76be3405bfb" id="r_a225f353c2a283f7b1ebdb76be3405bfb"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a225f353c2a283f7b1ebdb76be3405bfb">getOutportFactory</a> ()</td></tr>
<tr class="separator:a225f353c2a283f7b1ebdb76be3405bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf4564075f6757c039d1ab7bddcd332" id="r_acbf4564075f6757c039d1ab7bddcd332"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbf4564075f6757c039d1ab7bddcd332">getOutportFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:acbf4564075f6757c039d1ab7bddcd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985c8457f309f6939b350d0877a688ea" id="r_a985c8457f309f6939b350d0877a688ea"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985c8457f309f6939b350d0877a688ea">getOutportFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a985c8457f309f6939b350d0877a688ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd77e28823a1e07aac632f41f561225" id="r_afcd77e28823a1e07aac632f41f561225"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcd77e28823a1e07aac632f41f561225">getOutportFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:afcd77e28823a1e07aac632f41f561225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6424aa0b7ed27584e4aec9e50332f8b5" id="r_a6424aa0b7ed27584e4aec9e50332f8b5"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6424aa0b7ed27584e4aec9e50332f8b5">getPortInspectorFactory</a> ()</td></tr>
<tr class="separator:a6424aa0b7ed27584e4aec9e50332f8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337ca58f1ab197b5b538f2df2c3d60d9" id="r_a337ca58f1ab197b5b538f2df2c3d60d9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a337ca58f1ab197b5b538f2df2c3d60d9">getPortInspectorFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a337ca58f1ab197b5b538f2df2c3d60d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3328a7f85bb10bc4f68e01e589e91c7f" id="r_a3328a7f85bb10bc4f68e01e589e91c7f"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3328a7f85bb10bc4f68e01e589e91c7f">getPortInspectorFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a3328a7f85bb10bc4f68e01e589e91c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9068605538c589091a4f93f8094dd6c" id="r_ae9068605538c589091a4f93f8094dd6c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9068605538c589091a4f93f8094dd6c">getPortInspectorFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:ae9068605538c589091a4f93f8094dd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb568474e1a5f55a03b19fa17d57bd57" id="r_aeb568474e1a5f55a03b19fa17d57bd57"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb568474e1a5f55a03b19fa17d57bd57">getProcessorFactory</a> ()</td></tr>
<tr class="separator:aeb568474e1a5f55a03b19fa17d57bd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d52054f6b553e91c9fa6b96ba7951" id="r_a579d52054f6b553e91c9fa6b96ba7951"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a579d52054f6b553e91c9fa6b96ba7951">getProcessorFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a579d52054f6b553e91c9fa6b96ba7951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abb99ecd4d684f9f6e7db38c14189f4" id="r_a0abb99ecd4d684f9f6e7db38c14189f4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0abb99ecd4d684f9f6e7db38c14189f4">getProcessorFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a0abb99ecd4d684f9f6e7db38c14189f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e419deed7ae61aca5e6c42991dac4ca" id="r_a5e419deed7ae61aca5e6c42991dac4ca"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e419deed7ae61aca5e6c42991dac4ca">getProcessorFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a5e419deed7ae61aca5e6c42991dac4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18a8d1ff055cdc4871caaf9105fb714" id="r_aa18a8d1ff055cdc4871caaf9105fb714"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18a8d1ff055cdc4871caaf9105fb714">getProcessorWidgetFactory</a> ()</td></tr>
<tr class="separator:aa18a8d1ff055cdc4871caaf9105fb714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822bd9c723e6c3ff5b8811c1661ab619" id="r_a822bd9c723e6c3ff5b8811c1661ab619"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a822bd9c723e6c3ff5b8811c1661ab619">getProcessorWidgetFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a822bd9c723e6c3ff5b8811c1661ab619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3769912920cb25676b87a3e9e18894fb" id="r_a3769912920cb25676b87a3e9e18894fb"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3769912920cb25676b87a3e9e18894fb">getProcessorWidgetFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a3769912920cb25676b87a3e9e18894fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84d061d989c94549b2515228784d390" id="r_af84d061d989c94549b2515228784d390"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84d061d989c94549b2515228784d390">getProcessorWidgetFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:af84d061d989c94549b2515228784d390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaf5599590a84ca5b5a7c7a753cba00" id="r_a4eaf5599590a84ca5b5a7c7a753cba00"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eaf5599590a84ca5b5a7c7a753cba00">getPropertyConverterManager</a> ()</td></tr>
<tr class="separator:a4eaf5599590a84ca5b5a7c7a753cba00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8439998a9ed40b44da4bd7058115463" id="r_ac8439998a9ed40b44da4bd7058115463"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8439998a9ed40b44da4bd7058115463">getPropertyConverterManager</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:ac8439998a9ed40b44da4bd7058115463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c29f2ec6e6af67b8420361ee84bcd" id="r_ab33c29f2ec6e6af67b8420361ee84bcd"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33c29f2ec6e6af67b8420361ee84bcd">getPropertyConverterManager</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ab33c29f2ec6e6af67b8420361ee84bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d250f0b31a70916c4ad6cdda9a5a3d2" id="r_a2d250f0b31a70916c4ad6cdda9a5a3d2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d250f0b31a70916c4ad6cdda9a5a3d2">getPropertyConverterManager</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a2d250f0b31a70916c4ad6cdda9a5a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9840b2cdf93710505c943c60aebde12" id="r_aa9840b2cdf93710505c943c60aebde12"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9840b2cdf93710505c943c60aebde12">getPropertyFactory</a> ()</td></tr>
<tr class="separator:aa9840b2cdf93710505c943c60aebde12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa3e4c9abdac91937ddd9f54296e200" id="r_afaa3e4c9abdac91937ddd9f54296e200"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa3e4c9abdac91937ddd9f54296e200">getPropertyFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:afaa3e4c9abdac91937ddd9f54296e200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01abba5d8d446507b0361215de3ac2" id="r_a4e01abba5d8d446507b0361215de3ac2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e01abba5d8d446507b0361215de3ac2">getPropertyFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a4e01abba5d8d446507b0361215de3ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead4f50d8139c890e18633be5cf70b0f" id="r_aead4f50d8139c890e18633be5cf70b0f"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead4f50d8139c890e18633be5cf70b0f">getPropertyFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:aead4f50d8139c890e18633be5cf70b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd81fc6f5826cfebaae57f83c333f28d" id="r_acd81fc6f5826cfebaae57f83c333f28d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd81fc6f5826cfebaae57f83c333f28d">getPropertyWidgetFactory</a> ()</td></tr>
<tr class="separator:acd81fc6f5826cfebaae57f83c333f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e9003338a7f346abe69f37ed05e40d" id="r_a55e9003338a7f346abe69f37ed05e40d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55e9003338a7f346abe69f37ed05e40d">getPropertyWidgetFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a55e9003338a7f346abe69f37ed05e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ba7caad19de318e26f6a20c77950ba" id="r_a35ba7caad19de318e26f6a20c77950ba"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ba7caad19de318e26f6a20c77950ba">getPropertyWidgetFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a35ba7caad19de318e26f6a20c77950ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42568695652844d78dbfdcf49cb711a2" id="r_a42568695652844d78dbfdcf49cb711a2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42568695652844d78dbfdcf49cb711a2">getPropertyWidgetFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:a42568695652844d78dbfdcf49cb711a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9162a4e2c222f4eb070608e9159a299" id="r_af9162a4e2c222f4eb070608e9159a299"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9162a4e2c222f4eb070608e9159a299">getRepresentationMetaFactory</a> ()</td></tr>
<tr class="separator:af9162a4e2c222f4eb070608e9159a299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2faab1f347a6ec696b4d7dd494c23e2" id="r_af2faab1f347a6ec696b4d7dd494c23e2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2faab1f347a6ec696b4d7dd494c23e2">getRepresentationMetaFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:af2faab1f347a6ec696b4d7dd494c23e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d79174e78d30a6af364908f10f421e2" id="r_a2d79174e78d30a6af364908f10f421e2"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d79174e78d30a6af364908f10f421e2">getRepresentationMetaFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a2d79174e78d30a6af364908f10f421e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5210a10605942a6808dc8f4fc095509" id="r_ac5210a10605942a6808dc8f4fc095509"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5210a10605942a6808dc8f4fc095509">getRepresentationMetaFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:ac5210a10605942a6808dc8f4fc095509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e66064e0eca754510e1499e8acbfae8" id="r_a4e66064e0eca754510e1499e8acbfae8"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e66064e0eca754510e1499e8acbfae8">getRepresentationConverterMetaFactory</a> ()</td></tr>
<tr class="separator:a4e66064e0eca754510e1499e8acbfae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9bd887300af6145ef80867de65ca5d" id="r_a6d9bd887300af6145ef80867de65ca5d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d9bd887300af6145ef80867de65ca5d">getRepresentationConverterMetaFactory</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a6d9bd887300af6145ef80867de65ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d30e7a22eadb5c072c03cef4d8043cc" id="r_a4d30e7a22eadb5c072c03cef4d8043cc"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d30e7a22eadb5c072c03cef4d8043cc">getRepresentationConverterMetaFactory</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a4d30e7a22eadb5c072c03cef4d8043cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede753d265f637170350697f0179541d" id="r_aede753d265f637170350697f0179541d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aede753d265f637170350697f0179541d">getRepresentationConverterMetaFactory</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:aede753d265f637170350697f0179541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13808ea8c1dd607e9e3c4d4d2ac28fef" id="r_a13808ea8c1dd607e9e3c4d4d2ac28fef"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13808ea8c1dd607e9e3c4d4d2ac28fef">getResourceManager</a> ()</td></tr>
<tr class="separator:a13808ea8c1dd607e9e3c4d4d2ac28fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9636e75c722c445752b25b025ae8616c" id="r_a9636e75c722c445752b25b025ae8616c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9636e75c722c445752b25b025ae8616c">getResourceManager</a> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a9636e75c722c445752b25b025ae8616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2d0033f3187cc5e974c86807a8ba4a" id="r_ade2d0033f3187cc5e974c86807a8ba4a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade2d0033f3187cc5e974c86807a8ba4a">getResourceManager</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ade2d0033f3187cc5e974c86807a8ba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69ba056958e896c36c307cef6c8be5d" id="r_ae69ba056958e896c36c307cef6c8be5d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae69ba056958e896c36c307cef6c8be5d">getResourceManager</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *property)</td></tr>
<tr class="separator:ae69ba056958e896c36c307cef6c8be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>util </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af2128449f85e6a0683ecfab6f0bf557f" name="af2128449f85e6a0683ecfab6f0bf557f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2128449f85e6a0683ecfab6f0bf557f">&#9670;&#160;</a></span>HasClassIdentifierLower</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using inviwo::util::HasClassIdentifierLower</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    is_detected_exact&lt;const std::string, detail::lowerClassIdentifierType, T&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5433403a98e6a64371dada8fd4b5693" name="aa5433403a98e6a64371dada8fd4b5693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5433403a98e6a64371dada8fd4b5693">&#9670;&#160;</a></span>HasClassIdentifierUpper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using inviwo::util::HasClassIdentifierUpper</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    is_detected_exact&lt;const std::string, detail::upperClassIdentifierType, T&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae48603c54e2435829ff923a16fb6f24f" name="ae48603c54e2435829ff923a16fb6f24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48603c54e2435829ff923a16fb6f24f">&#9670;&#160;</a></span>HasColorCodeLower</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using inviwo::util::HasColorCodeLower</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::disjunction&lt;is_detected_exact&lt;uvec3, detail::colorCodeLowerType, T&gt;,</div>
<div class="line">                     is_detected_exact&lt;const uvec3, detail::colorCodeLowerType, T&gt;&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e72a7827ed4af44cfdd53604e14d417" name="a2e72a7827ed4af44cfdd53604e14d417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e72a7827ed4af44cfdd53604e14d417">&#9670;&#160;</a></span>HasColorCodeUpper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using inviwo::util::HasColorCodeUpper</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::disjunction&lt;is_detected_exact&lt;uvec3, detail::colorCodeUpperType, T&gt;,</div>
<div class="line">                     is_detected_exact&lt;const uvec3, detail::colorCodeUpperType, T&gt;&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1e4eff95e999c0f37072af916d5d93b" name="ab1e4eff95e999c0f37072af916d5d93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e4eff95e999c0f37072af916d5d93b">&#9670;&#160;</a></span>PrecisionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab1e4eff95e999c0f37072af916d5d93b">inviwo::util::PrecisionType</a> = typename std::remove_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility for retrieving the type of a (Buffer/Layer/Volume)RamPrecision pointer variable. Example usage: </p><div class="fragment"><div class="line">VolumeRam* volumeram = ...; <span class="comment">// of some glm vector type.</span></div>
<div class="line"><span class="keyword">auto</span> count = volumeram-&gt;dispatch&lt;size_t, <a class="code hl_struct" href="structinviwo_1_1dispatching_1_1filter_1_1Vecs.html">dispatching::filter::Vecs</a>&gt;([](<span class="keyword">auto</span> vrprecision) {</div>
<div class="line">    <span class="keyword">using </span>VolumeType = <a class="code hl_typedef" href="#ab1e4eff95e999c0f37072af916d5d93b">util::PrecisionType</a>&lt;<span class="keyword">decltype</span>(vrprecision)&gt;;</div>
<div class="line">    ....</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_ab1e4eff95e999c0f37072af916d5d93b"><div class="ttname"><a href="#ab1e4eff95e999c0f37072af916d5d93b">inviwo::util::PrecisionType</a></div><div class="ttdeci">typename std::remove_pointer&lt; typename std::remove_const&lt; T &gt;::type &gt;::type PrecisionType</div><div class="ttdef"><b>Definition</b> formatdispatching.h:493</div></div>
<div class="ttc" id="astructinviwo_1_1dispatching_1_1filter_1_1Vecs_html"><div class="ttname"><a href="structinviwo_1_1dispatching_1_1filter_1_1Vecs.html">inviwo::dispatching::filter::Vecs</a></div><div class="ttdef"><b>Definition</b> formatdispatching.h:393</div></div>
</div><!-- fragment --><p> VolumeType will then be for example VolumeRamPrecision&lt;vec3&gt; </p>

</div>
</div>
<a id="a4c5cc1457325e4cf1c8756319d5e83c5" name="a4c5cc1457325e4cf1c8756319d5e83c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5cc1457325e4cf1c8756319d5e83c5">&#9670;&#160;</a></span>PrecisionValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4c5cc1457325e4cf1c8756319d5e83c5">inviwo::util::PrecisionValueType</a> = typename <a class="el" href="#ab1e4eff95e999c0f37072af916d5d93b">PrecisionType</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility for retrieving the type of a (Buffer/Layer/Volume)RamPrecision pointer variable. Example usage: </p><div class="fragment"><div class="line">VolumeRam* volumeram = ...; <span class="comment">// of some glm vector type.</span></div>
<div class="line"><span class="keyword">auto</span> count = volumeram-&gt;dispatch&lt;size_t, <a class="code hl_struct" href="structinviwo_1_1dispatching_1_1filter_1_1Vecs.html">dispatching::filter::Vecs</a>&gt;([](<span class="keyword">auto</span> vrprecision) {</div>
<div class="line">    <span class="keyword">using </span>ValueType = <a class="code hl_typedef" href="#a4c5cc1457325e4cf1c8756319d5e83c5">util::PrecisionValueType</a>&lt;<span class="keyword">decltype</span>(vrprecision)&gt;;</div>
<div class="line">    ....</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_a4c5cc1457325e4cf1c8756319d5e83c5"><div class="ttname"><a href="#a4c5cc1457325e4cf1c8756319d5e83c5">inviwo::util::PrecisionValueType</a></div><div class="ttdeci">typename PrecisionType&lt; T &gt;::type PrecisionValueType</div><div class="ttdef"><b>Definition</b> formatdispatching.h:511</div></div>
</div><!-- fragment --><p> ValueType will then be for example vec3 </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a416c8d9416964edc5a92908f30761f6f" name="a416c8d9416964edc5a92908f30761f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416c8d9416964edc5a92908f30761f6f">&#9670;&#160;</a></span>addTFPresetsMenu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API QMenu * inviwo::util::addTFPresetsMenu </td>
          <td>(</td>
          <td class="paramtype">QWidget *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMenu *</td>          <td class="paramname"><span class="paramname"><em>menu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TransferFunctionProperty.html">TransferFunctionProperty</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a submenu containing entries for TF presets of all transfer functions found in the path <code>PathType::TransferFunctions</code>. Upon selecting a menu entry, the respective preset will be loaded by <code>property</code>. The submenu will be disabled if <code>property</code> is read-only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent widget </td></tr>
    <tr><td class="paramname">menu</td><td>parent menu to which the TF preset submenu should be added </td></tr>
    <tr><td class="paramname">property</td><td>this property will load the TF presets once the menu entries are triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly created submenu, which is owned by <code>parent</code> </dd></dl>

</div>
</div>
<a id="a2f406a130b054515fd4dceb5b35b84ba" name="a2f406a130b054515fd4dceb5b35b84ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f406a130b054515fd4dceb5b35b84ba">&#9670;&#160;</a></span>alignAlphaToBottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignAlphaToBottom </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the alphas value of selection to the min alpha value. </p>

</div>
</div>
<a id="ad833fb2a28acd35e6be134baa81331fa" name="ad833fb2a28acd35e6be134baa81331fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833fb2a28acd35e6be134baa81331fa">&#9670;&#160;</a></span>alignAlphaToMean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignAlphaToMean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the alphas value of selection to the average alpha value. </p>

</div>
</div>
<a id="a92665c9b8c2cd085faf8e4b701edbdc7" name="a92665c9b8c2cd085faf8e4b701edbdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92665c9b8c2cd085faf8e4b701edbdc7">&#9670;&#160;</a></span>alignAlphaToTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignAlphaToTop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the alphas value of selection to the max alpha value. </p>

</div>
</div>
<a id="a27792fd235656d42d7e286db7cdc4bd3" name="a27792fd235656d42d7e286db7cdc4bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27792fd235656d42d7e286db7cdc4bd3">&#9670;&#160;</a></span>alignPositionToLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignPositionToLeft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position value of selection to the min position value. </p>

</div>
</div>
<a id="a6fd54c996575d2b47bea52c51ee3ec14" name="a6fd54c996575d2b47bea52c51ee3ec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd54c996575d2b47bea52c51ee3ec14">&#9670;&#160;</a></span>alignPositionToMean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignPositionToMean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position value of selection to the average position value. </p>

</div>
</div>
<a id="a886b02bc8bf08edc11981f255bdc9780" name="a886b02bc8bf08edc11981f255bdc9780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886b02bc8bf08edc11981f255bdc9780">&#9670;&#160;</a></span>alignPositionToRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignPositionToRight </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position value of selection to the max position value. </p>

</div>
</div>
<a id="ad9f205a4666ea62977429eb4a760e87b" name="ad9f205a4666ea62977429eb4a760e87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f205a4666ea62977429eb4a760e87b">&#9670;&#160;</a></span>appendIfNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::appendIfNotEmpty </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends b to a if a is not empty and returns a. Useful if an empty a is considered an error and we want to propagate that error. </p>

</div>
</div>
<a id="a3c1d35bf328c84cfedc3dfd7976ae43a" name="a3c1d35bf328c84cfedc3dfd7976ae43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1d35bf328c84cfedc3dfd7976ae43a">&#9670;&#160;</a></span>appendPartialProcessorNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; inviwo::util::appendPartialProcessorNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>refPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetCallback</td>          <td class="paramname"><span class="paramname"><em>offsetCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a PartialProcessorNetwork to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>the network to append to the current one </td></tr>
    <tr><td class="paramname">is</td><td>a stream of a serialized PartialProcessorNetwork </td></tr>
    <tr><td class="paramname">refPath</td><td>a possible path to the original file of the PartialProcessorNetwork, for error reporting </td></tr>
    <tr><td class="paramname">app</td><td>The inviwo application </td></tr>
    <tr><td class="paramname">offsetCallback</td><td>callback for determining an offset, which is applied to all added processors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended processors. </dd></dl>

</div>
</div>
<a id="a49245a6e71202c206adbbffe5301690e" name="a49245a6e71202c206adbbffe5301690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49245a6e71202c206adbbffe5301690e">&#9670;&#160;</a></span>boundingBox() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="ab279fda2d5e97b698c1c269a30ea6314" name="ab279fda2d5e97b698c1c269a30ea6314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab279fda2d5e97b698c1c269a30ea6314">&#9670;&#160;</a></span>boundingBox() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a>, 0 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a3328efd9d49b9501846901e6814187d6" name="a3328efd9d49b9501846901e6814187d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3328efd9d49b9501846901e6814187d6">&#9670;&#160;</a></span>boundingBox() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a>, 0, true &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a1b49a23359f08fa4d30f61fc0c56de5a" name="a1b49a23359f08fa4d30f61fc0c56de5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b49a23359f08fa4d30f61fc0c56de5a">&#9670;&#160;</a></span>boundingBox() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="abf9ff4b80212faa99dda24be3fd6639c" name="abf9ff4b80212faa99dda24be3fd6639c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9ff4b80212faa99dda24be3fd6639c">&#9670;&#160;</a></span>boundingBox() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a>, 0 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>meshes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a518e5ae03c40b276fc39d55e2cacfc11" name="a518e5ae03c40b276fc39d55e2cacfc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518e5ae03c40b276fc39d55e2cacfc11">&#9670;&#160;</a></span>boundingBox() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a>, 0, true &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>meshes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a301a4dd68ec13be8ccacafeaa3d5d23c" name="a301a4dd68ec13be8ccacafeaa3d5d23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301a4dd68ec13be8ccacafeaa3d5d23c">&#9670;&#160;</a></span>boundingBox() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volumes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="abdd152d8abef09fe85cd9d03d7e5d91d" name="abdd152d8abef09fe85cd9d03d7e5d91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd152d8abef09fe85cd9d03d7e5d91d">&#9670;&#160;</a></span>boundingBox() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a1fe50ae518a474b7e03b565b029df8e8" name="a1fe50ae518a474b7e03b565b029df8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe50ae518a474b7e03b565b029df8e8">&#9670;&#160;</a></span>boundingBox() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="ab09c288eeb600394bd546b3def257fb3" name="ab09c288eeb600394bd546b3def257fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09c288eeb600394bd546b3def257fb3">&#9670;&#160;</a></span>boundingBox() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="afa4f3306477d0aadf1371e6953688b1e" name="afa4f3306477d0aadf1371e6953688b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4f3306477d0aadf1371e6953688b1e">&#9670;&#160;</a></span>boundingBox() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volumes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a34f8a1d3278dcc2b4114beb5d398959b" name="a34f8a1d3278dcc2b4114beb5d398959b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f8a1d3278dcc2b4114beb5d398959b">&#9670;&#160;</a></span>boundingBox() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a0123d642715c707b5cc76d11ca0bad95" name="a0123d642715c707b5cc76d11ca0bad95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0123d642715c707b5cc76d11ca0bad95">&#9670;&#160;</a></span>boundingBox() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a bounding box of the layers in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. The bounding box will have zero depth in most cases since the layer basis is two-dimensional. </p>

</div>
</div>
<a id="a74a73f5197bbfc5940421cee5d8f5755" name="a74a73f5197bbfc5940421cee5d8f5755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a73f5197bbfc5940421cee5d8f5755">&#9670;&#160;</a></span>boundingBox() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a bounding box of the position buffer of the mesh in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="aa7a49c8d7b70aa04748e46e77aaa4bf3" name="aa7a49c8d7b70aa04748e46e77aaa4bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a49c8d7b70aa04748e46e77aaa4bf3">&#9670;&#160;</a></span>boundingBox() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>meshes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a bounding box of the position buffers of all the meshes in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="a212b4034a9b7f9090fb3cdf1ced7153d" name="a212b4034a9b7f9090fb3cdf1ced7153d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212b4034a9b7f9090fb3cdf1ced7153d">&#9670;&#160;</a></span>boundingBox() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a bounding box of all layers in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="a07503961e01f5f633c9f1a371b36d780" name="a07503961e01f5f633c9f1a371b36d780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07503961e01f5f633c9f1a371b36d780">&#9670;&#160;</a></span>boundingBox() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volumes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a bounding box of all the volumes in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="ac6b304bd97447cbc99865cf2a8bdc3a9" name="ac6b304bd97447cbc99865cf2a8bdc3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b304bd97447cbc99865cf2a8bdc3a9">&#9670;&#160;</a></span>boundingBox() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a bounding box of the volume in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="a0aaefd44a8fc7b7156c27f830e98ace1" name="a0aaefd44a8fc7b7156c27f830e98ace1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aaefd44a8fc7b7156c27f830e98ace1">&#9670;&#160;</a></span>combineChannels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TRAMrep &gt; <br />
requires requires(T data) { typename T::repr; std::is_base_of_v&lt;typename T::repr, TRAMrep&gt;; data.template getRepresentation&lt;TRAMrep&gt;(); }</div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; inviwo::util::combineChannels </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; T &gt;, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sources</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selectedPortChannels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combines up to four channels from four inports into a single object of type <code>T</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>underlying datatype </td></tr>
    <tr><td class="paramname">TRAMrep</td><td>RAM representation for <code>T</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sources</td><td>array of inports for type <code>T</code> </td></tr>
    <tr><td class="paramname">selectedPortChannels</td><td>selected channel for each inport </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of T with the combined channels of <code>sources</code> </dd></dl>
<p>Usage: <code>combineChannels&lt;Layer, LayerRAM&gt;(...)</code> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1LayerCombiner.html">LayerCombiner</a>, <a class="el" href="classinviwo_1_1VolumeChannelCombiner.html">VolumeChannelCombiner</a> </dd></dl>

</div>
</div>
<a id="a8b656c765eccf8074aa2adde7b031b09" name="a8b656c765eccf8074aa2adde7b031b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b656c765eccf8074aa2adde7b031b09">&#9670;&#160;</a></span>commonFormatPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API size_t inviwo::util::commonFormatPrecision </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="classinviwo_1_1DataFormatBase.html">DataFormatBase</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>formats</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the format precision of the given <code>formats</code>, that is the highest one. </p><dl class="section return"><dt>Returns</dt><dd>maximum precision of all <code>formats</code> </dd></dl>

</div>
</div>
<a id="a5f94054887b47451f416e2b60f9d248c" name="a5f94054887b47451f416e2b60f9d248c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f94054887b47451f416e2b60f9d248c">&#9670;&#160;</a></span>commonNumericType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API NumericType inviwo::util::commonNumericType </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="classinviwo_1_1DataFormatBase.html">DataFormatBase</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>formats</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the common numeric type of the given <code>formats</code>. Returns NumericType::Float if any of the formats is a floating point format. Otherwise, NumericType::SignedInteger is returned if at least one format is signed, and NumericType::UnsignedInteger if that is not the case. </p><dl class="section return"><dt>Returns</dt><dd>NumericType based on <code>formats</code>. NumericType::NotSpecialized if the span is empty. </dd></dl>

</div>
</div>
<a id="ab6356ee05cfde312881b948335bf689b" name="ab6356ee05cfde312881b948335bf689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6356ee05cfde312881b948335bf689b">&#9670;&#160;</a></span>convexHull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; inviwo::util::convexHull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the complex hull from a given set of 2D points using the Monotone Chain algorithm, i.e. Andrew's convex hull algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms">https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>set of 2D points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>complex hull of input points </dd></dl>

</div>
</div>
<a id="a5e2a9a37232b9367cf8bc52093935b37" name="a5e2a9a37232b9367cf8bc52093935b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2a9a37232b9367cf8bc52093935b37">&#9670;&#160;</a></span>createCameraEyeOffsetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> &gt; inviwo::util::createCameraEyeOffsetProperty </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; vec2()&gt;</td>          <td class="paramname"><span class="paramname"><em>get</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const vec2 &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an eye offset property for use in a camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="ad1562123df97b5129796b73f231e1bd5" name="ad1562123df97b5129796b73f231e1bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1562123df97b5129796b73f231e1bd5">&#9670;&#160;</a></span>createCameraFovProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt; inviwo::util::createCameraFovProperty </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float()&gt;</td>          <td class="paramname"><span class="paramname"><em>get</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vertical fov property for use in a camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PerspectiveCamera.html">PerspectiveCamera</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="a53cd42ede5eb2f1d94c2405c9f36c005" name="a53cd42ede5eb2f1d94c2405c9f36c005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cd42ede5eb2f1d94c2405c9f36c005">&#9670;&#160;</a></span>createCameraWidthProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt; inviwo::util::createCameraWidthProperty </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float()&gt;</td>          <td class="paramname"><span class="paramname"><em>get</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a width property for use in a <a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1OrthographicCamera.html" title="Camera with no perspective projection. Objects far away will appear as large as objects close.">OrthographicCamera</a> </dd></dl>

</div>
</div>
<a id="a4b7100edcb0e8721bc861233332b7d2c" name="a4b7100edcb0e8721bc861233332b7d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7100edcb0e8721bc861233332b7d2c">&#9670;&#160;</a></span>createTextTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_FONTRENDERING_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; inviwo::util::createTextTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>textRenderer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4</td>          <td class="paramname"><span class="paramname"><em>fontColor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture with rendered text for a given string. </p>
<p>Creates a texture with a text string using the specified renderer and color. May take an additional variable tex of an existing texture that can be reused to reduce the number of times we need to allocating new textures.</p>
<p>The size of the texture will be the smallest possible for the given text and the pixels containing no text will have zero alpha.</p>
<p>For correct alignment of the baseline, the position of where this texture will be rendered must be adjusted by pos + computeBoundingBox(text).glyphsOrigin. See also <a class="el" href="classinviwo_1_1TextOverlayGL.html#acfb36fb35fcf8c986eb72ca473a75806">TextOverlayGL::process()</a> as an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textRenderer</td><td>The renderer that will be used to render the text </td></tr>
    <tr><td class="paramname">text</td><td>text to be rendered </td></tr>
    <tr><td class="paramname">fontColor</td><td>the final color of the text </td></tr>
    <tr><td class="paramname">tex</td><td>optional cache texture which will be reused if possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>texture containing the text </dd></dl>

</div>
</div>
<a id="a6e1e0f2ae3a7b52b3a951b6fff0411b2" name="a6e1e0f2ae3a7b52b3a951b6fff0411b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1e0f2ae3a7b52b3a951b6fff0411b2">&#9670;&#160;</a></span>createTextTextureObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_FONTRENDERING_API <a class="el" href="structinviwo_1_1TextTextureObject.html">TextTextureObject</a> inviwo::util::createTextTextureObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>textRenderer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4</td>          <td class="paramname"><span class="paramname"><em>fontColor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture with rendered text for a given string including its bounding box. </p>
<p>Creates a texture with rendered text for a string using the specified renderer and color. May take an additional variable tex of an existing texture that can be reused to reduce the number of times we need to allocating new textures. The resulting texture is returned along with the respective bounding box.</p>
<p>The size of the texture will be the smallest possible for the given text. All pixels containing no text will have zero alpha.</p>
<p>For correct alignment of the baseline, the position of where this texture will be rendered must be adjusted by pos + TextTextureObject.glyphsOrigin. See also <a class="el" href="classinviwo_1_1TextOverlayGL.html#acfb36fb35fcf8c986eb72ca473a75806">TextOverlayGL::process()</a> as an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textRenderer</td><td>The renderer that will be used to render the text </td></tr>
    <tr><td class="paramname">text</td><td>string to be rendered </td></tr>
    <tr><td class="paramname">fontColor</td><td>the final color of the text </td></tr>
    <tr><td class="paramname">tex</td><td>optional cache texture which will be reused if possible (same texture will be returned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>text texture object referring to both texture and corresponding bounding box </dd></dl>

</div>
</div>
<a id="a125fdc1aa254554458167122ca14c08b" name="a125fdc1aa254554458167122ca14c08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125fdc1aa254554458167122ca14c08b">&#9670;&#160;</a></span>cubePlaneIntersectionAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::cubePlaneIntersectionAppend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Plane.html">Plane</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vec3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersects a unit cube with the given plane. The intersection points and the midpoint will be added to 'pos' and a list of triangle indicies referring to the pos array will be appended to 'inds' </p>

</div>
</div>
<a id="ae49e61ebf3b11c94b3497f88bb454634" name="ae49e61ebf3b11c94b3497f88bb454634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49e61ebf3b11c94b3497f88bb454634">&#9670;&#160;</a></span>dataMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; dvec4, dvec4 &gt; inviwo::util::dataMinMax </td>
          <td>(</td>
          <td class="paramtype">const ValueType *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IgnoreSpecialValues</td>          <td class="paramname"><span class="paramname"><em>ignore</em></span><span class="paramdefsep"> = </span><span class="paramdefval">IgnoreSpecialValues::No</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute component-wise minimum and maximum values scalar and glm::vec types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to values </td></tr>
    <tr><td class="paramname">size</td><td>of data </td></tr>
    <tr><td class="paramname">ignore</td><td>infinite and NaN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum and maximum values of each component and zero for non-existing components </dd></dl>

</div>
</div>
<a id="a2d48f7460aa46b805b25b7c8802e1433" name="a2d48f7460aa46b805b25b7c8802e1433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d48f7460aa46b805b25b7c8802e1433">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::demangle </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Demangle the type ID given in <code>name</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>mangled type ID name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>demangled type name without <code>class</code> and <code>struct</code> </dd></dl>

</div>
</div>
<a id="a818947e6c0c72cbdeb18b6631686091b" name="a818947e6c0c72cbdeb18b6631686091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818947e6c0c72cbdeb18b6631686091b">&#9670;&#160;</a></span>durationToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period  = std::ratio&lt;1&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string inviwo::util::durationToString </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;</td>          <td class="paramname"><span class="paramname"><em>duration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeZeros</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>spacing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience function for converting a std::chrono::duration to a string calling msToString(double). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>duration </td></tr>
    <tr><td class="paramname">includeZeros</td><td>if true, time units for zero values are always shown, e.g. "2d 0h 0min 23s" vs. "2d 23s" and "2h 0min 0s" vs. "2h" </td></tr>
    <tr><td class="paramname">spacing</td><td>if true, a space is inserted between digits and units </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>duration formatted as string </dd></dl>

</div>
</div>
<a id="aa0b234248fa0f75afa5d053118ec319a" name="aa0b234248fa0f75afa5d053118ec319a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b234248fa0f75afa5d053118ec319a">&#9670;&#160;</a></span>elideLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::elideLines </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>abbrev</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;...&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxLineLength</em></span><span class="paramdefsep"> = </span><span class="paramdefval">500</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elide parts of lines in <code>str</code> which are longer than <code>maxLineLength</code> and append <code>abbrev</code> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string with lines to abbreviate </td></tr>
    <tr><td class="paramname">abbrev</td><td>placeholder that gets added at the end of abbreviated lines </td></tr>
    <tr><td class="paramname">maxLineLength</td><td>lines that are longer are abbreviated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input string where no line is longer than <code>maxLineLength</code> + <code>abbrev.size()</code> </dd></dl>

</div>
</div>
<a id="a787f4da3b201153820af19c27c2a7fac" name="a787f4da3b201153820af19c27c2a7fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787f4da3b201153820af19c27c2a7fac">&#9670;&#160;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIndex  = size_t, typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::enumerate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>conts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerate element in a container. Example use case: std::vector&lt;int&gt; vec(10); for (auto&amp;&amp; item : util::enumerate(vec)) { auto&amp;&amp; ind = item.first(); auto&amp;&amp; elem = item.second(); // alternatively, get&lt;0&gt;(item) and get&lt;1&gt;(item) can be used }</p>
<p>with C++17 structured bindings for (auto&amp;&amp; [ind, elem] : util::enumerate(vec)) {</p>
<p>} </p>

</div>
</div>
<a id="acf49cedd9ee71ada8b2e5c822dce8fd4" name="acf49cedd9ee71ada8b2e5c822dce8fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49cedd9ee71ada8b2e5c822dce8fd4">&#9670;&#160;</a></span>enumeratedOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1OptionPropertyOption.html">OptionPropertyIntOption</a> &gt; inviwo::util::enumeratedOptions </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for setting up a OptionPropertyInt with enumerated options. That is, "@p name 1", "@p name 2", etc. up to <code>count</code>. </p>

</div>
</div>
<a id="a4c89b716938f61f15132ae42d6d4a16b" name="a4c89b716938f61f15132ae42d6d4a16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c89b716938f61f15132ae42d6d4a16b">&#9670;&#160;</a></span>expandCompositeProcessorIntoNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::expandCompositeProcessorIntoNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CompositeProcessor.html">CompositeProcessor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>composite</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand a composite processors sub network into its network. Effectively reversing the actions of replaceSelectionWithCompositeProcessor. All processor except for composite sink and composite source processors are moved from the sub network into the network of the composite processor. Connections and links are the reestablished. Sources and sinks are discarded. </p>

</div>
</div>
<a id="ac1e400fc2734a064a4b9257da2776893" name="ac1e400fc2734a064a4b9257da2776893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e400fc2734a064a4b9257da2776893">&#9670;&#160;</a></span>exportAllFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::filesystem::path &gt; inviwo::util::exportAllFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>nameTemplate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidateExtensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite</td>          <td class="paramname"><span class="paramname"><em>overwrite</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports the data from all export processors in <code>network</code> into the directory <code>dir</code> using a <code>nameTemplate</code> and candidate extensions. </p><dl class="section return"><dt>Returns</dt><dd>names of exported files </dd></dl>

</div>
</div>
<a id="a754bddb595bebae365189d7de121ec9a" name="a754bddb595bebae365189d7de121ec9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754bddb595bebae365189d7de121ec9a">&#9670;&#160;</a></span>exportIsoValueCollectionDialog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API void inviwo::util::exportIsoValueCollectionDialog </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1IsoValueCollection.html">IsoValueCollection</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to export a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iso</td><td><a class="el" href="classinviwo_1_1IsoValueCollection.html" title="data structure representing isovalues">IsoValueCollection</a> set to be exported </td></tr>
    <tr><td class="paramname">parent</td><td>parent widget of the file dialog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7336f466792bdd174b745bd6285048bc" name="a7336f466792bdd174b745bd6285048bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7336f466792bdd174b745bd6285048bc">&#9670;&#160;</a></span>exportTransferFunctionDialog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API void inviwo::util::exportTransferFunctionDialog </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1TransferFunction.html">TransferFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to export a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td><a class="el" href="classinviwo_1_1TransferFunction.html" title="data structure for holding 1D transfer function data">TransferFunction</a> set to be exported </td></tr>
    <tr><td class="paramname">parent</td><td>parent widget of the file dialog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b594a5638571d9e20783d8843f3c38" name="ad2b594a5638571d9e20783d8843f3c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b594a5638571d9e20783d8843f3c38">&#9670;&#160;</a></span>filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename T  = typename M::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M inviwo::util::filled </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to create a matrix filled with a constant. For example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="#ad2b594a5638571d9e20783d8843f3c38">util::filled&lt;mat3&gt;</a>(3.16);</div>
<div class="line"><span class="comment">// | 3.16 3.16 3.16 |</span></div>
<div class="line"><span class="comment">// | 3.16 3.16 3.16 |</span></div>
<div class="line"><span class="comment">// | 3.16 3.16 3.16 |</span></div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_ad2b594a5638571d9e20783d8843f3c38"><div class="ttname"><a href="#ad2b594a5638571d9e20783d8843f3c38">inviwo::util::filled</a></div><div class="ttdeci">M filled(T v)</div><div class="ttdef"><b>Definition</b> glm.h:256</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a1641752b9b6ec1384f983f1f7b86a9" name="a2a1641752b9b6ec1384f983f1f7b86a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1641752b9b6ec1384f983f1f7b86a9">&#9670;&#160;</a></span>findUniqueIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::findUniqueIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(std::string_view)&gt;</td>          <td class="paramname"><span class="paramname"><em>isUnique</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility to augment an identifier with a number to make it unique. Will add an increasing number to the end of the given identifier until the isUnique test returns true. Example for a processor identifier: auto uniqueIdentifier = <a class="el" href="#a2a1641752b9b6ec1384f983f1f7b86a9">util::findUniqueIdentifier</a>( startIdentifier, [&amp;](std::string_view id) { return processorNetwork-&gt;getProcessorByIdentifier(id) == nullptr; }, "" ); </p>

</div>
</div>
<a id="a0cb3c9707e78b11bc105e3b2614f1621" name="a0cb3c9707e78b11bc105e3b2614f1621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb3c9707e78b11bc105e3b2614f1621">&#9670;&#160;</a></span>flipPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::flipPositions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip the positions of the <code>selection</code> with respect to the respective range, i.e. p' = range.max - (p - range.min) with range.min/max corresponding to the lowest/highest position in <code>selection</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selection</td><td>list of primitives to be flipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb6b8dfc1fe3a44825c0a2dbbc2ae65a" name="aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6b8dfc1fe3a44825c0a2dbbc2ae65a">&#9670;&#160;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::forEach </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;</td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to iterate over all element in an iterable data structure (such as std::vector). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc3ba8edf9868ee32bb79ba5f1c1b114" name="adc3ba8edf9868ee32bb79ba5f1c1b114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3ba8edf9868ee32bb79ba5f1c1b114">&#9670;&#160;</a></span>forEachParallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::forEachParallel </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;</td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>jobs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use multiple threads to iterate over all elements in an iterable data structure (such as std::vector). If the Inviwo pool size is zero it will be executed directly in the same thread as the caller. The function will return once all jobs as has finished processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
    <tr><td class="paramname">jobs</td><td>optional parameter specifying how many jobs to create, if jobs==0 (default) it will create pool size * 4 jobs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5152f1acc0ccd5f17aef14a459df80b0" name="a5152f1acc0ccd5f17aef14a459df80b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5152f1acc0ccd5f17aef14a459df80b0">&#9670;&#160;</a></span>forEachParallelAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Callback , typename OnDoneCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::future&lt; void &gt; &gt; inviwo::util::forEachParallelAsync </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;</td>          <td class="paramname"><span class="paramname"><em>iterable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>jobs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnDoneCallback &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>onTaskDone</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use multiple threads to iterate over all elements in an iterable data structure (such as std::vector). If the Inviwo pool size is zero it will be executed directly in the same thread as the caller. The function will return once all jobs as has been created and queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
    <tr><td class="paramname">jobs</td><td>optional parameter specifying how many jobs to create, if jobs==0 (default) it will create pool size * 4 jobs </td></tr>
    <tr><td class="paramname">onTaskDone</td><td>callback that will be called when each job is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of futures, one for each job created. </dd></dl>

</div>
</div>
<a id="a040967fe9b1828c138864fcff6d60c0d" name="a040967fe9b1828c138864fcff6d60c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040967fe9b1828c138864fcff6d60c0d">&#9670;&#160;</a></span>forEachStringPart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::forEachStringPart </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on each part of the string after splitting by sep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramname">sep</td><td>The delimiter to split by </td></tr>
    <tr><td class="paramname">func</td><td>Function callback, should take a std::string_view as argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ec5e6658368eb78ce7b3161c63eddb" name="a53ec5e6658368eb78ce7b3161c63eddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ec5e6658368eb78ce7b3161c63eddb">&#9670;&#160;</a></span>fromWstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::fromWstring </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the given std::wstring to std::string. On Windows, WideCharToMultiByte is used for this conversion assuming utf8 encoding. Otherwise, std::wcsrtombs is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>std::wstring character string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input converted to multibyte std::string </dd></dl>

</div>
</div>
<a id="af36b4e4950c7c433f359ad1e2e32c8ac" name="af36b4e4950c7c433f359ad1e2e32c8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b4e4950c7c433f359ad1e2e32c8ac">&#9670;&#160;</a></span>generateVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::generateVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;</td>          <td class="paramname"><span class="paramname"><em>dimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat3 &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for generating volumes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td><a class="el" href="classinviwo_1_1Volume.html">Volume</a> grid dimensions </td></tr>
    <tr><td class="paramname">basis</td><td><a class="el" href="classinviwo_1_1Volume.html">Volume</a> basis, offset automatically set to center the volume around origo </td></tr>
    <tr><td class="paramname">function</td><td>Functor called for each volume voxel. T(const size3_t&amp; ind). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba0bfadae887301565e97b98483268b" name="aaba0bfadae887301565e97b98483268b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba0bfadae887301565e97b98483268b">&#9670;&#160;</a></span>getArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double inviwo::util::getArea </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the area of a convex polygon </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>points ordered counter-clockwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>area of polygon </dd></dl>

</div>
</div>
<a id="a8256eb5b33cde59a3e0d832b0569d323" name="a8256eb5b33cde59a3e0d832b0569d323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8256eb5b33cde59a3e0d832b0569d323">&#9670;&#160;</a></span>getBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt; inviwo::util::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>processors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve bounding box of the processors in the list. The return value is pair of the min x,y and the max x,y </p>

</div>
</div>
<a id="ade9c4d7699d86580d306484f30f7110d" name="ade9c4d7699d86580d306484f30f7110d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9c4d7699d86580d306484f30f7110d">&#9670;&#160;</a></span>getBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt; inviwo::util::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>network</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve bounding box of the processors in the network. The return value is pair of the min x,y and the max x,y </p>

</div>
</div>
<a id="ac161982c151dab1c0f48df711facdd0d" name="ac161982c151dab1c0f48df711facdd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac161982c151dab1c0f48df711facdd0d">&#9670;&#160;</a></span>getBuildInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a> &gt; IVW_CORE_API inviwo::util::getBuildInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses build information via an INI file or compile-time definitions. </p>
<dl class="section return"><dt>Returns</dt><dd>build information </dd></dl>

</div>
</div>
<a id="aae046e2b3232a4ce60452ccc5853efb9" name="aae046e2b3232a4ce60452ccc5853efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae046e2b3232a4ce60452ccc5853efb9">&#9670;&#160;</a></span>getCameraEyeOffsetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> * inviwo::util::getCameraEyeOffsetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraProperty</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the eye offset property in the cameraProperty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraProperty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the eye offset property if found, nullptr otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="a2f62084032e77eedb915e4960d3b04e1" name="a2f62084032e77eedb915e4960d3b04e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f62084032e77eedb915e4960d3b04e1">&#9670;&#160;</a></span>getCameraFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> * inviwo::util::getCameraFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> </dd></dl>

</div>
</div>
<a id="a0d921b209846ad190d508fda7a6fa5c0" name="a0d921b209846ad190d508fda7a6fa5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d921b209846ad190d508fda7a6fa5c0">&#9670;&#160;</a></span>getCameraFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> * inviwo::util::getCameraFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> </dd></dl>

</div>
</div>
<a id="a970a97747e74096b1d8edbeb3a04b24c" name="a970a97747e74096b1d8edbeb3a04b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970a97747e74096b1d8edbeb3a04b24c">&#9670;&#160;</a></span>getCameraFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> * inviwo::util::getCameraFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> </dd></dl>

</div>
</div>
<a id="aa15da526769c7e6cfac443da69fbeb01" name="aa15da526769c7e6cfac443da69fbeb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15da526769c7e6cfac443da69fbeb01">&#9670;&#160;</a></span>getCameraFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> * inviwo::util::getCameraFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Camera.html" title="Base class for cameras. Override this class to set your own projection matrix.">Camera</a> <a class="el" href="classinviwo_1_1CameraFactory.html">CameraFactory</a> </dd></dl>

</div>
</div>
<a id="ad37abc25e96c99f34aac8f37606c7df4" name="ad37abc25e96c99f34aac8f37606c7df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37abc25e96c99f34aac8f37606c7df4">&#9670;&#160;</a></span>getCameraFovProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::getCameraFovProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraProperty</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the vertical fov property in the cameraProperty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraProperty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fov property if found, nullptr otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PerspectiveCamera.html">PerspectiveCamera</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="a8cfe78f266537021920d03efb74a15a3" name="a8cfe78f266537021920d03efb74a15a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfe78f266537021920d03efb74a15a3">&#9670;&#160;</a></span>getCameraWidthProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::getCameraWidthProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraProperty</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the width property in the cameraProperty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraProperty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the width property if found, nullptr otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1OrthographicCamera.html" title="Camera with no perspective projection. Objects far away will appear as large as objects close.">OrthographicCamera</a> </dd></dl>

</div>
</div>
<a id="a9814ba491ab54162a61144582fff0dbd" name="a9814ba491ab54162a61144582fff0dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9814ba491ab54162a61144582fff0dbd">&#9670;&#160;</a></span>getCenterPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API ivec2 inviwo::util::getCenterPosition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>processors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the mean position of the processors in the list. </p>

</div>
</div>
<a id="a930eff3a3f70e0c02c85a55c99c13166" name="a930eff3a3f70e0c02c85a55c99c13166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930eff3a3f70e0c02c85a55c99c13166">&#9670;&#160;</a></span>getCenterPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API ivec2 inviwo::util::getCenterPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>network</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the mean position of the processors in the network. </p>

</div>
</div>
<a id="ade202b1479ea75f08cf1453041653d71" name="ade202b1479ea75f08cf1453041653d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade202b1479ea75f08cf1453041653d71">&#9670;&#160;</a></span>getDataReaderFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> * inviwo::util::getDataReaderFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> </dd></dl>

</div>
</div>
<a id="abb89ce7475c175642c1af64b4968977e" name="abb89ce7475c175642c1af64b4968977e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb89ce7475c175642c1af64b4968977e">&#9670;&#160;</a></span>getDataReaderFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> * inviwo::util::getDataReaderFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> </dd></dl>

</div>
</div>
<a id="ab4f4b42cd6cd39b83dc90c559fa6bb0e" name="ab4f4b42cd6cd39b83dc90c559fa6bb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f4b42cd6cd39b83dc90c559fa6bb0e">&#9670;&#160;</a></span>getDataReaderFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> * inviwo::util::getDataReaderFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> </dd></dl>

</div>
</div>
<a id="a45dde0363ab2471e96be96369d165121" name="a45dde0363ab2471e96be96369d165121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dde0363ab2471e96be96369d165121">&#9670;&#160;</a></span>getDataReaderFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> * inviwo::util::getDataReaderFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataReader.html" title="A abstract base class for all file readers.">DataReader</a> <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> </dd></dl>

</div>
</div>
<a id="af791b6c40d260174cfe13d1b910a2997" name="af791b6c40d260174cfe13d1b910a2997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af791b6c40d260174cfe13d1b910a2997">&#9670;&#160;</a></span>getDataWriterFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> * inviwo::util::getDataWriterFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> </dd></dl>

</div>
</div>
<a id="ad10f29c6754fa85df59d5733cc2fe575" name="ad10f29c6754fa85df59d5733cc2fe575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10f29c6754fa85df59d5733cc2fe575">&#9670;&#160;</a></span>getDataWriterFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> * inviwo::util::getDataWriterFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> </dd></dl>

</div>
</div>
<a id="aedde0f16b84fba22f20ff5f4decb2886" name="aedde0f16b84fba22f20ff5f4decb2886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedde0f16b84fba22f20ff5f4decb2886">&#9670;&#160;</a></span>getDataWriterFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> * inviwo::util::getDataWriterFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> </dd></dl>

</div>
</div>
<a id="a218c489b7b18b032fe820723a6763220" name="a218c489b7b18b032fe820723a6763220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218c489b7b18b032fe820723a6763220">&#9670;&#160;</a></span>getDataWriterFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> * inviwo::util::getDataWriterFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> <a class="el" href="classinviwo_1_1DataWriterFactory.html">DataWriterFactory</a> </dd></dl>

</div>
</div>
<a id="a86d2b2443c5b46240122de8b5dd5b400" name="a86d2b2443c5b46240122de8b5dd5b400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d2b2443c5b46240122de8b5dd5b400">&#9670;&#160;</a></span>getDefaultTimerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> &amp; inviwo::util::getDefaultTimerThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the default <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> from the app. </p>

</div>
</div>
<a id="adddd3009e57cad26baf545989a534a83" name="adddd3009e57cad26baf545989a534a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddd3009e57cad26baf545989a534a83">&#9670;&#160;</a></span>getDialogFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> * inviwo::util::getDialogFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> </dd></dl>

</div>
</div>
<a id="ae9e23f2ba516c17cafc8332c363ddf20" name="ae9e23f2ba516c17cafc8332c363ddf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e23f2ba516c17cafc8332c363ddf20">&#9670;&#160;</a></span>getDialogFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> * inviwo::util::getDialogFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> </dd></dl>

</div>
</div>
<a id="a69f2666044e4fc6a71095773d48cff0c" name="a69f2666044e4fc6a71095773d48cff0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f2666044e4fc6a71095773d48cff0c">&#9670;&#160;</a></span>getDialogFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> * inviwo::util::getDialogFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> </dd></dl>

</div>
</div>
<a id="a186c1e11a68572b7b72f108e6dbe1938" name="a186c1e11a68572b7b72f108e6dbe1938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186c1e11a68572b7b72f108e6dbe1938">&#9670;&#160;</a></span>getDialogFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> * inviwo::util::getDialogFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Dialog.html">Dialog</a> <a class="el" href="classinviwo_1_1DialogFactory.html">DialogFactory</a> </dd></dl>

</div>
</div>
<a id="aeb37235946d4585a005b69fb8d3108ae" name="aeb37235946d4585a005b69fb8d3108ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb37235946d4585a005b69fb8d3108ae">&#9670;&#160;</a></span>getInportFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> * inviwo::util::getInportFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> </dd></dl>

</div>
</div>
<a id="ace64aafb2b90aff39a7de052c44c6fd6" name="ace64aafb2b90aff39a7de052c44c6fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace64aafb2b90aff39a7de052c44c6fd6">&#9670;&#160;</a></span>getInportFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> * inviwo::util::getInportFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> </dd></dl>

</div>
</div>
<a id="a5bf592017e46c128612fba4707622ad2" name="a5bf592017e46c128612fba4707622ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf592017e46c128612fba4707622ad2">&#9670;&#160;</a></span>getInportFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> * inviwo::util::getInportFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> </dd></dl>

</div>
</div>
<a id="a8ce439b90c0fdfa31bf496f9e079901f" name="a8ce439b90c0fdfa31bf496f9e079901f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce439b90c0fdfa31bf496f9e079901f">&#9670;&#160;</a></span>getInportFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> * inviwo::util::getInportFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Inport.html" title="Abstract base class for all inports An Inport can be connected to an Outport. The approved connection...">Inport</a> <a class="el" href="classinviwo_1_1InportFactory.html">InportFactory</a> </dd></dl>

</div>
</div>
<a id="a458419095875341f984870e6f8e9fd13" name="a458419095875341f984870e6f8e9fd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458419095875341f984870e6f8e9fd13">&#9670;&#160;</a></span>getInviwoApplication() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> </p>

</div>
</div>
<a id="a608356f2ce89e1326c5ab6910337a907" name="a608356f2ce89e1326c5ab6910337a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608356f2ce89e1326c5ab6910337a907">&#9670;&#160;</a></span>getInviwoApplication() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> </p>

</div>
</div>
<a id="aba248938bdec0647ee6706ea2ece4c8c" name="aba248938bdec0647ee6706ea2ece4c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba248938bdec0647ee6706ea2ece4c8c">&#9670;&#160;</a></span>getInviwoApplication() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> </p>

</div>
</div>
<a id="a6ab66fbd51685a6de63dfd0e06b89013" name="a6ab66fbd51685a6de63dfd0e06b89013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab66fbd51685a6de63dfd0e06b89013">&#9670;&#160;</a></span>getInviwoApplication() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> </p>

</div>
</div>
<a id="a0baa816930736caaf0d8b9f4e0733723" name="a0baa816930736caaf0d8b9f4e0733723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baa816930736caaf0d8b9f4e0733723">&#9670;&#160;</a></span>getInviwoApplication() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> </p>

</div>
</div>
<a id="a538a9a4720640e9bb18b5b8a2000cb83" name="a538a9a4720640e9bb18b5b8a2000cb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538a9a4720640e9bb18b5b8a2000cb83">&#9670;&#160;</a></span>getLibrarySearchPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::filesystem::path &gt; inviwo::util::getLibrarySearchPaths </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns paths to search for module libraries. All platforms: executable directory and application modules directory (AppData/Inviwo/modules on windows). Platform dependent search directories: OSX: DYLD_LIBRARY_PATH UNIX: LD_LIBRARY_PATH/LD_RUN_PATH, RPATH and "executable directory
/../../lib". </p>
<dl class="section return"><dt>Returns</dt><dd>List of paths to directories </dd></dl>

</div>
</div>
<a id="af3c2e1caf7ae7eb2ed27584c20c8882c" name="af3c2e1caf7ae7eb2ed27584c20c8882c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c2e1caf7ae7eb2ed27584c20c8882c">&#9670;&#160;</a></span>getMeshDrawerFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> * inviwo::util::getMeshDrawerFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> </dd></dl>

</div>
</div>
<a id="a4d03cd82ba9e0c25d55d56f84182db58" name="a4d03cd82ba9e0c25d55d56f84182db58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d03cd82ba9e0c25d55d56f84182db58">&#9670;&#160;</a></span>getMeshDrawerFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> * inviwo::util::getMeshDrawerFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> </dd></dl>

</div>
</div>
<a id="aaebb0173adbe89836698e846ded2bc33" name="aaebb0173adbe89836698e846ded2bc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebb0173adbe89836698e846ded2bc33">&#9670;&#160;</a></span>getMeshDrawerFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> * inviwo::util::getMeshDrawerFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> </dd></dl>

</div>
</div>
<a id="aca24404f35e96d489dae994fcbaec7b2" name="aca24404f35e96d489dae994fcbaec7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca24404f35e96d489dae994fcbaec7b2">&#9670;&#160;</a></span>getMeshDrawerFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> * inviwo::util::getMeshDrawerFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MeshDrawer.html">MeshDrawer</a> <a class="el" href="classinviwo_1_1MeshDrawerFactory.html">MeshDrawerFactory</a> </dd></dl>

</div>
</div>
<a id="a72f0efd826c637426672e1c60dd26c52" name="a72f0efd826c637426672e1c60dd26c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f0efd826c637426672e1c60dd26c52">&#9670;&#160;</a></span>getMetaData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API const <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> * inviwo::util::getMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the meta data of the processor. </p>

</div>
</div>
<a id="af74c8c14214ac56aeafc8d0165333c57" name="af74c8c14214ac56aeafc8d0165333c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74c8c14214ac56aeafc8d0165333c57">&#9670;&#160;</a></span>getMetaData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> * inviwo::util::getMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the meta data of the processor. </p>

</div>
</div>
<a id="aec4215ec03970d45f9aa9821701d6159" name="aec4215ec03970d45f9aa9821701d6159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4215ec03970d45f9aa9821701d6159">&#9670;&#160;</a></span>getMetaDataFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> * inviwo::util::getMetaDataFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> </dd></dl>

</div>
</div>
<a id="a59492d6e149b187c8a8514f9260bab9d" name="a59492d6e149b187c8a8514f9260bab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59492d6e149b187c8a8514f9260bab9d">&#9670;&#160;</a></span>getMetaDataFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> * inviwo::util::getMetaDataFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> </dd></dl>

</div>
</div>
<a id="a00b0438bcba0a5ff305142481e6d940a" name="a00b0438bcba0a5ff305142481e6d940a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b0438bcba0a5ff305142481e6d940a">&#9670;&#160;</a></span>getMetaDataFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> * inviwo::util::getMetaDataFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> </dd></dl>

</div>
</div>
<a id="a0d5b7960202bcd6a57324a5533026576" name="a0d5b7960202bcd6a57324a5533026576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5b7960202bcd6a57324a5533026576">&#9670;&#160;</a></span>getMetaDataFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> * inviwo::util::getMetaDataFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1MetaData.html">MetaData</a> <a class="el" href="classinviwo_1_1MetaDataFactory.html">MetaDataFactory</a> </dd></dl>

</div>
</div>
<a id="a721fe3b2ce0d411ffcffee6e563357bd" name="a721fe3b2ce0d411ffcffee6e563357bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721fe3b2ce0d411ffcffee6e563357bd">&#9670;&#160;</a></span>getModulePath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::filesystem::path inviwo::util::getModulePath </td>
          <td>(</td>
          <td class="paramtype">ModulePath</td>          <td class="paramname"><span class="paramname"><em>pathType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the path for a specific type located within the requested module of type T </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathType</td><td>type of the requested path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subdirectory of the module matching the type </dd></dl>

</div>
</div>
<a id="a03965ae6be1bd4270e8d4eaba85eb02b" name="a03965ae6be1bd4270e8d4eaba85eb02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03965ae6be1bd4270e8d4eaba85eb02b">&#9670;&#160;</a></span>getModulePath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::filesystem::path inviwo::util::getModulePath </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModulePath</td>          <td class="paramname"><span class="paramname"><em>pathType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the path for a specific type located within the requested module </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identifier</td><td>name of the module </td></tr>
    <tr><td class="paramname">pathType</td><td>type of the requested path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subdirectory of the module matching the type </dd></dl>

</div>
</div>
<a id="a225f353c2a283f7b1ebdb76be3405bfb" name="a225f353c2a283f7b1ebdb76be3405bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225f353c2a283f7b1ebdb76be3405bfb">&#9670;&#160;</a></span>getOutportFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> * inviwo::util::getOutportFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> </dd></dl>

</div>
</div>
<a id="acbf4564075f6757c039d1ab7bddcd332" name="acbf4564075f6757c039d1ab7bddcd332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf4564075f6757c039d1ab7bddcd332">&#9670;&#160;</a></span>getOutportFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> * inviwo::util::getOutportFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> </dd></dl>

</div>
</div>
<a id="a985c8457f309f6939b350d0877a688ea" name="a985c8457f309f6939b350d0877a688ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985c8457f309f6939b350d0877a688ea">&#9670;&#160;</a></span>getOutportFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> * inviwo::util::getOutportFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> </dd></dl>

</div>
</div>
<a id="afcd77e28823a1e07aac632f41f561225" name="afcd77e28823a1e07aac632f41f561225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd77e28823a1e07aac632f41f561225">&#9670;&#160;</a></span>getOutportFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> * inviwo::util::getOutportFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Outport.html" title="Abstract base class for all outports The Outport can be connected to an arbitrary number of Inports.">Outport</a> <a class="el" href="classinviwo_1_1OutportFactory.html">OutportFactory</a> </dd></dl>

</div>
</div>
<a id="a702e21fe04fa35dfbb9d289debe3728a" name="a702e21fe04fa35dfbb9d289debe3728a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702e21fe04fa35dfbb9d289debe3728a">&#9670;&#160;</a></span>getPoolSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API size_t inviwo::util::getPoolSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to query the pool size of the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> </p><dl class="section return"><dt>Returns</dt><dd>pool size of the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a>, 0 if the application is not initialized </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1InviwoApplication.html#a0ff96dc0843f202b26b603a1aef5e8d7">InviwoApplication::getPoolSize()</a>, InviwoApplication::isInitialized </dd></dl>

</div>
</div>
<a id="a6424aa0b7ed27584e4aec9e50332f8b5" name="a6424aa0b7ed27584e4aec9e50332f8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6424aa0b7ed27584e4aec9e50332f8b5">&#9670;&#160;</a></span>getPortInspectorFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> * inviwo::util::getPortInspectorFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> </dd></dl>

</div>
</div>
<a id="a337ca58f1ab197b5b538f2df2c3d60d9" name="a337ca58f1ab197b5b538f2df2c3d60d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337ca58f1ab197b5b538f2df2c3d60d9">&#9670;&#160;</a></span>getPortInspectorFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> * inviwo::util::getPortInspectorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> </dd></dl>

</div>
</div>
<a id="a3328a7f85bb10bc4f68e01e589e91c7f" name="a3328a7f85bb10bc4f68e01e589e91c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3328a7f85bb10bc4f68e01e589e91c7f">&#9670;&#160;</a></span>getPortInspectorFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> * inviwo::util::getPortInspectorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> </dd></dl>

</div>
</div>
<a id="ae9068605538c589091a4f93f8094dd6c" name="ae9068605538c589091a4f93f8094dd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9068605538c589091a4f93f8094dd6c">&#9670;&#160;</a></span>getPortInspectorFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> * inviwo::util::getPortInspectorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PortInspector.html">PortInspector</a> <a class="el" href="classinviwo_1_1PortInspectorFactory.html">PortInspectorFactory</a> </dd></dl>

</div>
</div>
<a id="a5f521098da377963713d6db28a4d5f6e" name="a5f521098da377963713d6db28a4d5f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f521098da377963713d6db28a4d5f6e">&#9670;&#160;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API ivec2 inviwo::util::getPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the position of the processor. </p>

</div>
</div>
<a id="a1ad4b58375e9767217d380b694a0f008" name="a1ad4b58375e9767217d380b694a0f008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad4b58375e9767217d380b694a0f008">&#9670;&#160;</a></span>getPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; ivec2 &gt; inviwo::util::getPositions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>processors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the positions of the processors in the list. </p>

</div>
</div>
<a id="a917b0dac4338ee41354df68a988d4bca" name="a917b0dac4338ee41354df68a988d4bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917b0dac4338ee41354df68a988d4bca">&#9670;&#160;</a></span>getPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; ivec2 &gt; inviwo::util::getPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>network</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the positions of the processors in the network. </p>

</div>
</div>
<a id="aeb568474e1a5f55a03b19fa17d57bd57" name="aeb568474e1a5f55a03b19fa17d57bd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb568474e1a5f55a03b19fa17d57bd57">&#9670;&#160;</a></span>getProcessorFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> * inviwo::util::getProcessorFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> </dd></dl>

</div>
</div>
<a id="a579d52054f6b553e91c9fa6b96ba7951" name="a579d52054f6b553e91c9fa6b96ba7951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579d52054f6b553e91c9fa6b96ba7951">&#9670;&#160;</a></span>getProcessorFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> * inviwo::util::getProcessorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> </dd></dl>

</div>
</div>
<a id="a0abb99ecd4d684f9f6e7db38c14189f4" name="a0abb99ecd4d684f9f6e7db38c14189f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abb99ecd4d684f9f6e7db38c14189f4">&#9670;&#160;</a></span>getProcessorFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> * inviwo::util::getProcessorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> </dd></dl>

</div>
</div>
<a id="a5e419deed7ae61aca5e6c42991dac4ca" name="a5e419deed7ae61aca5e6c42991dac4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e419deed7ae61aca5e6c42991dac4ca">&#9670;&#160;</a></span>getProcessorFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> * inviwo::util::getProcessorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> <a class="el" href="classinviwo_1_1ProcessorFactory.html">ProcessorFactory</a> </dd></dl>

</div>
</div>
<a id="ae521c3dff86b5ef56d2797786d2b95bf" name="ae521c3dff86b5ef56d2797786d2b95bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae521c3dff86b5ef56d2797786d2b95bf">&#9670;&#160;</a></span>getProcessorModule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> * inviwo::util::getProcessorModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>app</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find which module that registered a processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>the processor to look for </td></tr>
    <tr><td class="paramname">app</td><td>the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> needed to get the modules </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classinviwo_1_1InviwoModule.html" title="A module class contains registrations of functionality, such as processors, ports,...">InviwoModule</a> that registered the processor or nullptr if not found </dd></dl>

</div>
</div>
<a id="a1edb2ff6faa4d51610458290ed1f45c5" name="a1edb2ff6faa4d51610458290ed1f45c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edb2ff6faa4d51610458290ed1f45c5">&#9670;&#160;</a></span>getProcessorModule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> * inviwo::util::getProcessorModule </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>classIdentifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>app</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find which module that registered a processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classIdentifier</td><td>the class identifier of the processor to look for </td></tr>
    <tr><td class="paramname">app</td><td>the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> needed to get the modules </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classinviwo_1_1InviwoModule.html" title="A module class contains registrations of functionality, such as processors, ports,...">InviwoModule</a> that registered the processor or nullptr if not found </dd></dl>

</div>
</div>
<a id="a0ec54f1f2a92884f6dbee0f725a8c6f9" name="a0ec54f1f2a92884f6dbee0f725a8c6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec54f1f2a92884f6dbee0f725a8c6f9">&#9670;&#160;</a></span>getProcessorModuleIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::optional&lt; std::string &gt; inviwo::util::getProcessorModuleIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>classIdentifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>app</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the module identifier of a registered processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classIdentifier</td><td>the class identifier of the processor to look for </td></tr>
    <tr><td class="paramname">app</td><td>the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> needed to get the modules </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identifer of the module that registered the processor or nullopt if not found </dd></dl>

</div>
</div>
<a id="aa18a8d1ff055cdc4871caaf9105fb714" name="aa18a8d1ff055cdc4871caaf9105fb714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18a8d1ff055cdc4871caaf9105fb714">&#9670;&#160;</a></span>getProcessorWidgetFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> * inviwo::util::getProcessorWidgetFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a822bd9c723e6c3ff5b8811c1661ab619" name="a822bd9c723e6c3ff5b8811c1661ab619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822bd9c723e6c3ff5b8811c1661ab619">&#9670;&#160;</a></span>getProcessorWidgetFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> * inviwo::util::getProcessorWidgetFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a3769912920cb25676b87a3e9e18894fb" name="a3769912920cb25676b87a3e9e18894fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3769912920cb25676b87a3e9e18894fb">&#9670;&#160;</a></span>getProcessorWidgetFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> * inviwo::util::getProcessorWidgetFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="af84d061d989c94549b2515228784d390" name="af84d061d989c94549b2515228784d390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84d061d989c94549b2515228784d390">&#9670;&#160;</a></span>getProcessorWidgetFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> * inviwo::util::getProcessorWidgetFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1ProcessorWidget.html">ProcessorWidget</a> <a class="el" href="classinviwo_1_1ProcessorWidgetFactory.html">ProcessorWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a4eaf5599590a84ca5b5a7c7a753cba00" name="a4eaf5599590a84ca5b5a7c7a753cba00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaf5599590a84ca5b5a7c7a753cba00">&#9670;&#160;</a></span>getPropertyConverterManager() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> * inviwo::util::getPropertyConverterManager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyConverter.html">PropertyConverter</a> <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </dd></dl>

</div>
</div>
<a id="ac8439998a9ed40b44da4bd7058115463" name="ac8439998a9ed40b44da4bd7058115463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8439998a9ed40b44da4bd7058115463">&#9670;&#160;</a></span>getPropertyConverterManager() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> * inviwo::util::getPropertyConverterManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyConverter.html">PropertyConverter</a> <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </dd></dl>

</div>
</div>
<a id="ab33c29f2ec6e6af67b8420361ee84bcd" name="ab33c29f2ec6e6af67b8420361ee84bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c29f2ec6e6af67b8420361ee84bcd">&#9670;&#160;</a></span>getPropertyConverterManager() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> * inviwo::util::getPropertyConverterManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyConverter.html">PropertyConverter</a> <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </dd></dl>

</div>
</div>
<a id="a2d250f0b31a70916c4ad6cdda9a5a3d2" name="a2d250f0b31a70916c4ad6cdda9a5a3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d250f0b31a70916c4ad6cdda9a5a3d2">&#9670;&#160;</a></span>getPropertyConverterManager() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> * inviwo::util::getPropertyConverterManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyConverter.html">PropertyConverter</a> <a class="el" href="classinviwo_1_1PropertyConverterManager.html">PropertyConverterManager</a> </dd></dl>

</div>
</div>
<a id="aa9840b2cdf93710505c943c60aebde12" name="aa9840b2cdf93710505c943c60aebde12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9840b2cdf93710505c943c60aebde12">&#9670;&#160;</a></span>getPropertyFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> * inviwo::util::getPropertyFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> </dd></dl>

</div>
</div>
<a id="afaa3e4c9abdac91937ddd9f54296e200" name="afaa3e4c9abdac91937ddd9f54296e200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa3e4c9abdac91937ddd9f54296e200">&#9670;&#160;</a></span>getPropertyFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> * inviwo::util::getPropertyFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> </dd></dl>

</div>
</div>
<a id="a4e01abba5d8d446507b0361215de3ac2" name="a4e01abba5d8d446507b0361215de3ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e01abba5d8d446507b0361215de3ac2">&#9670;&#160;</a></span>getPropertyFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> * inviwo::util::getPropertyFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> </dd></dl>

</div>
</div>
<a id="aead4f50d8139c890e18633be5cf70b0f" name="aead4f50d8139c890e18633be5cf70b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead4f50d8139c890e18633be5cf70b0f">&#9670;&#160;</a></span>getPropertyFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> * inviwo::util::getPropertyFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> <a class="el" href="classinviwo_1_1PropertyFactory.html">PropertyFactory</a> </dd></dl>

</div>
</div>
<a id="acd81fc6f5826cfebaae57f83c333f28d" name="acd81fc6f5826cfebaae57f83c333f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd81fc6f5826cfebaae57f83c333f28d">&#9670;&#160;</a></span>getPropertyWidgetFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> * inviwo::util::getPropertyWidgetFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a55e9003338a7f346abe69f37ed05e40d" name="a55e9003338a7f346abe69f37ed05e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e9003338a7f346abe69f37ed05e40d">&#9670;&#160;</a></span>getPropertyWidgetFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> * inviwo::util::getPropertyWidgetFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a35ba7caad19de318e26f6a20c77950ba" name="a35ba7caad19de318e26f6a20c77950ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ba7caad19de318e26f6a20c77950ba">&#9670;&#160;</a></span>getPropertyWidgetFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> * inviwo::util::getPropertyWidgetFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a42568695652844d78dbfdcf49cb711a2" name="a42568695652844d78dbfdcf49cb711a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42568695652844d78dbfdcf49cb711a2">&#9670;&#160;</a></span>getPropertyWidgetFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> * inviwo::util::getPropertyWidgetFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> factory </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PropertyWidget.html">PropertyWidget</a> <a class="el" href="classinviwo_1_1PropertyWidgetFactory.html">PropertyWidgetFactory</a> </dd></dl>

</div>
</div>
<a id="a4e66064e0eca754510e1499e8acbfae8" name="a4e66064e0eca754510e1499e8acbfae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e66064e0eca754510e1499e8acbfae8">&#9670;&#160;</a></span>getRepresentationConverterMetaFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> * inviwo::util::getRepresentationConverterMetaFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Converter Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationConverterFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationConverter.html">RepresentationConverter</a> <a class="el" href="classinviwo_1_1RepresentationConverterFactory.html">RepresentationConverterFactory</a> <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> </dd></dl>

</div>
</div>
<a id="a6d9bd887300af6145ef80867de65ca5d" name="a6d9bd887300af6145ef80867de65ca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9bd887300af6145ef80867de65ca5d">&#9670;&#160;</a></span>getRepresentationConverterMetaFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> * inviwo::util::getRepresentationConverterMetaFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Converter Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationConverterFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationConverter.html">RepresentationConverter</a> <a class="el" href="classinviwo_1_1RepresentationConverterFactory.html">RepresentationConverterFactory</a> <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> </dd></dl>

</div>
</div>
<a id="a4d30e7a22eadb5c072c03cef4d8043cc" name="a4d30e7a22eadb5c072c03cef4d8043cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d30e7a22eadb5c072c03cef4d8043cc">&#9670;&#160;</a></span>getRepresentationConverterMetaFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> * inviwo::util::getRepresentationConverterMetaFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Converter Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationConverterFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationConverter.html">RepresentationConverter</a> <a class="el" href="classinviwo_1_1RepresentationConverterFactory.html">RepresentationConverterFactory</a> <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> </dd></dl>

</div>
</div>
<a id="aede753d265f637170350697f0179541d" name="aede753d265f637170350697f0179541d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede753d265f637170350697f0179541d">&#9670;&#160;</a></span>getRepresentationConverterMetaFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> * inviwo::util::getRepresentationConverterMetaFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Converter Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationConverterFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationConverter.html">RepresentationConverter</a> <a class="el" href="classinviwo_1_1RepresentationConverterFactory.html">RepresentationConverterFactory</a> <a class="el" href="classinviwo_1_1RepresentationConverterMetaFactory.html">RepresentationConverterMetaFactory</a> </dd></dl>

</div>
</div>
<a id="af9162a4e2c222f4eb070608e9159a299" name="af9162a4e2c222f4eb070608e9159a299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9162a4e2c222f4eb070608e9159a299">&#9670;&#160;</a></span>getRepresentationMetaFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> * inviwo::util::getRepresentationMetaFactory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationFactory.html">RepresentationFactory</a> <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> </dd></dl>

</div>
</div>
<a id="af2faab1f347a6ec696b4d7dd494c23e2" name="af2faab1f347a6ec696b4d7dd494c23e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2faab1f347a6ec696b4d7dd494c23e2">&#9670;&#160;</a></span>getRepresentationMetaFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> * inviwo::util::getRepresentationMetaFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationFactory.html">RepresentationFactory</a> <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> </dd></dl>

</div>
</div>
<a id="a2d79174e78d30a6af364908f10f421e2" name="a2d79174e78d30a6af364908f10f421e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d79174e78d30a6af364908f10f421e2">&#9670;&#160;</a></span>getRepresentationMetaFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> * inviwo::util::getRepresentationMetaFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationFactory.html">RepresentationFactory</a> <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> </dd></dl>

</div>
</div>
<a id="ac5210a10605942a6808dc8f4fc095509" name="ac5210a10605942a6808dc8f4fc095509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5210a10605942a6808dc8f4fc095509">&#9670;&#160;</a></span>getRepresentationMetaFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> * inviwo::util::getRepresentationMetaFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Representation Meta <a class="el" href="classinviwo_1_1Factory.html">Factory</a> holds RepresentationFactories for various kinds of representations (<a class="el" href="classinviwo_1_1Volume.html">Volume</a> Representation, <a class="el" href="classinviwo_1_1Layer.html">Layer</a> Representation, <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a> Representation, etc) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Data.html" title="The base class for all data objects.">Data</a> <a class="el" href="classinviwo_1_1DataRepresentation.html" title="Base class for all DataRepresentations.">DataRepresentation</a> <a class="el" href="classinviwo_1_1RepresentationFactory.html">RepresentationFactory</a> <a class="el" href="classinviwo_1_1RepresentationMetaFactory.html">RepresentationMetaFactory</a> </dd></dl>

</div>
</div>
<a id="a13808ea8c1dd607e9e3c4d4d2ac28fef" name="a13808ea8c1dd607e9e3c4d4d2ac28fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13808ea8c1dd607e9e3c4d4d2ac28fef">&#9670;&#160;</a></span>getResourceManager() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> * inviwo::util::getResourceManager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structinviwo_1_1Resource.html">Resource</a> Manager </p>

</div>
</div>
<a id="a9636e75c722c445752b25b025ae8616c" name="a9636e75c722c445752b25b025ae8616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9636e75c722c445752b25b025ae8616c">&#9670;&#160;</a></span>getResourceManager() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> * inviwo::util::getResourceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *</td>          <td class="paramname"><span class="paramname"><em>app</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structinviwo_1_1Resource.html">Resource</a> Manager </p>

</div>
</div>
<a id="ade2d0033f3187cc5e974c86807a8ba4a" name="ade2d0033f3187cc5e974c86807a8ba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2d0033f3187cc5e974c86807a8ba4a">&#9670;&#160;</a></span>getResourceManager() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> * inviwo::util::getResourceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structinviwo_1_1Resource.html">Resource</a> Manager </p>

</div>
</div>
<a id="ae69ba056958e896c36c307cef6c8be5d" name="ae69ba056958e896c36c307cef6c8be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69ba056958e896c36c307cef6c8be5d">&#9670;&#160;</a></span>getResourceManager() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ResourceManager.html">ResourceManager</a> * inviwo::util::getResourceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *</td>          <td class="paramname"><span class="paramname"><em>property</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structinviwo_1_1Resource.html">Resource</a> Manager </p>

</div>
</div>
<a id="ab73ec645cb3206ba1ffd1d9bea0747ee" name="ab73ec645cb3206ba1ffd1d9bea0747ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73ec645cb3206ba1ffd1d9bea0747ee">&#9670;&#160;</a></span>getVolumeDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size3_t IVW_CORE_API inviwo::util::getVolumeDimensions </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the true volume dimensions considering volume margins and bricking </p>
<dl class="section return"><dt>Returns</dt><dd>true volume dimensions </dd></dl>

</div>
</div>
<a id="a2694731debfdf03c3fe12fd45f760e22" name="a2694731debfdf03c3fe12fd45f760e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2694731debfdf03c3fe12fd45f760e22">&#9670;&#160;</a></span>getVolumeMargins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; vec3, vec3 &gt; IVW_CORE_API inviwo::util::getVolumeMargins </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the margins of a volume, in normalized texture coordinates [0,1] </p>
<dl class="section return"><dt>Returns</dt><dd>pair of margins from the bottom left corner and the top right corner </dd></dl>

</div>
</div>
<a id="ae998c98a827c0d18229a6f1775ff0a8f" name="ae998c98a827c0d18229a6f1775ff0a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae998c98a827c0d18229a6f1775ff0a8f">&#9670;&#160;</a></span>haltonSequence() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfPoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>baseX</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>baseY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a <a class="el" href="classinviwo_1_1Layer.html">Layer</a> with sparse noise based on a pair of two Halton Sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae4a4886800ee3ba916742c7158b183d4">haltonSequence(size_t base, size_t numberOfPoints)</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of the resulting layer. </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">baseX</td><td>base used for the fractions to generate the x-values </td></tr>
    <tr><td class="paramname">baseY</td><td>base used for the fractions to generate the y-values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec5a54031ffd03ed97bb957ca8f522d3" name="aec5a54031ffd03ed97bb957ca8f522d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5a54031ffd03ed97bb957ca8f522d3">&#9670;&#160;</a></span>haltonSequence() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size3_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfPoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>baseX</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>baseY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>baseZ</em></span><span class="paramdefsep"> = </span><span class="paramdefval">5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Volume.html">Volume</a> with sparse noise based on a three Halton Sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae4a4886800ee3ba916742c7158b183d4">haltonSequence(size_t base, size_t numberOfPoints)</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of the resulting <a class="el" href="classinviwo_1_1Volume.html">Volume</a>. </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">baseX</td><td>base used for the fractions to generate the x-values </td></tr>
    <tr><td class="paramname">baseY</td><td>base used for the fractions to generate the y-values </td></tr>
    <tr><td class="paramname">baseZ</td><td>base used for the fractions to generate the z-values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4a4886800ee3ba916742c7158b183d4" name="ae4a4886800ee3ba916742c7158b183d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a4886800ee3ba916742c7158b183d4">&#9670;&#160;</a></span>haltonSequence() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the <code>n</code> th point of the Halton sequence with base <code>base</code> on the open range (0 1). </p><dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>what base to use to generate fractions </td></tr>
    <tr><td class="paramname">n</td><td>index of the nth point of the Halton sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nth </dd></dl>

</div>
</div>
<a id="a903ca9372bd3a12d9a2579ac7c99c890" name="a903ca9372bd3a12d9a2579ac7c99c890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903ca9372bd3a12d9a2579ac7c99c890">&#9670;&#160;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to combine several hash values <a href="http://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x">http://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x</a> </p>

</div>
</div>
<a id="a72163c26b092ba2ad01a8ba8af763d59" name="a72163c26b092ba2ad01a8ba8af763d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72163c26b092ba2ad01a8ba8af763d59">&#9670;&#160;</a></span>iCaseEndsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::util::iCaseEndsWith </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if provided string ends with suffix using case insensitive equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to check last part of. Allowed to be smaller than suffix. </td></tr>
    <tr><td class="paramname">suffix</td><td>Ending to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if last part of str is equal to suffix, false otherwise. </dd></dl>

</div>
</div>
<a id="af36a5eb1a40ce3beee139b0564980a54" name="af36a5eb1a40ce3beee139b0564980a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36a5eb1a40ce3beee139b0564980a54">&#9670;&#160;</a></span>importIsoValueCollectionDialog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1IsoValueCollection.html">IsoValueCollection</a> &gt; inviwo::util::importIsoValueCollectionDialog </td>
          <td>(</td>
          <td class="paramtype">QWidget *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to import a <a class="el" href="classinviwo_1_1IsoValueCollection.html" title="data structure representing isovalues">IsoValueCollection</a> from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent widget of the file dialog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd9a27c97b0b7391d9538f03a329b4d0" name="afd9a27c97b0b7391d9538f03a329b4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9a27c97b0b7391d9538f03a329b4d0">&#9670;&#160;</a></span>importTransferFunctionDialog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1TransferFunction.html">TransferFunction</a> &gt; inviwo::util::importTransferFunctionDialog </td>
          <td>(</td>
          <td class="paramtype">QWidget *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to import a <a class="el" href="classinviwo_1_1TransferFunction.html" title="data structure for holding 1D transfer function data">TransferFunction</a> from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent widget of the file dialog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a255656e04e9caab0092cefb2387b522c" name="a255656e04e9caab0092cefb2387b522c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255656e04e9caab0092cefb2387b522c">&#9670;&#160;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Tuple , size_t count = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t inviwo::util::index_of </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index of a type in a tuple, returns the index of the first matching type </p>

</div>
</div>
<a id="a144ffacb1ddf668f23cac00ffca4071a" name="a144ffacb1ddf668f23cac00ffca4071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ffacb1ddf668f23cac00ffca4071a">&#9670;&#160;</a></span>index_of_derived()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Tuple , size_t count = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t inviwo::util::index_of_derived </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index of the first type in the Tuple that is derived from T </p>

</div>
</div>
<a id="a7669f35617341a0ec4465acb3a0b4a93" name="a7669f35617341a0ec4465acb3a0b4a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7669f35617341a0ec4465acb3a0b4a93">&#9670;&#160;</a></span>interpolateAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::interpolateAlpha </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate the alpha values of selected primitives in between the first and the last primitive based on their relative position. </p>

</div>
</div>
<a id="a9043d4a86a79be19df535ce9731f0153" name="a9043d4a86a79be19df535ce9731f0153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9043d4a86a79be19df535ce9731f0153">&#9670;&#160;</a></span>is_callable_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... A, typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::is_callable_with </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A type trait to determine if type "callback" can be called with certain arguments. Example: util::is_callable_with&lt;float&gt;(callback) where callback = [](float){} -&gt; true callback = [](std::string){} -&gt; false </p>

</div>
</div>
<a id="aa048b0cf2e27625499d9ac8e03af03d6" name="aa048b0cf2e27625499d9ac8e03af03d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa048b0cf2e27625499d9ac8e03af03d6">&#9670;&#160;</a></span>isConvex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isConvex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polygon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether the given polygon is convex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>polygon consisting of points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the polygon is convex, false otherwise </dd></dl>

</div>
</div>
<a id="a193aac2254d9cc5b5b1029995323d957" name="a193aac2254d9cc5b5b1029995323d957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193aac2254d9cc5b5b1029995323d957">&#9670;&#160;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isInside </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>hull</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a given point lies within the convex hull </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hull</td><td>convex hull </td></tr>
    <tr><td class="paramname">p</td><td>point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point lies inside the convex hull </dd></dl>

</div>
</div>
<a id="a819d6ed95184ff0ae2c68b501dcd0cff" name="a819d6ed95184ff0ae2c68b501dcd0cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d6ed95184ff0ae2c68b501dcd0cff">&#9670;&#160;</a></span>isInviwoApplicationInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::util::isInviwoApplicationInitialized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to return whether the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> is initialized </p><dl class="section see"><dt>See also</dt><dd>InviwoApplication::isInitialized </dd></dl>

</div>
</div>
<a id="a33720f81ed26a3562c7447ce9eb89288" name="a33720f81ed26a3562c7447ce9eb89288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33720f81ed26a3562c7447ce9eb89288">&#9670;&#160;</a></span>isSelected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::util::isSelected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the selection state of processor. </p>

</div>
</div>
<a id="a90dfea83005204a1c4beaa3714c38e74" name="a90dfea83005204a1c4beaa3714c38e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dfea83005204a1c4beaa3714c38e74">&#9670;&#160;</a></span>layerRAMDistanceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::layerRAMDistanceTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>inLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *</td>          <td class="paramname"><span class="paramname"><em>outDistanceField</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; 2, U &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size2_t</td>          <td class="paramname"><span class="paramname"><em>upsample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTransform</td>          <td class="paramname"><span class="paramname"><em>valueTransform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProgressCallback</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Implementation of Euclidean Distance Transform according to Saito's algorithm:
</pre><p> T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance transformations of an n-dimensional digitized picture with applications. Pattern Recognition, 27(11). pp. 1551-1565, 1994. <a href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf</a></p>
<p>Calculates the distance in base mat space </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>is a function of type <code>(const T &amp;value) -&gt; bool</code> to decide if a value in the input is a "feature". </td></tr>
    <tr><td class="paramname">ValueTransform</td><td>is a function of type <code>(const U&amp; squaredDist) -&gt; U</code> that is appiled to all squared distance values at the end of the calculation. </td></tr>
    <tr><td class="paramname">ProcessCallback</td><td>is a function of type <code>(double progress) -&gt; void</code> that is called with a value from 0 to 1 to indicate the progress of the calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab36aead3fc89df1f8274c4a4ad543f2b" name="ab36aead3fc89df1f8274c4a4ad543f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36aead3fc89df1f8274c4a4ad543f2b">&#9670;&#160;</a></span>layerSubSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &gt; inviwo::util::layerSubSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clampBorderOutsideImage</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extracts a subregion from a layer and returns it as a new layer </p>
<p>This function extracts a subregion given by offset and extent from the input layer. If border clamping is enabled, the output region will be clamped to lie completely within the source layer. Otherwise (default), the areas outside the source layer will be filled with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input layer </td></tr>
    <tr><td class="paramname">offset</td><td>subregion offset in input layer </td></tr>
    <tr><td class="paramname">extent</td><td>extent (width and height) of subregion </td></tr>
    <tr><td class="paramname">clampBorderOutsideImage</td><td>if true, the output region is clamped to the layer boundaries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;LayerRAM&gt; </dd></dl>

</div>
</div>
<a id="ab6bf0cc28f51cabb7d36e15c61129f7c" name="ab6bf0cc28f51cabb7d36e15c61129f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bf0cc28f51cabb7d36e15c61129f7c">&#9670;&#160;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view inviwo::util::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>trims <code>str</code> from beginning removing white spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>trimmed stringview without leading white space </dd></dl>

</div>
</div>
<a id="aa566d97b543e2bdded79bb2a50c33bb0" name="aa566d97b543e2bdded79bb2a50c33bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa566d97b543e2bdded79bb2a50c33bb0">&#9670;&#160;</a></span>make_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::make_sequence </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>inc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">T{1}</span>&#160;) -&gt; <a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a>&lt;T&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenvience function for creating a sequence. Use case example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> inc = 2; <span class="keyword">auto</span> end = 3;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; i : <a class="code hl_function" href="#aa566d97b543e2bdded79bb2a50c33bb0">util::make_sequence</a>(0, end, inc)) {</div>
<div class="line">  <span class="comment">// Iterates over 0 and 2</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_aa566d97b543e2bdded79bb2a50c33bb0"><div class="ttname"><a href="#aa566d97b543e2bdded79bb2a50c33bb0">inviwo::util::make_sequence</a></div><div class="ttdeci">auto make_sequence(const T &amp;begin, const T &amp;end, const T &amp;inc=T{1}) -&gt; sequence&lt; T &gt;</div><div class="ttdef"><b>Definition</b> zip.h:551</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a95a518b92960df1752bebaa80ec50c61" name="a95a518b92960df1752bebaa80ec50c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a518b92960df1752bebaa80ec50c61">&#9670;&#160;</a></span>makeIndirectIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool PropagateConst = true, typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a>&lt; Iter, PropagateConst &gt; inviwo::util::makeIndirectIterator </td>
          <td>(</td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a> </dd></dl>

</div>
</div>
<a id="ab618818fcbf3c386f0f07928ce06821f" name="ab618818fcbf3c386f0f07928ce06821f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab618818fcbf3c386f0f07928ce06821f">&#9670;&#160;</a></span>makeMarchingCubeVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeMarchingCubeVolume </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A 2x2x2 volume corresponding to a marching cube case </p>

</div>
</div>
<a id="a743b3fa3cbde44118de690fe87a21113" name="a743b3fa3cbde44118de690fe87a21113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743b3fa3cbde44118de690fe87a21113">&#9670;&#160;</a></span>makeProcessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T &gt; inviwo::util::makeProcessor </td>
          <td>(</td>
          <td class="paramtype">ivec2</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A utility function to create a processor and set identifier, display name, and position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Sets the position meta data of the <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> </td></tr>
    <tr><td class="paramname">args</td><td>Any extra arguments to supply to the <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5167c56b9fc5c53f102462d89bbf1f11" name="a5167c56b9fc5c53f102462d89bbf1f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5167c56b9fc5c53f102462d89bbf1f11">&#9670;&#160;</a></span>makeRippleVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeRippleVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A quickly oscillating density between 0 and 1 </p>

</div>
</div>
<a id="a5bb99c263ef07f00a0892cf1d9610d15" name="a5bb99c263ef07f00a0892cf1d9610d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb99c263ef07f00a0892cf1d9610d15">&#9670;&#160;</a></span>makeSingleVoxelVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeSingleVoxelVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Center voxel equal to 1 all other 0 </p>

</div>
</div>
<a id="a351bc675bcbde3fa893929b312a1b276" name="a351bc675bcbde3fa893929b312a1b276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351bc675bcbde3fa893929b312a1b276">&#9670;&#160;</a></span>makeSphericalVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeSphericalVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spherically symmetric density centered in the volume decaying radially with the distance from the center </p>

</div>
</div>
<a id="a5bec0b925a8be26aebea592ce1b00fd2" name="a5bec0b925a8be26aebea592ce1b00fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bec0b925a8be26aebea592ce1b00fd2">&#9670;&#160;</a></span>marchingcubes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingcubes </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enclose</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;</td>          <td class="paramname"><span class="paramname"><em>progressCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::function&lt;&#160;void(float)&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>maskingCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[](const&#160;size3_t&#160;&amp;)&#160;{&#160;return&#160;true;}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an isosurface from a volume using the Marching Cubes algorithm</p>
<p>Note: Share interface with <a class="el" href="#ad05c658162fd0c9fb67eb70cfd537e52">util::marchingtetrahedron</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the isosurface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], usefull for progressbars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a264903a207983c82b75a97aaa2a69545" name="a264903a207983c82b75a97aaa2a69545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264903a207983c82b75a97aaa2a69545">&#9670;&#160;</a></span>marchingCubesOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingCubesOpt </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enclose</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;</td>          <td class="paramname"><span class="paramname"><em>progressCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>maskingCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an iso surface from a volume using the Marching Cubes algorithm</p>
<p>Note: Shares interface with util::marchingcbes and <a class="el" href="#ad05c658162fd0c9fb67eb70cfd537e52">util::marchingtetrahedron</a> This is an optimized version of <a class="el" href="#a5bec0b925a8be26aebea592ce1b00fd2">util::marchingcubes</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the iso surface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], useful for progress bars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad05c658162fd0c9fb67eb70cfd537e52" name="ad05c658162fd0c9fb67eb70cfd537e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05c658162fd0c9fb67eb70cfd537e52">&#9670;&#160;</a></span>marchingtetrahedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingtetrahedron </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span><span class="paramdefsep"> = </span><span class="paramdefval">vec4(1.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invert</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enclose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;</td>          <td class="paramname"><span class="paramname"><em>progressCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::function&lt;&#160;void(float)&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>maskingCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[](const&#160;size3_t&#160;&amp;)&#160;{&#160;return&#160;true;}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an isosurface from a volume using the Marching Tetrahedron algorithm</p>
<p>Note: Share interface with <a class="el" href="#a5bec0b925a8be26aebea592ce1b00fd2">util::marchingcubes</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the isosurface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], usefull for progressbars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae84a9ec3e9841aca2ea06fa34aaaed50" name="ae84a9ec3e9841aca2ea06fa34aaaed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84a9ec3e9841aca2ea06fa34aaaed50">&#9670;&#160;</a></span>md2doc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1Document.html">Document</a> inviwo::util::md2doc </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>markdown</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a markdown string and convert to an inviwo document. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Document.html" title="A class to represent a structured document, usually some html.">Document</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markdown</td><td>A string that will be interpreted as markdown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an inviwo <a class="el" href="classinviwo_1_1Document.html" title="A class to represent a structured document, usually some html.">Document</a> with an html representation of the parsed markdown </dd></dl>

</div>
</div>
<a id="af1136c71f85d4df4b2b2449aee7121b0" name="af1136c71f85d4df4b2b2449aee7121b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1136c71f85d4df4b2b2449aee7121b0">&#9670;&#160;</a></span>msToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::msToString </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeZeros</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>spacing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the given duration from milliseconds to a string. The returned string will have the format "%dd %dh %dmin %dsec %.3fms", where days, hours, minutes, seconds, ... are suppressed up to the first non-zero unit if not needed. Milliseconds and seconds are combined if larger than 1 second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>in milliseconds </td></tr>
    <tr><td class="paramname">includeZeros</td><td>if true, time units for zero values are always shown, e.g. "2d 0h 0min 23s" vs. "2d 23s" and "2h 0min 0s" vs. "2h" </td></tr>
    <tr><td class="paramname">spacing</td><td>if true, a space is inserted between digits and units </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>duration formatted as string </dd></dl>

</div>
</div>
<a id="a1341a5fe91b0d7f378da017b90eb3779" name="a1341a5fe91b0d7f378da017b90eb3779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1341a5fe91b0d7f378da017b90eb3779">&#9670;&#160;</a></span>offsetPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::offsetPosition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>processors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset all the positions of the processors in the list by offset </p>

</div>
</div>
<a id="ada3f90c8cfa64a0898b021cca551de05" name="ada3f90c8cfa64a0898b021cca551de05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3f90c8cfa64a0898b021cca551de05">&#9670;&#160;</a></span>ordinalColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec4 &gt; inviwo::util::ordinalColor </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a></td>          <td class="paramname"><span class="paramname"><em>invalidationLevel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">InvalidationLevel::InvalidOutput</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for OrdinalProperties representing Colors When instantiating a Ordinal <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> for a color value one would need to write something along there lines </p><div class="fragment"><div class="line">color(<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, vec4(0.11f, 0.42f, 0.63f, 1.0f),</div>
<div class="line">     {vec4(0.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>},</div>
<div class="line">     {vec4(1.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>}, vec4(0.01f),</div>
<div class="line">     InvalidationLevel::InvalidOutput, PropertySemantics::Color)</div>
<div class="ttc" id="anamespaceinviwo_html_ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc"><div class="ttname"><a href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">inviwo::ConstraintBehavior::Immutable</a></div><div class="ttdeci">@ Immutable</div></div>
</div><!-- fragment --><p> by using the helper function most of the boilerplate can be removed: </p><div class="fragment"><div class="line">color{<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, <a class="code hl_function" href="#ada3f90c8cfa64a0898b021cca551de05">util::ordinalColor</a>(0.11f, 0.42f, 0.63f)}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_ada3f90c8cfa64a0898b021cca551de05"><div class="ttname"><a href="#ada3f90c8cfa64a0898b021cca551de05">inviwo::util::ordinalColor</a></div><div class="ttdeci">IVW_CORE_API OrdinalPropertyState&lt; vec4 &gt; ordinalColor(float r, float g, float b, float a=1.0f, InvalidationLevel invalidationLevel=InvalidationLevel::InvalidOutput)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae6c3c7230deaaaa556873e2684e4303f" name="ae6c3c7230deaaaa556873e2684e4303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c3c7230deaaaa556873e2684e4303f">&#9670;&#160;</a></span>ordinalCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = size_t, typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt; inviwo::util::ordinalCount </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">T{0}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">U{100}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for configuring a <a class="el" href="classinviwo_1_1OrdinalProperty.html">OrdinalProperty</a> representing a count. It will have a Immutable min at zero and an upper Ignored max. The increment will be one. The invalidation level defaults to InvalidOutput, and the property semantics to SpinBox. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the default value for the property </td></tr>
    <tr><td class="paramname">max</td><td>used to construct the max value. The max constraint behavior will be Ignore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec0d6260ee968193442da41efb8fff79" name="aec0d6260ee968193442da41efb8fff79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0d6260ee968193442da41efb8fff79">&#9670;&#160;</a></span>ordinalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt; inviwo::util::ordinalLength </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">T{0}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">U{100}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for configuring a <a class="el" href="classinviwo_1_1OrdinalProperty.html">OrdinalProperty</a> representing a length. It will have a Immutable min at zero and an upper Ignored max. The invalidation level defaults to InvalidOutput, and the property semantics to SpinBox. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the default value for the property </td></tr>
    <tr><td class="paramname">max</td><td>used to construct the max value. The max constraint behavior will be Ignore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78fe508315d93a69417c6ee9614303d6" name="a78fe508315d93a69417c6ee9614303d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fe508315d93a69417c6ee9614303d6">&#9670;&#160;</a></span>ordinalRefColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalRefPropertyState.html">OrdinalRefPropertyState</a>&lt; vec4 &gt; inviwo::util::ordinalRefColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a></td>          <td class="paramname"><span class="paramname"><em>invalidationLevel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">InvalidationLevel::InvalidOutput</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for OrdinalProperties representing Colors When instantiating a Ordinal <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> for a color value one would need to write something along there lines </p><div class="fragment"><div class="line">color(<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, vec4(0.11f, 0.42f, 0.63f, 1.0f),</div>
<div class="line">     {vec4(0.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>},</div>
<div class="line">     {vec4(1.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>}, vec4(0.01f),</div>
<div class="line">     InvalidationLevel::InvalidOutput, PropertySemantics::Color)</div>
</div><!-- fragment --><p> by using the helper function most of the boilerplate can be removed: </p><div class="fragment"><div class="line">color{<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, <a class="code hl_function" href="#ada3f90c8cfa64a0898b021cca551de05">util::ordinalColor</a>()}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6f57559577f5aec3ec856e38b2b4d58c" name="a6f57559577f5aec3ec856e38b2b4d58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f57559577f5aec3ec856e38b2b4d58c">&#9670;&#160;</a></span>ordinalRefSymmetricVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1OrdinalRefPropertyState.html">OrdinalRefPropertyState</a>&lt; T &gt; inviwo::util::ordinalRefSymmetricVector </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>minMax</em></span><span class="paramdefsep"> = </span><span class="paramdefval">U{100}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for configuring a <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">OrdinalRefProperty</a> representing a generic vector, with a symmetric range around zero, and Ignored boundary constraints. The invalidation level defaults to InvalidOutput, and the property semantics to SpinBox. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the default value for the property </td></tr>
    <tr><td class="paramname">minMax</td><td>used to construct the range of the property like min = T{-minMax}, max = T{minMax}. The constraint behavior will be Ignore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae10672d3ce62a8142941c05a182ca335" name="ae10672d3ce62a8142941c05a182ca335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10672d3ce62a8142941c05a182ca335">&#9670;&#160;</a></span>ordinalScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt; inviwo::util::ordinalScale </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">T{0}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">U{100}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for configuring a <a class="el" href="classinviwo_1_1OrdinalProperty.html">OrdinalProperty</a> representing a scale factor. It will have a Immutable min at epsilon and an upper Ignored max. The invalidation level default to InvalidOutput, and the property semantics to Slider. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the default value for the property </td></tr>
    <tr><td class="paramname">max</td><td>used to construct the max value. The max constraint behavior will be Ignore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa58b65316e88fa13b51e3f2a3093b066" name="aa58b65316e88fa13b51e3f2a3093b066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58b65316e88fa13b51e3f2a3093b066">&#9670;&#160;</a></span>ordinalSymmetricVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; T &gt; inviwo::util::ordinalSymmetricVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{0}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>minMax</em></span><span class="paramdefsep"> = </span><span class="paramdefval">U{100}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A factory function for configuring a <a class="el" href="classinviwo_1_1OrdinalProperty.html">OrdinalProperty</a> representing a generic vector, with a symmetric range around zero, and Ignored boundary constraints. The invalidation level defaults to InvalidOutput, and the property semantics to SpinBox. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the default value for the property </td></tr>
    <tr><td class="paramname">minMax</td><td>used to construct the range of the property like min = T{-minMax}, max = T{minMax}. The constraint behavior will be Ignore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17cede42366cbed152e45d50fb16d062" name="a17cede42366cbed152e45d50fb16d062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cede42366cbed152e45d50fb16d062">&#9670;&#160;</a></span>parseTypeIdName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::parseTypeIdName </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Demangle and strip the type ID given in <code>name</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>mangled type ID name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>demangled type name without <code>class</code>, <code>struct</code>, <code>const</code>, <code>inviwo::</code>, or white space </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d48f7460aa46b805b25b7c8802e1433">demangle()</a> </dd></dl>

</div>
</div>
<a id="a35a361515d9e7661be39f493d796dca6" name="a35a361515d9e7661be39f493d796dca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a361515d9e7661be39f493d796dca6">&#9670;&#160;</a></span>perlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rand  = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; inviwo::util::perlinNoise </td>
          <td>(</td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>persistence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>startLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>endLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a <a class="el" href="classinviwo_1_1Layer.html">Layer</a> with perlin noise, a cloud like noise using the sum of several white noise layers with different frequencies </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output layer </td></tr>
    <tr><td class="paramname">persistence</td><td>controls the amplitude used in the different frequencies </td></tr>
    <tr><td class="paramname">startLevel</td><td>controls the min level used. The level is determining the frequency to use in each white noise layer as 2^level </td></tr>
    <tr><td class="paramname">endLevel</td><td>controlsthe max level used. </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b0885e5f02bce9ed3ef708fe9ff059" name="a71b0885e5f02bce9ed3ef708fe9ff059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b0885e5f02bce9ed3ef708fe9ff059">&#9670;&#160;</a></span>poissonDisk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rand  = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; inviwo::util::poissonDisk </td>
          <td>(</td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>poissonDotsAlongX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxPoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a <a class="el" href="classinviwo_1_1Layer.html">Layer</a> with sparse noise based on the perlin noise algorith. </p><dl class="section see"><dt>See also</dt><dd><a href="http://devmag.org.za/2009/05/03/poisson-disk-sampling/">http://devmag.org.za/2009/05/03/poisson-disk-sampling/</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output layer </td></tr>
    <tr><td class="paramname">poissonDotsAlongX</td><td>controlls the amount on points there is on average per line, set the minimum distance between points </td></tr>
    <tr><td class="paramname">maxPoints</td><td>a fallback variable to prevent generating to many points </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb28155c56d675b83c5dc803d0a844a1" name="acb28155c56d675b83c5dc803d0a844a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb28155c56d675b83c5dc803d0a844a1">&#9670;&#160;</a></span>randomLayer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &gt; inviwo::util::randomLayer </td>
          <td>(</td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;</td>          <td class="paramname"><span class="paramname"><em>distribution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Dist(0,&#160;1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a <a class="el" href="classinviwo_1_1Layer.html">Layer</a> with white noise based using a given random number generator and distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output layer </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab539d0cecda1edf6ee5ecfe6949f38d5">randomLayerRAM</a> </dd></dl>

</div>
</div>
<a id="ab539d0cecda1edf6ee5ecfe6949f38d5" name="ab539d0cecda1edf6ee5ecfe6949f38d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab539d0cecda1edf6ee5ecfe6949f38d5">&#9670;&#160;</a></span>randomLayerRAM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; &gt; inviwo::util::randomLayerRAM </td>
          <td>(</td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;</td>          <td class="paramname"><span class="paramname"><em>distribution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Dist(0,&#160;1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a LayerRAMPrecision&lt;T&gt; with white noise based using a given random number generator and distribution. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>data type of the random numbers </td></tr>
    <tr><td class="paramname">Rand</td><td>random number engine, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">Dist</td><td>random number distribution, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the resulting layer </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> with white noise </dd></dl>

</div>
</div>
<a id="aebe4e9668671b9b73896e7d737763045" name="aebe4e9668671b9b73896e7d737763045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe4e9668671b9b73896e7d737763045">&#9670;&#160;</a></span>randomSequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::randomSequence </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;</td>          <td class="paramname"><span class="paramname"><em>distribution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Dist(0,&#160;1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a span of type T with numberOfElements random numbers using the given random number generator and distribution </p>

</div>
</div>
<a id="a48b2f672f99a31ee8b19f6f40fa768cb" name="a48b2f672f99a31ee8b19f6f40fa768cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2f672f99a31ee8b19f6f40fa768cb">&#9670;&#160;</a></span>randomSequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::randomSequence </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfElements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;</td>          <td class="paramname"><span class="paramname"><em>distribution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Dist(0,&#160;1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a data container of type T with numberOfElements random numbers using the given random number generator and distribution </p>

</div>
</div>
<a id="a27779344a8c3a59f6cb41222bea0b8e2" name="a27779344a8c3a59f6cb41222bea0b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27779344a8c3a59f6cb41222bea0b8e2">&#9670;&#160;</a></span>randomVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::randomVolume </td>
          <td>(</td>
          <td class="paramtype">size3_t</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;</td>          <td class="paramname"><span class="paramname"><em>randomNumberGenerator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Rand()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;</td>          <td class="paramname"><span class="paramname"><em>distribution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Dist(0,&#160;1)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Volume.html">Volume</a> with white noise based using C++ a given random number generator and distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output <a class="el" href="classinviwo_1_1Volume.html">Volume</a> </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9375ead98669b8a4b58850f90bdd4248" name="a9375ead98669b8a4b58850f90bdd4248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9375ead98669b8a4b58850f90bdd4248">&#9670;&#160;</a></span>remap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IVW_MODULE_VOLUME_API inviwo::util::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>missingValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useMissingValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remap all voxels of <code>volume</code> by mapping values from <code>src</code> to <code>dst</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">volume</td><td>voxels of this scalar volume will be remapped </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">src</td><td>list of source indices </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dst</td><td>list of destination indices matching <code>src</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">missingValue</td><td>assigned if a value cannot be found in <code>src</code> and <code>useMissingValue</code> is set </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">useMissingValue</td><td>if true, all values not included in <code>src</code> are mapped to <code>missingValue</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1Exception.html">Exception</a></td><td>if <code>src</code> and <code>dst</code> have different sizes </td></tr>
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1Exception.html">Exception</a></td><td>if <code>src</code> contains duplicated values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>volume</code> must be a scalar volume </dd>
<dd>
<code>src</code> and <code>dst</code> must have the same length </dd>
<dd>
<code>src</code> must not contain duplicates </dd>
<dd>
<code>dst</code> may contain duplicates </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>volume</code> only contains voxels with values found in <code>dst</code> </dd></dl>

</div>
</div>
<a id="ac526048b608d9c8b31251eb6d4c633e4" name="ac526048b608d9c8b31251eb6d4c633e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac526048b608d9c8b31251eb6d4c633e4">&#9670;&#160;</a></span>replaceSelectionWithCompositeProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::replaceSelectionWithCompositeProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classinviwo_1_1CompositeProcessor.html" title="A processor containing a network of processors, i.e. it will act as a sub network within a processor ...">CompositeProcessor</a> out of the currently selected processors and replace them with the composite processors. The selected processors are moved from the current network into the sub network of the composite processor. For each port connection between a selected and unselected processor a composite sink or composite source processor is added to the sub network and connections are made from the selected processor to the sink/source and from the composite processor to the unselected processor. For each link between a selected and unselected processor, a super property is added to the composite processor and the link added to it. </p>

</div>
</div>
<a id="ac1a7add893c040adf20aa7bfb32b6aa7" name="ac1a7add893c040adf20aa7bfb32b6aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a7add893c040adf20aa7bfb32b6aa7">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to reverse the orders of the elements in a buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the buffer to reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ababf20580e98b848eaffd93c087fedb2" name="ababf20580e98b848eaffd93c087fedb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababf20580e98b848eaffd93c087fedb2">&#9670;&#160;</a></span>rtrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view inviwo::util::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>trims <code>str</code> from end by removing white spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>trimmed stringview without trailing white space </dd></dl>

</div>
</div>
<a id="a8a4d4e6fe612ca06641d9354787759eb" name="a8a4d4e6fe612ca06641d9354787759eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4d4e6fe612ca06641d9354787759eb">&#9670;&#160;</a></span>saveData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::saveData </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite</td>          <td class="paramname"><span class="paramname"><em>overwrite</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save <code>data</code> to <code>filePath</code> using the writer given by <code>extension</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Object to save to file </td></tr>
    <tr><td class="paramname">filePath</td><td>Complete path, name, and extension of the written file </td></tr>
    <tr><td class="paramname">extension</td><td>The extension used to identifier the <a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> in the factory </td></tr>
    <tr><td class="paramname">overwrite</td><td>Whether to overwrite any existing file or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1DataWriterException.html">DataWriterException</a></td><td>if no write could be found, or if overwrite was violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e915887dd7afac4db322379b958423" name="a28e915887dd7afac4db322379b958423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e915887dd7afac4db322379b958423">&#9670;&#160;</a></span>saveData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::filesystem::path &gt; inviwo::util::saveData </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>extensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite</td>          <td class="paramname"><span class="paramname"><em>overwrite</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save <code>data</code> to the filePath given by concatenating <code>path</code>, "/", <code>name</code>, ".", and extension where extensions is the first extension in <code>extensions</code> that we find a matching writer for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Object to save to file </td></tr>
    <tr><td class="paramname">path</td><td>Directory where the file will be written </td></tr>
    <tr><td class="paramname">name</td><td>Name of the file excluding extension </td></tr>
    <tr><td class="paramname">extensions</td><td>A list of extensions to use for finding a matching <a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> </td></tr>
    <tr><td class="paramname">overwrite</td><td>Whether to overwrite any existing file or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full path to the file written or std::nullopt if no writer was found </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1DataWriterException.html">DataWriterException</a></td><td>if overwrite was violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164993d46bdb58f8b16a943c65ae4b9c" name="a164993d46bdb58f8b16a943c65ae4b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164993d46bdb58f8b16a943c65ae4b9c">&#9670;&#160;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position of processor to pos </p>

</div>
</div>
<a id="af6fa91973f804cd02c1e28fb635202d1" name="af6fa91973f804cd02c1e28fb635202d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fa91973f804cd02c1e28fb635202d1">&#9670;&#160;</a></span>setSelected() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::setSelected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>processors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>selected</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the listed processors as selected or unSelected. </p>

</div>
</div>
<a id="a78172b271a10c03a2bb4a1a41bbde23e" name="a78172b271a10c03a2bb4a1a41bbde23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78172b271a10c03a2bb4a1a41bbde23e">&#9670;&#160;</a></span>setSelected() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::setSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>processor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>selected</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the selection state of processor </p>

</div>
</div>
<a id="a68531c2a1a0d7b50fbcd32b4ab6d03a2" name="a68531c2a1a0d7b50fbcd32b4ab6d03a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68531c2a1a0d7b50fbcd32b4ab6d03a2">&#9670;&#160;</a></span>splitByFirst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByFirst </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the first instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will be the same as the input str, and the second one will be empty </dd></dl>

</div>
</div>
<a id="a72e4709f37d1f58ead6f6bb699964102" name="a72e4709f37d1f58ead6f6bb699964102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e4709f37d1f58ead6f6bb699964102">&#9670;&#160;</a></span>splitByFirst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByFirst </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the first instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will be the same as the input str, and the second one will be empty </dd></dl>

</div>
</div>
<a id="a7062e820ba75f7fb44e8b149e52dd979" name="a7062e820ba75f7fb44e8b149e52dd979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7062e820ba75f7fb44e8b149e52dd979">&#9670;&#160;</a></span>splitByLast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByLast </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the last instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will empty, and the second one will be equal to the input str </dd></dl>

</div>
</div>
<a id="a22420f375af97c3654f65bd70c7df79c" name="a22420f375af97c3654f65bd70c7df79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22420f375af97c3654f65bd70c7df79c">&#9670;&#160;</a></span>splitByLast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByLast </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the last instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will empty, and the second one will be equal to the input str </dd></dl>

</div>
</div>
<a id="ab608fdeb665bcddf5e9821006487364b" name="ab608fdeb665bcddf5e9821006487364b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab608fdeb665bcddf5e9821006487364b">&#9670;&#160;</a></span>splitString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::string &gt; inviwo::util::splitString </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb. </p>
<dl class="section note"><dt>Note</dt><dd>Empty substrings are not skipped, ";;" will generate an element. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character use for splitting (default to space) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the substrings as std::string </dd></dl>

</div>
</div>
<a id="a018c12bda5703660547faff1bd31b8b9" name="a018c12bda5703660547faff1bd31b8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018c12bda5703660547faff1bd31b8b9">&#9670;&#160;</a></span>splitStringView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::string_view &gt; inviwo::util::splitStringView </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb. </p>
<dl class="section note"><dt>Note</dt><dd>Empty substrings are not skipped, ";;" will generate an element. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character use for splitting (default to space) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the substrings as std::string_view </dd></dl>

</div>
</div>
<a id="a7a96dd02792cfa20cef05e9d001b497b" name="a7a96dd02792cfa20cef05e9d001b497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a96dd02792cfa20cef05e9d001b497b">&#9670;&#160;</a></span>stripIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::stripIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Strip all invalid characters from the given <code>identifier</code>. If the resulting identifier is empty, a single underscore <code>_</code> is returned.</p>
<p>Valid identifiers follow the C++ and Python variable naming rules. That is</p><ul>
<li>case sensitive</li>
<li>start with letter or underscore</li>
<li>contain letters, numbers, and underscores</li>
<li>length &gt; 0</li>
</ul>
<p>Matching regex: [a-zA-Z_][a-zA-Z0-9_]*</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identifier</td><td>name to be stripped and validated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valid identifier</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a84a22c0c040b8e54cdb5bd3d4896a698">validateIdentifier</a> </dd></dl>

</div>
</div>
<a id="a9540b524a4db813530dfad0a0e19e883" name="a9540b524a4db813530dfad0a0e19e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9540b524a4db813530dfad0a0e19e883">&#9670;&#160;</a></span>stripModuleFileNameDecoration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::stripModuleFileNameDecoration </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes inviwo-module from module library file name. Turns "/path/to/inviwo-module-yourmodule.dll" into "yourmodule". Returns filename without extension if inviwo-module was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to module file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the module </dd></dl>

</div>
</div>
<a id="ac562f60680204dda73a7d29d9c9ddb24" name="ac562f60680204dda73a7d29d9c9ddb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac562f60680204dda73a7d29d9c9ddb24">&#9670;&#160;</a></span>toWstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::wstring inviwo::util::toWstring </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the given std::string to std::wstring. On Windows, MultiByteToWideChar is used for this conversion assuming utf8 encoding. Otherwise, std::mbsrtowcs is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>multibyte character string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input converted to std::wstring </dd></dl>

</div>
</div>
<a id="aeb3562b94700f15c08e99b826745258a" name="aeb3562b94700f15c08e99b826745258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3562b94700f15c08e99b826745258a">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view inviwo::util::trim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>trims <code>str</code> from beginning and end by removing white spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>trimmed stringview without leading/trailing white space </dd></dl>

</div>
</div>
<a id="a9bb4e1d0a952f2a8216385f68ac32178" name="a9bb4e1d0a952f2a8216385f68ac32178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb4e1d0a952f2a8216385f68ac32178">&#9670;&#160;</a></span>trySetProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; inviwo::util::trySetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *</td>          <td class="paramname"><span class="paramname"><em>proc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>recursive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to set a processor's property to a given value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of <code>proc</code>. </td></tr>
    <tr><td class="paramname">V</td><td>Type of <code>val</code>, deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> that has the target property. </td></tr>
    <tr><td class="paramname">identifier</td><td>Identifier of the property to be set. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">recursive</td><td>Enable/Disable recursive search for Processor::getPropertyByIdentifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to set property. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1Exception.html">Exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11440c1b6dc927f82d4ff5fd673d2ea9" name="a11440c1b6dc927f82d4ff5fd673d2ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11440c1b6dc927f82d4ff5fd673d2ea9">&#9670;&#160;</a></span>typedLayerSubSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; &gt; inviwo::util::typedLayerSubSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size2_t</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clampBorderOutsideImage</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extracts a subregion from a layer and converts it into a new layer </p>
<p>This function extracts a subregion given by <code>offset</code> and <code>extent</code> from the input layer. The values will be converted to type T using util::glm_convert_normalized. If border clamping is enabled, the output region will be clamped to lie completely within the source layer. Otherwise (default), the areas outside the source layer will be filled with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input layer </td></tr>
    <tr><td class="paramname">offset</td><td>subregion offset in input layer </td></tr>
    <tr><td class="paramname">extent</td><td>extent (width and height) of subregion </td></tr>
    <tr><td class="paramname">clampBorderOutsideImage</td><td>if true, the output region is clamped to the layer boundaries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;LayerRAMPrecision&lt;T&gt;&gt; </dd></dl>

</div>
</div>
<a id="a7e303f4a0c646b1328474d4df906e534" name="a7e303f4a0c646b1328474d4df906e534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e303f4a0c646b1328474d4df906e534">&#9670;&#160;</a></span>unindentMd2doc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1Document.html">Document</a> inviwo::util::unindentMd2doc </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>markdown</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a markdown string and convert to an inviwo document. Before the string is parsed as markdown, any leading indentation is removed from the string </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1Document.html" title="A class to represent a structured document, usually some html.">Document</a>, indent::unindent</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markdown</td><td>A string that will be interpreted as markdown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an inviwo <a class="el" href="classinviwo_1_1Document.html" title="A class to represent a structured document, usually some html.">Document</a> with an html representation of the parsed markdown </dd></dl>

</div>
</div>
<a id="a47927175e2344c3b515b14d86e5c508e" name="a47927175e2344c3b515b14d86e5c508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47927175e2344c3b515b14d86e5c508e">&#9670;&#160;</a></span>updateDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::updateDefaultState </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>property</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverwriteState</td>          <td class="paramname"><span class="paramname"><em>overwrite</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the default state of <code>property</code> to <code>state</code> and set the current state to <code>state</code> if <code>property</code> is in the default state or <code>overwrite</code> is OverwriteState::Yes </p>

</div>
</div>
<a id="aa4d38c8a311e159b1bdb778697984dbe" name="aa4d38c8a311e159b1bdb778697984dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d38c8a311e159b1bdb778697984dbe">&#9670;&#160;</a></span>updateOrCreateCameraEyeOffsetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> * inviwo::util::updateOrCreateCameraEyeOffsetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraProperty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; vec2()&gt;</td>          <td class="paramname"><span class="paramname"><em>get</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const vec2 &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either return an existing eye offset property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="aa25faca6335f85635cde61c0986c2343" name="aa25faca6335f85635cde61c0986c2343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25faca6335f85635cde61c0986c2343">&#9670;&#160;</a></span>updateOrCreateCameraFovProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::updateOrCreateCameraFovProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraProperty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float()&gt;</td>          <td class="paramname"><span class="paramname"><em>get</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either return an existing vertical fov property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PerspectiveCamera.html">PerspectiveCamera</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="ab27d645275cb437d22b94f20ddfe611a" name="ab27d645275cb437d22b94f20ddfe611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27d645275cb437d22b94f20ddfe611a">&#9670;&#160;</a></span>updateOrCreateCameraWidthProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::updateOrCreateCameraWidthProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraProperty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float()&gt;</td>          <td class="paramname"><span class="paramname"><em>get</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either return an existing width property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1OrthographicCamera.html" title="Camera with no perspective projection. Objects far away will appear as large as objects close.">OrthographicCamera</a> </dd></dl>

</div>
</div>
<a id="a84a22c0c040b8e54cdb5bd3d4896a698" name="a84a22c0c040b8e54cdb5bd3d4896a698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a22c0c040b8e54cdb5bd3d4896a698">&#9670;&#160;</a></span>validateIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::validateIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a></td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the given <code>identifier</code>. If <code>identifier</code> is invalid, throws an <a class="el" href="classinviwo_1_1Exception.html">Exception</a> with the given exception context <code>context</code> and identifier <code>type</code> for a detailed error message.</p>
<p>Valid identifiers follow the C++ and Python variable naming rules. That is</p><ul>
<li>case sensitive</li>
<li>start with letter or underscore</li>
<li>contain letters, numbers, and underscores</li>
<li>length &gt; 0</li>
</ul>
<p>Matching regex: [a-zA-Z_][a-zA-Z0-9_]*</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identifier</td><td>name to be validated </td></tr>
    <tr><td class="paramname">type</td><td>identifier type, only used in case of exception </td></tr>
    <tr><td class="paramname">context</td><td>used when throwing an exception </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1Exception.html">Exception</a></td><td>if identifier is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7a96dd02792cfa20cef05e9d001b497b">stripIdentifier</a> </dd></dl>

</div>
</div>
<a id="a21094bd4eae6e9a668b25cf52d70fa2c" name="a21094bd4eae6e9a668b25cf52d70fa2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21094bd4eae6e9a668b25cf52d70fa2c">&#9670;&#160;</a></span>volumeRAMDistanceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::volumeRAMDistanceTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>inVolume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *</td>          <td class="paramname"><span class="paramname"><em>outDistanceField</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; 3, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size3_t &amp;</td>          <td class="paramname"><span class="paramname"><em>upsample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTransform</td>          <td class="paramname"><span class="paramname"><em>valueTransform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProgressCallback</td>          <td class="paramname"><span class="paramname"><em>progress</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of Euclidean Distance <a class="el" href="classinviwo_1_1Transform.html">Transform</a> according to Saito's algorithm: T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance transformations of an n-dimensional digitized picture with applications. Pattern Recognition, 27(11). pp. 1551-1565, 1994. <a href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf</a></p>
<p>Calculates the distance in grid index space</p><ul>
<li>Predicate is a function of type (const T &amp;value) -&gt; bool to deside if a value in the input is a "feature".</li>
<li>ValueTransform is a function of type (const U&amp; squaredDist) -&gt; U that is appiled to all squared distance values at the end of the calculation.</li>
<li>ProcessCallback is a function of type (double progress) -&gt; void that is called with a value from 0 to 1 to indicate the progress of the calculation. </li>
</ul>

</div>
</div>
<a id="aa9402f8b933d12f71410d3cc938691e9" name="aa9402f8b933d12f71410d3cc938691e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9402f8b933d12f71410d3cc938691e9">&#9670;&#160;</a></span>voronoiSegmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::voronoiSegmentation </td>
          <td>(</td>
          <td class="paramtype">const size3_t</td>          <td class="paramname"><span class="paramname"><em>volumeDimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat4 &amp;</td>          <td class="paramname"><span class="paramname"><em>indexToDataMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat4 &amp;</td>          <td class="paramname"><span class="paramname"><em>dataToModelMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; uint32_t, vec3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>seedPointsWithIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Wrapping3D &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::vector&lt; float &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of Voronoi segmentation.</p>
<p>The function returns a volume with each voxel containing the index for the closest seed point (according to the power distance with or without weights). </p><pre class="fragment">* volumeDimensions is the dimensions for the volume.
* indexToDataMatrix is the matrix to transform the voxel positions from index to data
  space.
* dataToModelMatrix is the matrix to transform the voxel positions from data to model
  space.
* seedPointsWithIndices is a vector containing the seed points for the algorithm together
  with their index number on the form {index, position}. The positions are expected be in
  model space.
* wrapping the wrapping mode of the volume, @see Wrapping3D.
* weights is an optional vector containing the weights for each seed point. If set the
  weighted version of voronoi should be used.
</pre> 
</div>
</div>
<a id="a4fde21434664ba9e965614cfdf7890fc" name="a4fde21434664ba9e965614cfdf7890fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fde21434664ba9e965614cfdf7890fc">&#9670;&#160;</a></span>voxelVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IVW_CORE_API inviwo::util::voxelVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the volume of a single voxel, taking the basis and the dimensions into account The units of the result is in the unit as the basis vectors ^3 </p>
<dl class="section return"><dt>Returns</dt><dd>volume of one voxel </dd></dl>

</div>
</div>
<a id="a366b7461e603c7bb7bf6dd161a6ddd8e" name="a366b7461e603c7bb7bf6dd161a6ddd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366b7461e603c7bb7bf6dd161a6ddd8e">&#9670;&#160;</a></span>writeIvfVolumeSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::filesystem::path inviwo::util::writeIvfVolumeSequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataSequence.html">VolumeSequence</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>volumes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>relativePathToElements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite</td>          <td class="paramname"><span class="paramname"><em>overwrite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Overwrite::Yes</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a volume sequence to disk. </p>
<p>Writes a volume sequence to disk. Will create one main file ([name].ivfs) and a series of ivf volumes ([name]xx.ivf), one for each element in the sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumes</td><td>The volume sequence to export </td></tr>
    <tr><td class="paramname">name</td><td>the name of the dataset, will be used for to name the output files [name].ivfs and [name]xx.ivf </td></tr>
    <tr><td class="paramname">path</td><td>path to the folder to put the main file </td></tr>
    <tr><td class="paramname">relativePathToElements</td><td>relative path (from the path to the main file) to where the sequence elements will be written </td></tr>
    <tr><td class="paramname">overwrite</td><td>whether or not to overwrite existing files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>path to the created main-file </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1IvfSequenceVolumeWriter.html" title="Writter for *.ivfs sequnce files.">inviwo::IvfSequenceVolumeWriter</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1IvfSequenceVolumeReader.html" title="Reader for *.ivfs sequnce files.">inviwo::IvfSequenceVolumeReader</a> </dd></dl>

</div>
</div>
<a id="a2ec11e63479fff3c005d159414687d4e" name="a2ec11e63479fff3c005d159414687d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec11e63479fff3c005d159414687d4e">&#9670;&#160;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::zip </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structinviwo_1_1util_1_1detailzip_1_1zipper.html">detailzip::zipper</a>&lt;T...&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over containers in sync. Example use case 1: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; a(10);</div>
<div class="line">std::vector&lt;int&gt; b(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; i : <a class="code hl_function" href="#a2ec11e63479fff3c005d159414687d4e">util::zip</a>(a, b)) {</div>
<div class="line">     std::cout &lt;&lt; i.first() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.second() &lt;&lt; std::endl;</div>
<div class="line">     <span class="comment">// alternatively, get&lt;0&gt;(i) and get&lt;1&gt;(i) can be used</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_a2ec11e63479fff3c005d159414687d4e"><div class="ttname"><a href="#a2ec11e63479fff3c005d159414687d4e">inviwo::util::zip</a></div><div class="ttdeci">auto zip(T &amp;&amp;... args) -&gt; detailzip::zipper&lt; T... &gt;</div><div class="ttdef"><b>Definition</b> zip.h:430</div></div>
</div><!-- fragment --><p>with C++17 structured bindings: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [i, j] : <a class="code hl_function" href="#a787f4da3b201153820af19c27c2a7fac">util::enumerate</a>(vec)) {</div>
<div class="line">     std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_a787f4da3b201153820af19c27c2a7fac"><div class="ttname"><a href="#a787f4da3b201153820af19c27c2a7fac">inviwo::util::enumerate</a></div><div class="ttdeci">auto enumerate(T &amp;&amp;cont, Ts &amp;&amp;... conts)</div><div class="ttdef"><b>Definition</b> zip.h:571</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a75d951ef356d1f9ac02d3028302f9d1c" name="a75d951ef356d1f9ac02d3028302f9d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d951ef356d1f9ac02d3028302f9d1c">&#9670;&#160;</a></span>defaultIdGetter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::defaultIdGetter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](TxElement* node) -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> inviwo::detail::getAttribute(node, <span class="stringliteral">&quot;identifier&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c6f2c783a1cc78c23c5060fc9e8425e" name="a6c6f2c783a1cc78c23c5060fc9e8425e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6f2c783a1cc78c23c5060fc9e8425e">&#9670;&#160;</a></span>fmtHelp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::fmtHelp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= IVW_UNINDENT(R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">    To locate the error try breaking on fmt::format_error exceptions,</span></div>
<div class="line"><span class="stringliteral">    or put a breakpoint in fmt::detail::error_handler::on_error.</span></div>
<div class="line"><span class="stringliteral">    in lldb try &quot;breakpoint set -E c++ -O fmt::format_error&quot;</span></div>
<div class="line"><span class="stringliteral">    or &quot;breakpoint set -M fmt::v7::detail::error_handler::on_error&quot;.</span></div>
<div class="line"><span class="stringliteral">    )&quot;)</span></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinviwo.html">inviwo</a></li><li class="navelem"><a class="el" href="namespaceinviwo_1_1util.html">util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
