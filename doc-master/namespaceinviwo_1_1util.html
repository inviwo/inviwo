<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inviwo: inviwo::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="inviwo_dark.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Inviwo
   &#160;<span id="projectnumber">0.9.9.1</span>
   </div>
   <div id="projectbrief">Inviwo documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceinviwo_1_1util.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">inviwo::util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1BufferDispatcher.html">BufferDispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information on build time and date as well as git hashes.  <a href="structinviwo_1_1util_1_1BuildInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1Camera2D.html">Camera2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1cameratype.html">cameratype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1cameratype_3_012_01_4.html">cameratype&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1cameratype_3_013_01_4.html">cameratype&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1cloneable__ptr.html">cloneable_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1extent_3_01const_01T_00_01N_01_4.html">extent&lt; const T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::mat&lt; C, R, T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::mat&lt; C, R, T, Q &gt;, 1 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::tquat&lt; T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::vec&lt; L, T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1flat__extent.html">flat_extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type.html">for_each_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type_3_01std_1_1tuple_3_01T_01_4_01_4.html">for_each_type&lt; std::tuple&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type_3_01std_1_1tuple_3_01T_00_01Types_8_8_8_01_4_01_4.html">for_each_type&lt; std::tuple&lt; T, Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type__pair.html">for_each_type_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type__pair_3_01std_1_1tuple_3_01ATypes_8_8_8_01_4_00_01std_1_980543efefbc8ab89773d2539d3c1f94.html">for_each_type_pair&lt; std::tuple&lt; ATypes... &gt;, std::tuple&lt; BTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype.html">glmtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype_3_01T_00_011_00_011_00_01P_01_4.html">glmtype&lt; T, 1, 1, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype_3_01T_00_01L_00_011_00_01P_01_4.html">glmtype&lt; T, L, 1, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1GridPos.html">GridPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasClassIdentifier.html">HasClassIdentifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasClassIdentifierLower.html">HasClassIdentifierLower</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasClassIdentifierUpper.html">HasClassIdentifierUpper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasColorCode.html">HasColorCode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasColorCodeLower.html">HasColorCodeLower</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasColorCodeUpper.html">HasColorCodeUpper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1HasDataFormat.html">HasDataFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasDataInfo.html">HasDataInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasDataName.html">HasDataName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1HasInfo.html">HasInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IdentifiedDeserializer.html">IdentifiedDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IndexedDeserializer.html">IndexedDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper_3_012_00_01IndexType_01_4.html">IndexMapper&lt; 2, IndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper_3_013_00_01IndexType_01_4.html">IndexMapper&lt; 3, IndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__constructible.html">is_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1is__container.html">is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__dereferenceable.html">is_dereferenceable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__dereferenceable_3_01T_00_01void__t_3_01decltype_07_5std_1_1declval_3_01T_01_4_07_08_08_4_01_4.html">is_dereferenceable&lt; T, void_t&lt; decltype(*std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__floating__point_3_01half__float_1_1half_01_4.html">is_floating_point&lt; half_float::half &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1is__stream__insertable.html">is_stream_insertable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__string.html">is_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1KeepTrueWhileInScope.html">KeepTrueWhileInScope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MapDeserializer.html">MapDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MemoryFileHandle.html">MemoryFileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII class for providing a FILE stream handle to a buffer in memory. This class will open a file handle to /dev/null and use a dedicated buffer for buffering. As long as less bytes than getBufferSize() bytes are written/read, its status is well defined. However, after writing more than buffer size bytes, the buffer contents will be flushed, i.e. are no longer accessible.  <a href="classinviwo_1_1util_1_1MemoryFileHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1NotificationBlocker.html">NotificationBlocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1OnScopeExit.html">OnScopeExit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1ostream__joiner.html">ostream_joiner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1PropertyDistanceSorter.html">PropertyDistanceSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank.html">rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank_3_01const_01T_01_4.html">rank&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::mat&lt; C, R, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::tquat&lt; T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::vec&lt; L, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank_3_01half__float_1_1half_01_4.html">rank&lt; half_float::half &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1same__extent.html">same_extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::mat&lt; C, R, T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::tquat&lt; T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::vec&lt; L, T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TempFileHandle.html">TempFileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII interface for providing a file handle and file name to a temporary file.  <a href="classinviwo_1_1util_1_1TempFileHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TextureAtlas.html">TextureAtlas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classinviwo_1_1Texture.html">Texture</a> atlas for a number of strings rendered with the <a class="el" href="classinviwo_1_1TextRenderer.html" title="Render text using the FreeType font library. ">TextRenderer</a>.  <a href="classinviwo_1_1util_1_1TextureAtlas.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1TFPropertyConcept.html">TFPropertyConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">property interface used by the TF dialog to support different TF properties  <a href="structinviwo_1_1util_1_1TFPropertyConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TFPropertyModel.html">TFPropertyModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1value__type.html">value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::mat&lt; C, R, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::tquat&lt; T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::vec&lt; L, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ade565d10867e0dc26e164bd60ff9ef6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade565d10867e0dc26e164bd60ff9ef6c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ade565d10867e0dc26e164bd60ff9ef6c">PrecsionType</a> = typename std::remove_pointer&lt; typename std::remove_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="separator:ade565d10867e0dc26e164bd60ff9ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdae1f9f37726cbb9ea49087f03ca79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accdae1f9f37726cbb9ea49087f03ca79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#accdae1f9f37726cbb9ea49087f03ca79">PrecsionValueType</a> = typename <a class="el" href="namespaceinviwo_1_1util.html#ade565d10867e0dc26e164bd60ff9ef6c">PrecsionType</a>&lt; T &gt;::type</td></tr>
<tr class="separator:accdae1f9f37726cbb9ea49087f03ca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f92cc22201b6bdb0121dfae46e921fc"><td class="memItemLeft" align="right" valign="top"><a id="a7f92cc22201b6bdb0121dfae46e921fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexMapper2D</b> = <a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a>&lt; 2, size_t &gt;</td></tr>
<tr class="separator:a7f92cc22201b6bdb0121dfae46e921fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788768f656d806bf88fefaef7dc4e4db"><td class="memItemLeft" align="right" valign="top"><a id="a788768f656d806bf88fefaef7dc4e4db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexMapper3D</b> = <a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a>&lt; 3, size_t &gt;</td></tr>
<tr class="separator:a788768f656d806bf88fefaef7dc4e4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33241d8467f892c3ffeaed160ffbc426"><td class="memTemplParams" colspan="2"><a id="a33241d8467f892c3ffeaed160ffbc426"></a>
template&lt;class... &gt; </td></tr>
<tr class="memitem:a33241d8467f892c3ffeaed160ffbc426"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>void_t</b> = void</td></tr>
<tr class="separator:a33241d8467f892c3ffeaed160ffbc426"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af7a21db522a804cf93c00863b5dfd76f"><td class="memItemLeft" align="right" valign="top"><a id="af7a21db522a804cf93c00863b5dfd76f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TraversalDirection</b> { <b>Up</b>, 
<b>Down</b>
 }</td></tr>
<tr class="separator:af7a21db522a804cf93c00863b5dfd76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aa2caf857929fd4da8450f78b1c4d9"><td class="memItemLeft" align="right" valign="top"><a id="a58aa2caf857929fd4da8450f78b1c4d9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>VisitPattern</b> { <b>Pre</b>, 
<b>Post</b>
 }</td></tr>
<tr class="separator:a58aa2caf857929fd4da8450f78b1c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b7c5a6156793bd1e87dec727b16af2"><td class="memItemLeft" align="right" valign="top"><a id="a50b7c5a6156793bd1e87dec727b16af2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>VolumeLaplacianPostProcessing</b> { <b>None</b>, 
<b>Normalized</b>, 
<b>SignNormalized</b>, 
<b>Scaled</b>
 }</td></tr>
<tr class="separator:a50b7c5a6156793bd1e87dec727b16af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a83c9f2374441d3698563e90c35a115"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a0a83c9f2374441d3698563e90c35a115">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *)</td></tr>
<tr class="separator:a0a83c9f2374441d3698563e90c35a115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf13843c2e4fd0df7921e8c9365b044f"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#abf13843c2e4fd0df7921e8c9365b044f">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *)</td></tr>
<tr class="separator:abf13843c2e4fd0df7921e8c9365b044f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d5b9648bb957bd76d93b52beddfc4b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad9d5b9648bb957bd76d93b52beddfc4b">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> *)</td></tr>
<tr class="separator:ad9d5b9648bb957bd76d93b52beddfc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d55ce422a8f0e6b2d423426246a9871"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a0d55ce422a8f0e6b2d423426246a9871">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *)</td></tr>
<tr class="separator:a0d55ce422a8f0e6b2d423426246a9871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a8f1d379addc2b0acf5b22775f20ea"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af1a8f1d379addc2b0acf5b22775f20ea">getInviwoApplication</a> ()</td></tr>
<tr class="separator:af1a8f1d379addc2b0acf5b22775f20ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0d79d00de28cb2bb960b35cf5b8b8e"><td class="memItemLeft" align="right" valign="top"><a id="aea0d79d00de28cb2bb960b35cf5b8b8e"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Buffer.html">IndexBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeIndexBuffer</b> (std::vector&lt; std::uint32_t &gt; &amp;&amp;data)</td></tr>
<tr class="separator:aea0d79d00de28cb2bb960b35cf5b8b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d25ccd9b1e68964e20e1903a220981"><td class="memTemplParams" colspan="2"><a id="ab8d25ccd9b1e68964e20e1903a220981"></a>
template&lt;typename T  = vec3, BufferUsage U = BufferUsage::Static, BufferTarget Target = BufferTarget::Data&gt; </td></tr>
<tr class="memitem:ab8d25ccd9b1e68964e20e1903a220981"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a>&lt; T, Target &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeBuffer</b> (std::vector&lt; T &gt; &amp;&amp;data)</td></tr>
<tr class="separator:ab8d25ccd9b1e68964e20e1903a220981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aabb926f743b0ff0a56ea01db4e10a0"><td class="memItemLeft" align="right" valign="top"><a id="a0aabb926f743b0ff0a56ea01db4e10a0"></a>
IVW_CORE_API uvec3&#160;</td><td class="memItemRight" valign="bottom"><b>getDataFormatColor</b> (NumericType t, size_t comp, size_t size)</td></tr>
<tr class="separator:a0aabb926f743b0ff0a56ea01db4e10a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b84870bcc5a9146482efc443d4d58e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a91b84870bcc5a9146482efc443d4d58e">appendIfNotEmpty</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:a91b84870bcc5a9146482efc443d4d58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e71f8023678768676cf999e5411d08"><td class="memTemplParams" colspan="2"><a id="af7e71f8023678768676cf999e5411d08"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7e71f8023678768676cf999e5411d08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1HistogramContainer.html">HistogramContainer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculateVolumeHistogram</b> (const T *data, size3_t dimensions, dvec2 dataRange, const bool &amp;stop=false, size_t bins=2048, size3_t sampleRate=size3_t(1))</td></tr>
<tr class="separator:af7e71f8023678768676cf999e5411d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14211380d9e4e93be99eae72e605f25"><td class="memItemLeft" align="right" valign="top"><a id="ab14211380d9e4e93be99eae72e605f25"></a>
void IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>readBytesIntoBuffer</b> (const std::string &amp;file, size_t offset, size_t bytes, bool littleEndian, size_t elementSize, void *dest)</td></tr>
<tr class="separator:ab14211380d9e4e93be99eae72e605f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b931df598ee94a12f1575888ead4d5"><td class="memItemLeft" align="right" valign="top"><a id="a95b931df598ee94a12f1575888ead4d5"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveLayer</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer, const std::string &amp;path, const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;extension=<a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a>())</td></tr>
<tr class="separator:a95b931df598ee94a12f1575888ead4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b01de4cc58c9f34bae68422ba45eca"><td class="memItemLeft" align="right" valign="top"><a id="aa2b01de4cc58c9f34bae68422ba45eca"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveLayer</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:aa2b01de4cc58c9f34bae68422ba45eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04512dd80a7008f5bd05b005f31e40e4"><td class="memItemLeft" align="right" valign="top"><a id="a04512dd80a7008f5bd05b005f31e40e4"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>renamePort</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Port.html">Port</a> *, std::string &gt;&gt; rules)</td></tr>
<tr class="separator:a04512dd80a7008f5bd05b005f31e40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882c0a447a1669378a217aea67372adb"><td class="memItemLeft" align="right" valign="top"><a id="a882c0a447a1669378a217aea67372adb"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>renameProperty</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Property.html">Property</a> *, std::string &gt;&gt; rules, std::string path=&quot;Properties&quot;)</td></tr>
<tr class="separator:a882c0a447a1669378a217aea67372adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab605c3c62533a6aea90195e58ffd3548"><td class="memItemLeft" align="right" valign="top"><a id="ab605c3c62533a6aea90195e58ffd3548"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>changePropertyType</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Property.html">Property</a> *, std::string &gt;&gt; rules)</td></tr>
<tr class="separator:ab605c3c62533a6aea90195e58ffd3548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d424a4f154377ef6a230572dcada37"><td class="memItemLeft" align="right" valign="top"><a id="a07d424a4f154377ef6a230572dcada37"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectPredecessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a07d424a4f154377ef6a230572dcada37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d77e2ddd6f6936a236a223c1fc5901"><td class="memItemLeft" align="right" valign="top"><a id="ac5d77e2ddd6f6936a236a223c1fc5901"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectSuccessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ac5d77e2ddd6f6936a236a223c1fc5901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248441bd2e8e3874c5f9c22e2e73d2e"><td class="memItemLeft" align="right" valign="top"><a id="a2248441bd2e8e3874c5f9c22e2e73d2e"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPredecessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a2248441bd2e8e3874c5f9c22e2e73d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a5f3e828663d077a354e82ef6bd7d8"><td class="memItemLeft" align="right" valign="top"><a id="ac7a5f3e828663d077a354e82ef6bd7d8"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSuccessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ac7a5f3e828663d077a354e82ef6bd7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5cd6486bf2c1d665739f6e7ac937cc"><td class="memTemplParams" colspan="2"><a id="a1f5cd6486bf2c1d665739f6e7ac937cc"></a>
template&lt;TraversalDirection D, VisitPattern V, typename Func &gt; </td></tr>
<tr class="memitem:a1f5cd6486bf2c1d665739f6e7ac937cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>traverseNetwork</b> (std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;state, <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, Func f)</td></tr>
<tr class="separator:a1f5cd6486bf2c1d665739f6e7ac937cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e80f39b6cc5a4f48e8e45415101bbe"><td class="memItemLeft" align="right" valign="top"><a id="af2e80f39b6cc5a4f48e8e45415101bbe"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>topologicalSort</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:af2e80f39b6cc5a4f48e8e45415101bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb2d348f3df4ca917597752612991bb"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aaeb2d348f3df4ca917597752612991bb">getPositions</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;processors)</td></tr>
<tr class="separator:aaeb2d348f3df4ca917597752612991bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9754915d79c8228216a3969b3ec336c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad9754915d79c8228216a3969b3ec336c">getPositions</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:ad9754915d79c8228216a3969b3ec336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a6c260b4f3557da91b05b08bab802a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad8a6c260b4f3557da91b05b08bab802a">getCenterPosition</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;processors)</td></tr>
<tr class="separator:ad8a6c260b4f3557da91b05b08bab802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4baa486b72f1f0869d5b078273b7479"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa4baa486b72f1f0869d5b078273b7479">getCenterPosition</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:aa4baa486b72f1f0869d5b078273b7479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea87cbfeb4336cada908d582d016461a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aea87cbfeb4336cada908d582d016461a">getBoundingBox</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;processors)</td></tr>
<tr class="separator:aea87cbfeb4336cada908d582d016461a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17166a30c043e7eb8d64099a5f6fc97"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab17166a30c043e7eb8d64099a5f6fc97">getBoundingBox</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:ab17166a30c043e7eb8d64099a5f6fc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba424f4f92432dc34daf48c2fd5e2b7f"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aba424f4f92432dc34daf48c2fd5e2b7f">offsetPosition</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;processors, ivec2 offset)</td></tr>
<tr class="separator:aba424f4f92432dc34daf48c2fd5e2b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a51062f4f2e754a047e5bedd9da776b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a3a51062f4f2e754a047e5bedd9da776b">setSelected</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;processors, bool selected)</td></tr>
<tr class="separator:a3a51062f4f2e754a047e5bedd9da776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23519f6b2fbadb158dffb636b5052e90"><td class="memItemLeft" align="right" valign="top"><a id="a23519f6b2fbadb158dffb636b5052e90"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>autoLinkProcessor</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a23519f6b2fbadb158dffb636b5052e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e623e1930522a876be35635cf8b63"><td class="memItemLeft" align="right" valign="top"><a id="a7e4e623e1930522a876be35635cf8b63"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>serializeSelected</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::ostream &amp;os, const std::string &amp;refPath)</td></tr>
<tr class="separator:a7e4e623e1930522a876be35635cf8b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b423d258ad3247fa02ff64ba99398e"><td class="memItemLeft" align="right" valign="top"><a id="a25b423d258ad3247fa02ff64ba99398e"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>appendDeserialized</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::istream &amp;is, const std::string &amp;refPath, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a25b423d258ad3247fa02ff64ba99398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094d438f79606242702c3f843cad6773"><td class="memItemLeft" align="right" valign="top"><a id="a094d438f79606242702c3f843cad6773"></a>
void IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>updateWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a094d438f79606242702c3f843cad6773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2be9fca7a318feb7d7a1d14b79eb976"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa2be9fca7a318feb7d7a1d14b79eb976">replaceSelectionWithCompositeProcessor</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;network)</td></tr>
<tr class="separator:aa2be9fca7a318feb7d7a1d14b79eb976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731971fbc0202eccf36e24fc48970761"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a731971fbc0202eccf36e24fc48970761">expandCompositeProcessorIntoNetwork</a> (<a class="el" href="classinviwo_1_1CompositeProcessor.html">CompositeProcessor</a> &amp;composite)</td></tr>
<tr class="separator:a731971fbc0202eccf36e24fc48970761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c43431c8e929139ef0d5a84dee78fa6"><td class="memItemLeft" align="right" valign="top"><a id="a4c43431c8e929139ef0d5a84dee78fa6"></a>
<a class="el" href="classinviwo_1_1Tags.html">Tags</a> IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getPlatformTags</b> (const <a class="el" href="classinviwo_1_1Tags.html">Tags</a> &amp;t)</td></tr>
<tr class="separator:a4c43431c8e929139ef0d5a84dee78fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99f2c2c49e4d7f23742ee2e0866fa3d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API const <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab99f2c2c49e4d7f23742ee2e0866fa3d">getMetaData</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ab99f2c2c49e4d7f23742ee2e0866fa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b23c11bea75c804e260490afeec4eef"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8b23c11bea75c804e260490afeec4eef">getMetaData</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a8b23c11bea75c804e260490afeec4eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bff6779ff52348702ca64e4b2c8cd73"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5bff6779ff52348702ca64e4b2c8cd73">getPosition</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a5bff6779ff52348702ca64e4b2c8cd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca943f4416953f426313a35674e4d3e1"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aca943f4416953f426313a35674e4d3e1">setPosition</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, ivec2 pos)</td></tr>
<tr class="separator:aca943f4416953f426313a35674e4d3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b87c0053e5b3359ec3d4622c804797"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab0b87c0053e5b3359ec3d4622c804797">isSelected</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ab0b87c0053e5b3359ec3d4622c804797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7230aed1f8b9a70db2bd5f6317082c8e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a7230aed1f8b9a70db2bd5f6317082c8e">setSelected</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, bool selected)</td></tr>
<tr class="separator:a7230aed1f8b9a70db2bd5f6317082c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8de07bc8d6ff42e86554ee40b76b82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a6a8de07bc8d6ff42e86554ee40b76b82"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6a8de07bc8d6ff42e86554ee40b76b82">makeProcessor</a> (ivec2 pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6a8de07bc8d6ff42e86554ee40b76b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7841f5d785d22816d52f6bbd8fac30"><td class="memItemLeft" align="right" valign="top"><a id="aba7841f5d785d22816d52f6bbd8fac30"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>debugBreak</b> ()</td></tr>
<tr class="separator:aba7841f5d785d22816d52f6bbd8fac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cee67b6facc99fd2e7a3ab655d65641"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a9cee67b6facc99fd2e7a3ab655d65641">reverse</a> (<a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> &amp;b)</td></tr>
<tr class="separator:a9cee67b6facc99fd2e7a3ab655d65641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a367e3e6c6c448efab8e00c52de4097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a> IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a9a367e3e6c6c448efab8e00c52de4097">getBuildInfo</a> ()</td></tr>
<tr class="memdesc:a9a367e3e6c6c448efab8e00c52de4097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses build information via an INI file or compile-time definitions.  <a href="#a9a367e3e6c6c448efab8e00c52de4097">More...</a><br /></td></tr>
<tr class="separator:a9a367e3e6c6c448efab8e00c52de4097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0496e7c1988418a45874928e7e98d1"><td class="memTemplParams" colspan="2"><a id="a0b0496e7c1988418a45874928e7e98d1"></a>
template&lt;size_t len&gt; </td></tr>
<tr class="memitem:a0b0496e7c1988418a45874928e7e98d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_hash</b> (const char(&amp;str)[len])</td></tr>
<tr class="separator:a0b0496e7c1988418a45874928e7e98d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e51751558c8e07c5b63cddf28b19f8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename T  = typename Iterable::value_type, typename Callback &gt; </td></tr>
<tr class="memitem:ab4e51751558c8e07c5b63cddf28b19f8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab4e51751558c8e07c5b63cddf28b19f8">forEachParallelAsync</a> (const Iterable &amp;iterable, Callback callback, size_t jobs=0)</td></tr>
<tr class="separator:ab4e51751558c8e07c5b63cddf28b19f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582b2f1b71b3ac6d3e606bc361ab07e"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename T  = typename Iterable::value_type, typename Callback &gt; </td></tr>
<tr class="memitem:a6582b2f1b71b3ac6d3e606bc361ab07e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6582b2f1b71b3ac6d3e606bc361ab07e">forEachParallel</a> (const Iterable &amp;iterable, Callback callback, size_t jobs=0)</td></tr>
<tr class="separator:a6582b2f1b71b3ac6d3e606bc361ab07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b94d32a4f96dd412446b35fa058db6"><td class="memTemplParams" colspan="2"><a id="a32b94d32a4f96dd412446b35fa058db6"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:a32b94d32a4f96dd412446b35fa058db6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_argument</b> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a32b94d32a4f96dd412446b35fa058db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f343736e8083a8b38183038511368"><td class="memTemplParams" colspan="2"><a id="a259f343736e8083a8b38183038511368"></a>
template&lt;typename F , typename TupleType &gt; </td></tr>
<tr class="memitem:a259f343736e8083a8b38183038511368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_in_tuple</b> (F &amp;&amp;f, TupleType &amp;&amp;t)</td></tr>
<tr class="separator:a259f343736e8083a8b38183038511368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memTemplParams" colspan="2"><a id="a9bc3c6a37ecf5dc4e89d4a99bd930f53"></a>
template&lt;typename F , typename TupleType1 , typename TupleType2 &gt; </td></tr>
<tr class="memitem:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_in_tuple</b> (F &amp;&amp;f, TupleType1 &amp;&amp;t1, TupleType2 &amp;&amp;t2)</td></tr>
<tr class="separator:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659661f4029ab40f486d9bb004e37150"><td class="memItemLeft" align="right" valign="top"><a id="a659661f4029ab40f486d9bb004e37150"></a>
IVW_CORE_API glm::u64&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_kilobytes</b> (glm::u64 bytes)</td></tr>
<tr class="separator:a659661f4029ab40f486d9bb004e37150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d380ae61a423640a6fce2fe49705d4"><td class="memItemLeft" align="right" valign="top"><a id="a75d380ae61a423640a6fce2fe49705d4"></a>
IVW_CORE_API glm::u64&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_megabytes</b> (glm::u64 bytes)</td></tr>
<tr class="separator:a75d380ae61a423640a6fce2fe49705d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669b7c4270b7c98e9eb69a49334a6aa4"><td class="memItemLeft" align="right" valign="top"><a id="a669b7c4270b7c98e9eb69a49334a6aa4"></a>
IVW_CORE_API glm::u64&#160;</td><td class="memItemRight" valign="bottom"><b>kilobytes_to_bytes</b> (glm::u64 bytes)</td></tr>
<tr class="separator:a669b7c4270b7c98e9eb69a49334a6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83d8b2d54c4950e1bcac978fdc50fe"><td class="memItemLeft" align="right" valign="top"><a id="a6e83d8b2d54c4950e1bcac978fdc50fe"></a>
IVW_CORE_API glm::u64&#160;</td><td class="memItemRight" valign="bottom"><b>megabytes_to_bytes</b> (glm::u64 bytes)</td></tr>
<tr class="separator:a6e83d8b2d54c4950e1bcac978fdc50fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd528c978955d82e181aa4038c33b62"><td class="memItemLeft" align="right" valign="top"><a id="a6fd528c978955d82e181aa4038c33b62"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatBytesToString</b> (glm::u64 bytes)</td></tr>
<tr class="separator:a6fd528c978955d82e181aa4038c33b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e029c8ccf362d845dfa9362adada1"><td class="memTemplParams" colspan="2"><a id="acf3e029c8ccf362d845dfa9362adada1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf3e029c8ccf362d845dfa9362adada1"><td class="memTemplItemLeft" align="right" valign="top">constexpr NumericType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getNumericType</b> ()</td></tr>
<tr class="separator:acf3e029c8ccf362d845dfa9362adada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5780feabad27a979c9c92bc67cf6ada2"><td class="memTemplParams" colspan="2"><a id="a5780feabad27a979c9c92bc67cf6ada2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5780feabad27a979c9c92bc67cf6ada2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const T &amp;v)</td></tr>
<tr class="separator:a5780feabad27a979c9c92bc67cf6ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e13503fd41b6870b153773372ce515"><td class="memTemplParams" colspan="2"><a id="a12e13503fd41b6870b153773372ce515"></a>
template&lt;glm::length_t L, typename T , glm::qualifier Q&gt; </td></tr>
<tr class="memitem:a12e13503fd41b6870b153773372ce515"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; L, bool, Q &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const glm::vec&lt; L, T, Q &gt; &amp;x)</td></tr>
<tr class="separator:a12e13503fd41b6870b153773372ce515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616f1e85d565c9149aba9f87a798f09"><td class="memTemplParams" colspan="2"><a id="af616f1e85d565c9149aba9f87a798f09"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af616f1e85d565c9149aba9f87a798f09"><td class="memTemplItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const half_float::half &amp;v)</td></tr>
<tr class="separator:af616f1e85d565c9149aba9f87a798f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memTemplParams" colspan="2"><a id="a47fc3d300d9eae79274e06a2ea8a5325"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const T &amp;v)</td></tr>
<tr class="separator:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae76c6c0fe12f58cf0aee17a2944c5f6"><td class="memTemplParams" colspan="2"><a id="aae76c6c0fe12f58cf0aee17a2944c5f6"></a>
template&lt;glm::length_t L, typename T , glm::qualifier Q&gt; </td></tr>
<tr class="memitem:aae76c6c0fe12f58cf0aee17a2944c5f6"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; L, bool, Q &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const glm::vec&lt; L, T, Q &gt; &amp;x)</td></tr>
<tr class="separator:aae76c6c0fe12f58cf0aee17a2944c5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d1d573292f23607b2c2415d52c916"><td class="memTemplParams" colspan="2"><a id="a7e9d1d573292f23607b2c2415d52c916"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e9d1d573292f23607b2c2415d52c916"><td class="memTemplItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const half_float::half &amp;v)</td></tr>
<tr class="separator:a7e9d1d573292f23607b2c2415d52c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fab874f7e075134d5dba1055797290"><td class="memTemplParams" colspan="2"><a id="a95fab874f7e075134d5dba1055797290"></a>
template&lt;class U , class T , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a95fab874f7e075134d5dba1055797290"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (T x, U init, BinaryOperation op)</td></tr>
<tr class="separator:a95fab874f7e075134d5dba1055797290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511bfeb832229de93d6064476ec3737f"><td class="memTemplParams" colspan="2"><a id="a511bfeb832229de93d6064476ec3737f"></a>
template&lt;glm::length_t L, class U , glm::qualifier Q, template&lt; glm::length_t, typename, glm::qualifier &gt; class vecType, class BinaryOperation &gt; </td></tr>
<tr class="memitem:a511bfeb832229de93d6064476ec3737f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; vecType&lt; L, U, Q &gt; &gt;::value==1, U &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (vecType&lt; L, U, Q &gt; const &amp;x, U init, BinaryOperation op)</td></tr>
<tr class="separator:a511bfeb832229de93d6064476ec3737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5e05aa127a992666b5c1a7898ef55b"><td class="memTemplParams" colspan="2"><a id="acc5e05aa127a992666b5c1a7898ef55b"></a>
template&lt;glm::length_t C, glm::length_t R, class U , glm::qualifier Q, template&lt; glm::length_t, glm::length_t, typename, glm::qualifier &gt; class vecType, class BinaryOperation &gt; </td></tr>
<tr class="memitem:acc5e05aa127a992666b5c1a7898ef55b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; vecType&lt; C, R, U, Q &gt; &gt;::value==2, U &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (vecType&lt; C, R, U, Q &gt; const &amp;x, U init, BinaryOperation op)</td></tr>
<tr class="separator:acc5e05aa127a992666b5c1a7898ef55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eff460b2d764066b797ef27c597841b"><td class="memTemplParams" colspan="2"><a id="a3eff460b2d764066b797ef27c597841b"></a>
template&lt;typename To  = double, typename From , typename std::enable_if&lt; util::rank&lt; From &gt;::value==0 &amp;&amp;util::rank&lt; To &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3eff460b2d764066b797ef27c597841b"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm_convert</b> (From x)</td></tr>
<tr class="separator:a3eff460b2d764066b797ef27c597841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02025471c09a9e5870cd267aff10a109"><td class="memTemplParams" colspan="2"><a id="a02025471c09a9e5870cd267aff10a109"></a>
template&lt;typename To  = double, typename From , typename std::enable_if&lt; std::is_same&lt; To, From &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a02025471c09a9e5870cd267aff10a109"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm_convert_normalized</b> (From x)</td></tr>
<tr class="separator:a02025471c09a9e5870cd267aff10a109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141644d95fac699b26e542dd8e9a06a"><td class="memTemplParams" colspan="2"><a id="ad141644d95fac699b26e542dd8e9a06a"></a>
template&lt;typename T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad141644d95fac699b26e542dd8e9a06a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (T &amp;elem, size_t) -&gt; T &amp;</td></tr>
<tr class="separator:ad141644d95fac699b26e542dd8e9a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memTemplParams" colspan="2"><a id="a0e69e5cb6a27439895b97689f5f3f2ed"></a>
template&lt;typename T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (const T &amp;elem, size_t i) -&gt; const typename T::value_type &amp;</td></tr>
<tr class="separator:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535872b8fa9d1afa94e41ee71d2dd9f4"><td class="memTemplParams" colspan="2"><a id="a535872b8fa9d1afa94e41ee71d2dd9f4"></a>
template&lt;typename T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a535872b8fa9d1afa94e41ee71d2dd9f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (T &amp;elem, size_t i, size_t j) -&gt; T &amp;</td></tr>
<tr class="separator:a535872b8fa9d1afa94e41ee71d2dd9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3d34285fc06bf52759afd757fb61f"><td class="memTemplParams" colspan="2"><a id="a05c3d34285fc06bf52759afd757fb61f"></a>
template&lt;typename T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a05c3d34285fc06bf52759afd757fb61f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (const T &amp;elem, size_t i, size_t j) -&gt; const typename T::value_type &amp;</td></tr>
<tr class="separator:a05c3d34285fc06bf52759afd757fb61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memTemplParams" colspan="2"><a id="a325d0254070f7fb9aec6ff895d4a0bdc"></a>
template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memTemplItemLeft" align="right" valign="top">Type1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invertY</b> (Type1 vec, Type2 dim)</td></tr>
<tr class="separator:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca39adef75ff36c5b3846a86e67269f"><td class="memTemplParams" colspan="2"><a id="afca39adef75ff36c5b3846a86e67269f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca39adef75ff36c5b3846a86e67269f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all</b> (const T &amp;t)</td></tr>
<tr class="separator:afca39adef75ff36c5b3846a86e67269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memTemplParams" colspan="2"><a id="a45a5e593ad97ae54ea8fe10fb4e88e2f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all</b> (const bool &amp;t)</td></tr>
<tr class="separator:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memTemplParams" colspan="2"><a id="a1fe8554ac4434ebd0a96ebc1427b44b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any</b> (const T &amp;t)</td></tr>
<tr class="separator:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memTemplParams" colspan="2"><a id="a7ee2ac139048aa0bc7f4d823ba6c26a4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any</b> (const bool &amp;t)</td></tr>
<tr class="separator:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8843b349d3a16c4bc14bb9f2604229"><td class="memTemplParams" colspan="2"><a id="adf8843b349d3a16c4bc14bb9f2604229"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:adf8843b349d3a16c4bc14bb9f2604229"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixel</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &amp;layer, C callback)</td></tr>
<tr class="separator:adf8843b349d3a16c4bc14bb9f2604229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memTemplParams" colspan="2"><a id="afed8f6b8d9311afc3ee6ee2f112b3e5b"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixelParallel</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &amp;layer, C callback, size_t jobs=0)</td></tr>
<tr class="separator:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a77aff89bb77c768157f02f845b39d"><td class="memItemLeft" align="right" valign="top"><a id="a32a77aff89bb77c768157f02f845b39d"></a>
IVW_CORE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readImageFromDisk</b> (std::string filename)</td></tr>
<tr class="separator:a32a77aff89bb77c768157f02f845b39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246294ce0a3b7487f492874591b7841"><td class="memTemplParams" colspan="2"><a id="af246294ce0a3b7487f492874591b7841"></a>
template&lt;size_t N, typename IndexType  = size_t&gt; </td></tr>
<tr class="memitem:af246294ce0a3b7487f492874591b7841"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeIndexMapper</b> (const Vector&lt; N, IndexType &gt; &amp;dim)</td></tr>
<tr class="separator:af246294ce0a3b7487f492874591b7841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0257287b8cc817dc288c86611672e4c"><td class="memTemplParams" colspan="2">template&lt;bool PropagateConst = true, typename Iter &gt; </td></tr>
<tr class="memitem:af0257287b8cc817dc288c86611672e4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a>&lt; Iter, PropagateConst &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af0257287b8cc817dc288c86611672e4c">makeIndirectIterator</a> (Iter &amp;&amp;iter)</td></tr>
<tr class="separator:af0257287b8cc817dc288c86611672e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de58d1081c70829462a75e15c657751"><td class="memTemplParams" colspan="2"><a id="a7de58d1081c70829462a75e15c657751"></a>
template&lt;typename T , typename std::enable_if&lt; HasClassIdentifierUpper&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7de58d1081c70829462a75e15c657751"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>classIdentifier</b> ()</td></tr>
<tr class="separator:a7de58d1081c70829462a75e15c657751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e6dc596313926716b8f49eb0e52543"><td class="memTemplParams" colspan="2"><a id="a79e6dc596313926716b8f49eb0e52543"></a>
template&lt;typename T , typename std::enable_if&lt; HasDataName&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a79e6dc596313926716b8f49eb0e52543"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataName</b> ()</td></tr>
<tr class="separator:a79e6dc596313926716b8f49eb0e52543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8aa11e101bd5d0b65a14fafb02a7712"><td class="memTemplParams" colspan="2"><a id="aa8aa11e101bd5d0b65a14fafb02a7712"></a>
template&lt;typename T , typename std::enable_if&lt; HasColorCodeUpper&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa8aa11e101bd5d0b65a14fafb02a7712"><td class="memTemplItemLeft" align="right" valign="top">uvec3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>colorCode</b> ()</td></tr>
<tr class="separator:aa8aa11e101bd5d0b65a14fafb02a7712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034e517cb3d0f51532659516fd00fb9e"><td class="memTemplParams" colspan="2"><a id="a034e517cb3d0f51532659516fd00fb9e"></a>
template&lt;typename T , typename std::enable_if&lt; HasDataInfo&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a034e517cb3d0f51532659516fd00fb9e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_info</b> (const T *data)</td></tr>
<tr class="separator:a034e517cb3d0f51532659516fd00fb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c06f4abcbaadca67fe724af058cedf3"><td class="memTemplParams" colspan="2"><a id="a0c06f4abcbaadca67fe724af058cedf3"></a>
template&lt;typename T , typename std::enable_if&lt;!HasInfo&lt; T &gt;::value &amp;&amp;HasDataInfo&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0c06f4abcbaadca67fe724af058cedf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1Document.html">Document</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>info</b> (const T &amp;data)</td></tr>
<tr class="separator:a0c06f4abcbaadca67fe724af058cedf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53def8e049a61d2e387a42c2ead8b565"><td class="memItemLeft" align="right" valign="top"><a id="a53def8e049a61d2e387a42c2ead8b565"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (<a class="el" href="structinviwo_1_1ExceptionContext.html">ExceptionContext</a> context, std::string message, LogLevel level=LogLevel::Info, LogAudience audience=LogAudience::Developer)</td></tr>
<tr class="separator:a53def8e049a61d2e387a42c2ead8b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda3e84375799dd6881d8501faa4f157"><td class="memTemplParams" colspan="2"><a id="aeda3e84375799dd6881d8501faa4f157"></a>
template&lt;class charT , class traits , class DelimT &gt; </td></tr>
<tr class="memitem:aeda3e84375799dd6881d8501faa4f157"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1util_1_1ostream__joiner.html">ostream_joiner</a>&lt; std::decay_t&lt; DelimT &gt;, charT, traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_ostream_joiner</b> (std::basic_ostream&lt; charT, traits &gt; &amp;os, DelimT &amp;&amp;delimiter)</td></tr>
<tr class="separator:aeda3e84375799dd6881d8501faa4f157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515b33c203ea126830f4bb9238bcaf1"><td class="memTemplParams" colspan="2"><a id="a7515b33c203ea126830f4bb9238bcaf1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7515b33c203ea126830f4bb9238bcaf1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetValue</b> (T &amp;t, T value)</td></tr>
<tr class="separator:a7515b33c203ea126830f4bb9238bcaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memTemplParams" colspan="2"><a id="af71ef5ebf3e6127ca2a819ef1ed62926"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memTemplItemLeft" align="right" valign="top">OnScopeExit::ExitAction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RevertValue</b> (T &amp;t)</td></tr>
<tr class="separator:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9d8109d75e9f8a6b234bfe6c426af4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4a9d8109d75e9f8a6b234bfe6c426af4">getLibrarySearchPaths</a> ()</td></tr>
<tr class="memdesc:a4a9d8109d75e9f8a6b234bfe6c426af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns paths to search for module libraries. All platforms: executable directory and application modules directory (AppData/Inviwo/modules on windows). Platform dependent search directories: OSX: DYLD_LIBRARY_PATH UNIX: LD_LIBRARY_PATH/LD_RUN_PATH, RPATH and "executable directory
/../../lib".  <a href="#a4a9d8109d75e9f8a6b234bfe6c426af4">More...</a><br /></td></tr>
<tr class="separator:a4a9d8109d75e9f8a6b234bfe6c426af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53b502584bb80069052c81328db2215"><td class="memItemLeft" align="right" valign="top"><a id="aa53b502584bb80069052c81328db2215"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasAddLibrarySearchDirsFunction</b> ()</td></tr>
<tr class="separator:aa53b502584bb80069052c81328db2215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e4600a8237efdd575010459808049"><td class="memItemLeft" align="right" valign="top"><a id="a608e4600a8237efdd575010459808049"></a>
IVW_CORE_API std::vector&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>addLibrarySearchDirs</b> (const std::vector&lt; std::string &gt; &amp;dirs)</td></tr>
<tr class="separator:a608e4600a8237efdd575010459808049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc0e5ac95c186097d2ee18e27b60e81"><td class="memItemLeft" align="right" valign="top"><a id="a4bc0e5ac95c186097d2ee18e27b60e81"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>removeLibrarySearchDirs</b> (const std::vector&lt; void *&gt; &amp;dirs)</td></tr>
<tr class="separator:a4bc0e5ac95c186097d2ee18e27b60e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3cea0d268da110a58fd05a2a731322"><td class="memItemLeft" align="right" valign="top"><a id="a7d3cea0d268da110a58fd05a2a731322"></a>
IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLoadedLibraries</b> ()</td></tr>
<tr class="separator:a7d3cea0d268da110a58fd05a2a731322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3156597249fa9167da75e41374c7c4"><td class="memTemplParams" colspan="2"><a id="aef3156597249fa9167da75e41374c7c4"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:aef3156597249fa9167da75e41374c7c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:aef3156597249fa9167da75e41374c7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeb2adb5689b9b930f4b7bb334ad7ce"><td class="memTemplParams" colspan="2"><a id="a1aeb2adb5689b9b930f4b7bb334ad7ce"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1aeb2adb5689b9b930f4b7bb334ad7ce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (std::size_t n)</td></tr>
<tr class="separator:a1aeb2adb5689b9b930f4b7bb334ad7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1f7a8488c0b6234072b2c076d660e"><td class="memTemplParams" colspan="2"><a id="a2ce1f7a8488c0b6234072b2c076d660e"></a>
template&lt;typename Derived , typename Base , typename Del &gt; </td></tr>
<tr class="memitem:a2ce1f7a8488c0b6234072b2c076d660e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived, Del &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_unique_ptr_cast</b> (std::unique_ptr&lt; Base, Del &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a2ce1f7a8488c0b6234072b2c076d660e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b933369fe95317aa1d1f5764989321"><td class="memTemplParams" colspan="2"><a id="ae2b933369fe95317aa1d1f5764989321"></a>
template&lt;typename Derived , typename Base , typename Del &gt; </td></tr>
<tr class="memitem:ae2b933369fe95317aa1d1f5764989321"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived, Del &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_unique_ptr_cast</b> (std::unique_ptr&lt; Base, Del &gt; &amp;&amp;p)</td></tr>
<tr class="separator:ae2b933369fe95317aa1d1f5764989321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37af5df3a1dbd38fa7389363cde49543"><td class="memTemplParams" colspan="2"><a id="a37af5df3a1dbd38fa7389363cde49543"></a>
template&lt;typename Derived , typename Base &gt; </td></tr>
<tr class="memitem:a37af5df3a1dbd38fa7389363cde49543"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_unique_ptr_cast</b> (std::unique_ptr&lt; Base, std::default_delete&lt; Base &gt;&gt; &amp;&amp;p)</td></tr>
<tr class="separator:a37af5df3a1dbd38fa7389363cde49543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d75eaeb326c05915cb07616332d31d5"><td class="memTemplParams" colspan="2"><a id="a3d75eaeb326c05915cb07616332d31d5"></a>
template&lt;std::size_t N, typename Index  = size_t, typename Functor &gt; </td></tr>
<tr class="memitem:a3d75eaeb326c05915cb07616332d31d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_array</b> (Functor &amp;&amp;func) -&gt; std::array&lt; decltype(func(std::declval&lt; Index &gt;())), N &gt;</td></tr>
<tr class="separator:a3d75eaeb326c05915cb07616332d31d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90888f794252ba3891f368137a67369d"><td class="memTemplParams" colspan="2"><a id="a90888f794252ba3891f368137a67369d"></a>
template&lt;typename T , typename std::enable_if&lt;!std::is_abstract&lt; T &gt;::value &amp;&amp;std::is_default_constructible&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a90888f794252ba3891f368137a67369d"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultConstructType</b> ()</td></tr>
<tr class="separator:a90888f794252ba3891f368137a67369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81e9808c5ba9826b5771e2542490bf"><td class="memTemplParams" colspan="2"><a id="abf81e9808c5ba9826b5771e2542490bf"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abf81e9808c5ba9826b5771e2542490bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_remove</b> (T &amp;cont, const V &amp;elem) -&gt; decltype(std::distance(std::declval&lt; T &gt;().begin(), std::declval&lt; T &gt;().end()))</td></tr>
<tr class="separator:abf81e9808c5ba9826b5771e2542490bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5262199109900b1b041fd1bb14a585f"><td class="memTemplParams" colspan="2"><a id="af5262199109900b1b041fd1bb14a585f"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:af5262199109900b1b041fd1bb14a585f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_remove_if</b> (T &amp;cont, Pred pred) -&gt; decltype(std::distance(std::declval&lt; T &gt;().begin(), std::declval&lt; T &gt;().end()))</td></tr>
<tr class="separator:af5262199109900b1b041fd1bb14a585f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memTemplParams" colspan="2"><a id="a2212b8323ef0cad0985bb8032a8c3e32"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_erase</b> (T &amp;cont)</td></tr>
<tr class="separator:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memTemplParams" colspan="2"><a id="a81d14f127305d858d416c2fdb0c4ec0f"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_erase_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439e115005151ce337820ffa1246e38"><td class="memTemplParams" colspan="2"><a id="a5439e115005151ce337820ffa1246e38"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a5439e115005151ce337820ffa1246e38"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_erase_remove_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a5439e115005151ce337820ffa1246e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memTemplParams" colspan="2"><a id="a4ba2e79134e4bf5de2c2851f3ddbabb1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>push_back_unique</b> (T &amp;cont, typename T::value_type elem)</td></tr>
<tr class="separator:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86511839ad3354ee89ff92c98be78c86"><td class="memTemplParams" colspan="2"><a id="a86511839ad3354ee89ff92c98be78c86"></a>
template&lt;typename Dst , typename... Srcs&gt; </td></tr>
<tr class="memitem:a86511839ad3354ee89ff92c98be78c86"><td class="memTemplItemLeft" align="right" valign="top">Dst &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append</b> (Dst &amp;dest, Srcs &amp;&amp;... sources)</td></tr>
<tr class="separator:a86511839ad3354ee89ff92c98be78c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3403811241ba0b1d202ae0548baa272"><td class="memTemplParams" colspan="2"><a id="ac3403811241ba0b1d202ae0548baa272"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ac3403811241ba0b1d202ae0548baa272"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ac3403811241ba0b1d202ae0548baa272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb1874215836798aa939a09ea7097e5"><td class="memTemplParams" colspan="2"><a id="a6cb1874215836798aa939a09ea7097e5"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a6cb1874215836798aa939a09ea7097e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (T &amp;cont, Pred pred) -&gt; typename T::iterator</td></tr>
<tr class="separator:a6cb1874215836798aa939a09ea7097e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memTemplParams" colspan="2"><a id="ae8e5dd33fbb9abc8d28e1e74f78233e0"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (const T &amp;cont, Pred pred) -&gt; typename T::const_iterator</td></tr>
<tr class="separator:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade96273c6f72f177a872f872e22091c0"><td class="memTemplParams" colspan="2"><a id="ade96273c6f72f177a872f872e22091c0"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ade96273c6f72f177a872f872e22091c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ade96273c6f72f177a872f872e22091c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f54391ec0db5815036c778ed412346"><td class="memTemplParams" colspan="2"><a id="ab1f54391ec0db5815036c778ed412346"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:ab1f54391ec0db5815036c778ed412346"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:ab1f54391ec0db5815036c778ed412346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae770415d5ba00c86cf182d333590ac06"><td class="memTemplParams" colspan="2"><a id="ae770415d5ba00c86cf182d333590ac06"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ae770415d5ba00c86cf182d333590ac06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ae770415d5ba00c86cf182d333590ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memTemplParams" colspan="2"><a id="a959a93edbea65cb8ae18addd0dcc04b1"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_if</b> (const T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memTemplParams" colspan="2"><a id="a071781f9ac07a9a1b432fc2aec6388ee"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if_or_null</b> (T &amp;cont, P pred) -&gt; typename T::value_type</td></tr>
<tr class="separator:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d7b74f00e72f7b4556af25b050a092"><td class="memTemplParams" colspan="2"><a id="a49d7b74f00e72f7b4556af25b050a092"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a49d7b74f00e72f7b4556af25b050a092"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_or_null</b> (T &amp;cont, const V &amp;elem) -&gt; typename T::value_type</td></tr>
<tr class="separator:a49d7b74f00e72f7b4556af25b050a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memTemplParams" colspan="2"><a id="ad093bf8f1f594c0f814c6154fb59e39c"></a>
template&lt;typename T , typename V , typename Callable &gt; </td></tr>
<tr class="memitem:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_or_null</b> (T &amp;cont, const V &amp;elem, Callable f) -&gt; typename T::value_type</td></tr>
<tr class="separator:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111c6325641f7d9c5bf18a934e5290c7"><td class="memTemplParams" colspan="2"><a id="a111c6325641f7d9c5bf18a934e5290c7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a111c6325641f7d9c5bf18a934e5290c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_key</b> (T &amp;map, const typename T::key_type &amp;key)</td></tr>
<tr class="separator:a111c6325641f7d9c5bf18a934e5290c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee41d732a5626da3a086161c7d83c33"><td class="memTemplParams" colspan="2"><a id="a1ee41d732a5626da3a086161c7d83c33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ee41d732a5626da3a086161c7d83c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_unique</b> (T &amp;map, const typename T::key_type &amp;key, typename T::mapped_type &amp;value)</td></tr>
<tr class="separator:a1ee41d732a5626da3a086161c7d83c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memTemplParams" colspan="2"><a id="a8d1bd66e291bc8e17a45faf11b8587bb"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_find_or_null</b> (T &amp;cont, const V &amp;elem) -&gt; typename T::mapped_type</td></tr>
<tr class="separator:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fa3775ce29cc54f0b8e740e72ac67e"><td class="memTemplParams" colspan="2"><a id="a27fa3775ce29cc54f0b8e740e72ac67e"></a>
template&lt;typename T , typename V , typename Callable &gt; </td></tr>
<tr class="memitem:a27fa3775ce29cc54f0b8e740e72ac67e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_find_or_null</b> (T &amp;cont, const V &amp;elem, Callable f) -&gt; typename std::result_of&lt; Callable(typename T::mapped_type)&gt;::type</td></tr>
<tr class="separator:a27fa3775ce29cc54f0b8e740e72ac67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ce6cc0afa6fd1aaced45db94fbad30"><td class="memTemplParams" colspan="2"><a id="a02ce6cc0afa6fd1aaced45db94fbad30"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a02ce6cc0afa6fd1aaced45db94fbad30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:a02ce6cc0afa6fd1aaced45db94fbad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa796907d64f78d935533478df8848c4f"><td class="memTemplParams" colspan="2"><a id="aa796907d64f78d935533478df8848c4f"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa796907d64f78d935533478df8848c4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:aa796907d64f78d935533478df8848c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c3d29b5b0221550c9f9c5e1df0bad7"><td class="memTemplParams" colspan="2"><a id="ae4c3d29b5b0221550c9f9c5e1df0bad7"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ae4c3d29b5b0221550c9f9c5e1df0bad7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>none_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:ae4c3d29b5b0221550c9f9c5e1df0bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2691c9ebc1d983d4918d0f8e221aed"><td class="memTemplParams" colspan="2"><a id="aaa2691c9ebc1d983d4918d0f8e221aed"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aaa2691c9ebc1d983d4918d0f8e221aed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (Iter begin, Iter end)</td></tr>
<tr class="separator:aaa2691c9ebc1d983d4918d0f8e221aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b134066908684664ba29302a87877f"><td class="memTemplParams" colspan="2"><a id="a02b134066908684664ba29302a87877f"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a02b134066908684664ba29302a87877f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (std::pair&lt; Iter, Iter &gt; const &amp;x)</td></tr>
<tr class="separator:a02b134066908684664ba29302a87877f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d359aa7245cf091a847e7ea68bd1b50"><td class="memTemplParams" colspan="2"><a id="a7d359aa7245cf091a847e7ea68bd1b50"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a7d359aa7245cf091a847e7ea68bd1b50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; typename Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (Container &amp;c)</td></tr>
<tr class="separator:a7d359aa7245cf091a847e7ea68bd1b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d405351d3c70773ab2be11f40b738a9"><td class="memTemplParams" colspan="2"><a id="a5d405351d3c70773ab2be11f40b738a9"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a5d405351d3c70773ab2be11f40b738a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; typename Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (const Container &amp;c)</td></tr>
<tr class="separator:a5d405351d3c70773ab2be11f40b738a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memTemplParams" colspan="2"><a id="a9ea3b690dfcdeda7ee4c0a5c54926945"></a>
template&lt;typename T , typename OutIt , typename P &gt; </td></tr>
<tr class="memitem:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memTemplItemLeft" align="right" valign="top">OutIt&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (const T &amp;cont, OutIt out, P pred)</td></tr>
<tr class="separator:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memTemplParams" colspan="2"><a id="a72545927f4c67d0c29ddf1fab7768ad8"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (const T &amp;cont, P pred) -&gt; std::vector&lt; typename T::value_type &gt;</td></tr>
<tr class="separator:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4022cf8a434cab539ee1a37a8c0bbc"><td class="memTemplParams" colspan="2"><a id="a5f4022cf8a434cab539ee1a37a8c0bbc"></a>
template&lt;typename T , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a5f4022cf8a434cab539ee1a37a8c0bbc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (const T &amp;cont, UnaryOperation op) -&gt; std::vector&lt; typename std::result_of&lt; UnaryOperation(typename T::value_type)&gt;::type &gt;</td></tr>
<tr class="separator:a5f4022cf8a434cab539ee1a37a8c0bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8002915caf2929e669c07a259ff36fb1"><td class="memTemplParams" colspan="2"><a id="a8002915caf2929e669c07a259ff36fb1"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a8002915caf2929e669c07a259ff36fb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordering</b> (T &amp;cont, Pred pred) -&gt; std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:a8002915caf2929e669c07a259ff36fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4401cb675aec808de01a4e7a9f552f1"><td class="memTemplParams" colspan="2"><a id="aa4401cb675aec808de01a4e7a9f552f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4401cb675aec808de01a4e7a9f552f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordering</b> (T &amp;cont) -&gt; std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:aa4401cb675aec808de01a4e7a9f552f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7679ac4f77483edefc2dc236495b625"><td class="memTemplParams" colspan="2"><a id="aa7679ac4f77483edefc2dc236495b625"></a>
template&lt;typename Generator &gt; </td></tr>
<tr class="memitem:aa7679ac4f77483edefc2dc236495b625"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>table</b> (Generator gen, int start, int end, int step=1) -&gt; std::vector&lt; decltype(gen(std::declval&lt; int &gt;()))&gt;</td></tr>
<tr class="separator:aa7679ac4f77483edefc2dc236495b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memTemplParams" colspan="2"><a id="acdd7c9fa30cdd956764cfe090ff6a4bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_future_ready</b> (const std::future&lt; T &gt; &amp;future)</td></tr>
<tr class="separator:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120524c5de0bd62f52483f096e0374d4"><td class="memTemplParams" colspan="2">template&lt;typename... A, typename F &gt; </td></tr>
<tr class="memitem:a120524c5de0bd62f52483f096e0374d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structinviwo_1_1util_1_1detail_1_1is__callable.html">detail::is_callable</a>&lt; F, A... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a120524c5de0bd62f52483f096e0374d4">is_callable_with</a> (F &amp;&amp;)</td></tr>
<tr class="separator:a120524c5de0bd62f52483f096e0374d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940aef3565e6c2edd145d6d410087668"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a940aef3565e6c2edd145d6d410087668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a940aef3565e6c2edd145d6d410087668">hash_combine</a> (std::size_t &amp;seed, const T &amp;v)</td></tr>
<tr class="separator:a940aef3565e6c2edd145d6d410087668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828ef8f28093e76d6de14668216ca4ed"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a828ef8f28093e76d6de14668216ca4ed">toWstring</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a828ef8f28093e76d6de14668216ca4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the given std::string to std::wstring. On Windows, MultiByteToWideChar is used for this conversion assuming utf8 encoding. Otherwise, std::mbsrtowcs is used.  <a href="#a828ef8f28093e76d6de14668216ca4ed">More...</a><br /></td></tr>
<tr class="separator:a828ef8f28093e76d6de14668216ca4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74142af3631865f4c234289d551ce883"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a74142af3631865f4c234289d551ce883">getDefaultTimerThread</a> ()</td></tr>
<tr class="separator:a74142af3631865f4c234289d551ce883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab1e98b2853526e340cf8868e2d5a2"><td class="memItemLeft" align="right" valign="top"><a id="a7cab1e98b2853526e340cf8868e2d5a2"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveNetwork</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::string filename)</td></tr>
<tr class="separator:a7cab1e98b2853526e340cf8868e2d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583e76909502b8ed3d5300ba1e61fcdc"><td class="memItemLeft" align="right" valign="top"><a id="a583e76909502b8ed3d5300ba1e61fcdc"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveAllCanvases</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::string dir, std::string name=&quot;UPN&quot;, std::string ext=&quot;.png&quot;)</td></tr>
<tr class="separator:a583e76909502b8ed3d5300ba1e61fcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab603a5de5e47e8d9dae8a9278316de39"><td class="memItemLeft" align="right" valign="top"><a id="ab603a5de5e47e8d9dae8a9278316de39"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidIdentifierCharacter</b> (char c, const std::string &amp;extra=&quot;&quot;)</td></tr>
<tr class="separator:ab603a5de5e47e8d9dae8a9278316de39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745c08a6d7361665ddd06574e8e24de6"><td class="memItemLeft" align="right" valign="top"><a id="a745c08a6d7361665ddd06574e8e24de6"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>validateIdentifier</b> (const std::string &amp;identifier, const std::string &amp;type, <a class="el" href="structinviwo_1_1ExceptionContext.html">ExceptionContext</a> context, const std::string &amp;extra=&quot;&quot;)</td></tr>
<tr class="separator:a745c08a6d7361665ddd06574e8e24de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c6cae56d5239848a9e2fa42cc5d15"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a947c6cae56d5239848a9e2fa42cc5d15">findUniqueIdentifier</a> (const std::string &amp;identifier, std::function&lt; bool(const std::string &amp;)&gt; isUnique, const std::string &amp;sep=&quot; &quot;)</td></tr>
<tr class="separator:a947c6cae56d5239848a9e2fa42cc5d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8099b742eca40726e0c2fabaa8729632"><td class="memItemLeft" align="right" valign="top"><a id="a8099b742eca40726e0c2fabaa8729632"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>cleanIdentifier</b> (const std::string &amp;identifier, const std::string &amp;extra=&quot;&quot;)</td></tr>
<tr class="separator:a8099b742eca40726e0c2fabaa8729632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dabd37be130a5a97526c8fbc77f65e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a45dabd37be130a5a97526c8fbc77f65e">stripModuleFileNameDecoration</a> (std::string filePath)</td></tr>
<tr class="memdesc:a45dabd37be130a5a97526c8fbc77f65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes inviwo-module from module library file name. Turns "/path/to/inviwo-module-yourmodule.dll" into "yourmodule". Returns filename without extension if inviwo-module was not found.  <a href="#a45dabd37be130a5a97526c8fbc77f65e">More...</a><br /></td></tr>
<tr class="separator:a45dabd37be130a5a97526c8fbc77f65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6384d17dba8503f35e7a35b38eed3dd"><td class="memItemLeft" align="right" valign="top"><a id="aa6384d17dba8503f35e7a35b38eed3dd"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stripIdentifier</b> (std::string identifier)</td></tr>
<tr class="separator:aa6384d17dba8503f35e7a35b38eed3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08654e337b9b5894672a1b218f5b9a31"><td class="memTemplParams" colspan="2"><a id="a08654e337b9b5894672a1b218f5b9a31"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a08654e337b9b5894672a1b218f5b9a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>show</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a08654e337b9b5894672a1b218f5b9a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84700445b4e279e926156e7539163a11"><td class="memTemplParams" colspan="2"><a id="a84700445b4e279e926156e7539163a11"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a84700445b4e279e926156e7539163a11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hide</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a84700445b4e279e926156e7539163a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memTemplParams" colspan="2"><a id="ad6d5b4f91c4ac3ca3d914354878b1601"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxel</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &amp;v, C callback)</td></tr>
<tr class="separator:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memTemplParams" colspan="2"><a id="a13d81aad86b9c7cb3348b7e57305d8a2"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxelParallel</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &amp;v, C callback, size_t jobs=0)</td></tr>
<tr class="separator:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116b4a7d2ce00fc4ae62c9a0d97ac913"><td class="memItemLeft" align="right" valign="top"><a id="a116b4a7d2ce00fc4ae62c9a0d97ac913"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasTimestamps</b> (const VolumeSequence &amp;seq, bool checkfirstonly=true)</td></tr>
<tr class="separator:a116b4a7d2ce00fc4ae62c9a0d97ac913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038745e7b7e75fa6036eba7b1221e94a"><td class="memItemLeft" align="right" valign="top"><a id="a038745e7b7e75fa6036eba7b1221e94a"></a>
std::pair&lt; double, double &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getTimestampRange</b> (const VolumeSequence &amp;seq, bool sorted=true)</td></tr>
<tr class="separator:a038745e7b7e75fa6036eba7b1221e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6926f02706fff47b2285ae4994e3f901"><td class="memItemLeft" align="right" valign="top"><a id="a6926f02706fff47b2285ae4994e3f901"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>isSorted</b> (const VolumeSequence &amp;seq)</td></tr>
<tr class="separator:a6926f02706fff47b2285ae4994e3f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa30fa7be8fb4348894c002a3ac3c67"><td class="memItemLeft" align="right" valign="top"><a id="adfa30fa7be8fb4348894c002a3ac3c67"></a>
VolumeSequence IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>sortSequence</b> (const VolumeSequence &amp;seq)</td></tr>
<tr class="separator:adfa30fa7be8fb4348894c002a3ac3c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e369c577a89285815da6ea35d288ca"><td class="memItemLeft" align="right" valign="top"><a id="ac0e369c577a89285815da6ea35d288ca"></a>
std::pair&lt; SharedVolume, SharedVolume &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getVolumesForTimestep</b> (const VolumeSequence &amp;seq, double t, bool sorted=true)</td></tr>
<tr class="separator:ac0e369c577a89285815da6ea35d288ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356570c1c610943548c9104393f4c780"><td class="memItemLeft" align="right" valign="top"><a id="a356570c1c610943548c9104393f4c780"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasTimestamp</b> (SharedVolume vol)</td></tr>
<tr class="separator:a356570c1c610943548c9104393f4c780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94572c4001697d71ad56c7f3d9a54ba8"><td class="memItemLeft" align="right" valign="top"><a id="a94572c4001697d71ad56c7f3d9a54ba8"></a>
double IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getTimestamp</b> (SharedVolume vol)</td></tr>
<tr class="separator:a94572c4001697d71ad56c7f3d9a54ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c529c38962b0f30f6472c395557ce59"><td class="memItemLeft" align="right" valign="top"><a id="a7c529c38962b0f30f6472c395557ce59"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasMargins</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a7c529c38962b0f30f6472c395557ce59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7950e78dcc116a79cbbcd2eb679f5cbd"><td class="memItemLeft" align="right" valign="top"><a id="a7950e78dcc116a79cbbcd2eb679f5cbd"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>isBricked</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a7950e78dcc116a79cbbcd2eb679f5cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9ea3efdd8f412253b530be6b5f715d"><td class="memItemLeft" align="right" valign="top"><a id="a0b9ea3efdd8f412253b530be6b5f715d"></a>
size3_t IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getBrickDimensions</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a0b9ea3efdd8f412253b530be6b5f715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8542415328e2816a23607c5cc98c9341"><td class="memItemLeft" align="right" valign="top">std::pair&lt; vec3, vec3 &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8542415328e2816a23607c5cc98c9341">getVolumeMargins</a> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="memdesc:a8542415328e2816a23607c5cc98c9341"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the margins of a volume, in normalized texture coordinates [0,1]  <a href="#a8542415328e2816a23607c5cc98c9341">More...</a><br /></td></tr>
<tr class="separator:a8542415328e2816a23607c5cc98c9341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c836cccb8edab48454737dedf4ea04"><td class="memItemLeft" align="right" valign="top">size3_t IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a95c836cccb8edab48454737dedf4ea04">getVolumeDimensions</a> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="memdesc:a95c836cccb8edab48454737dedf4ea04"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the true volume dimensions considering volume margins and bricking  <a href="#a95c836cccb8edab48454737dedf4ea04">More...</a><br /></td></tr>
<tr class="separator:a95c836cccb8edab48454737dedf4ea04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d36142d9279c614f2d9a0d4503ecb8"><td class="memItemLeft" align="right" valign="top">double IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af0d36142d9279c614f2d9a0d4503ecb8">voxelVolume</a> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="memdesc:af0d36142d9279c614f2d9a0d4503ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the volume of a single voxel, taking the basis and the dimensions into account The units of the result is in the unit as the basis vectors ^3  <a href="#af0d36142d9279c614f2d9a0d4503ecb8">More...</a><br /></td></tr>
<tr class="separator:af0d36142d9279c614f2d9a0d4503ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec11e63479fff3c005d159414687d4e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a2ec11e63479fff3c005d159414687d4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a2ec11e63479fff3c005d159414687d4e">zip</a> (T &amp;&amp;... args) -&gt; <a class="el" href="structinviwo_1_1util_1_1detailzip_1_1zipper.html">detailzip::zipper</a>&lt; T... &gt;</td></tr>
<tr class="separator:a2ec11e63479fff3c005d159414687d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4c1a60c4b345a81d28ca29ab9848d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b4c1a60c4b345a81d28ca29ab9848d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a0b4c1a60c4b345a81d28ca29ab9848d7">make_sequence</a> (const T &amp;begin, const T &amp;end, const T &amp;inc) -&gt; <a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a>&lt; T &gt;</td></tr>
<tr class="separator:a0b4c1a60c4b345a81d28ca29ab9848d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4344b2477debffad3176a91526179640"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a4344b2477debffad3176a91526179640"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4344b2477debffad3176a91526179640">enumerate</a> (T &amp;&amp;cont, Ts &amp;&amp;... conts)</td></tr>
<tr class="separator:a4344b2477debffad3176a91526179640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c709203564a22460661ee266085ad3"><td class="memItemLeft" align="right" valign="top"><a id="a21c709203564a22460661ee266085ad3"></a>
void IVW_QTEDITOR_API&#160;</td><td class="memItemRight" valign="bottom"><b>insertNetworkForData</b> (const std::string &amp;dataFile, <a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *net, bool alwaysFirst=false, bool onlySource=false)</td></tr>
<tr class="separator:a21c709203564a22460661ee266085ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e028e18ceb523fe25a0ae4207178d9a"><td class="memTemplParams" colspan="2"><a id="a1e028e18ceb523fe25a0ae4207178d9a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1e028e18ceb523fe25a0ae4207178d9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const half_float::half &amp;v)</td></tr>
<tr class="separator:a1e028e18ceb523fe25a0ae4207178d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7981aa76bddb83bfe067c9f9dfefbb69"><td class="memTemplParams" colspan="2"><a id="a7981aa76bddb83bfe067c9f9dfefbb69"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7981aa76bddb83bfe067c9f9dfefbb69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const half_float::half &amp;v)</td></tr>
<tr class="separator:a7981aa76bddb83bfe067c9f9dfefbb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa048b0cf2e27625499d9ac8e03af03d6">isConvex</a> (const std::vector&lt; T &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aa048b0cf2e27625499d9ac8e03af03d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given polygon is convex  <a href="#aa048b0cf2e27625499d9ac8e03af03d6">More...</a><br /></td></tr>
<tr class="separator:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193aac2254d9cc5b5b1029995323d957"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a193aac2254d9cc5b5b1029995323d957"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a193aac2254d9cc5b5b1029995323d957">isInside</a> (const std::vector&lt; T &gt; &amp;hull, const T &amp;p)</td></tr>
<tr class="memdesc:a193aac2254d9cc5b5b1029995323d957"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a given point lies within the convex hull  <a href="#a193aac2254d9cc5b5b1029995323d957">More...</a><br /></td></tr>
<tr class="separator:a193aac2254d9cc5b5b1029995323d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba0bfadae887301565e97b98483268b"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aaba0bfadae887301565e97b98483268b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aaba0bfadae887301565e97b98483268b">getArea</a> (const std::vector&lt; T &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aaba0bfadae887301565e97b98483268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the area of a convex polygon  <a href="#aaba0bfadae887301565e97b98483268b">More...</a><br /></td></tr>
<tr class="separator:aaba0bfadae887301565e97b98483268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6356ee05cfde312881b948335bf689b"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab6356ee05cfde312881b948335bf689b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab6356ee05cfde312881b948335bf689b">convexHull</a> (const std::vector&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ab6356ee05cfde312881b948335bf689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the complex hull from a given set of 2D points using the Monotone Chain algorithm, i.e. Andrew's convex hull algorithm  <a href="#ab6356ee05cfde312881b948335bf689b">More...</a><br /></td></tr>
<tr class="separator:ab6356ee05cfde312881b948335bf689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957df5095d5e6e1c7fc318dd545b1d7b"><td class="memItemLeft" align="right" valign="top"><a id="a957df5095d5e6e1c7fc318dd545b1d7b"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convertHullToMesh</b> (const std::vector&lt; vec2 &gt; &amp;hull, bool useIndices)</td></tr>
<tr class="separator:a957df5095d5e6e1c7fc318dd545b1d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dc0d84051199de89f7bca0cee40ec9"><td class="memItemLeft" align="right" valign="top"><a id="a88dc0d84051199de89f7bca0cee40ec9"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeMinMax</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a88dc0d84051199de89f7bca0cee40ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0b569b4fd24566c07af3acda732b48"><td class="memItemLeft" align="right" valign="top"><a id="abb0b569b4fd24566c07af3acda732b48"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>layerMinMax</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:abb0b569b4fd24566c07af3acda732b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dd2ff89710b3e4c89e4d6e11b6ef4f"><td class="memItemLeft" align="right" valign="top"><a id="aa7dd2ff89710b3e4c89e4d6e11b6ef4f"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bufferMinMax</b> (const <a class="el" href="classinviwo_1_1BufferRAM.html">BufferRAM</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:aa7dd2ff89710b3e4c89e4d6e11b6ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022b9b5a1cf46c488b8f27f7e7c52a6a"><td class="memItemLeft" align="right" valign="top"><a id="a022b9b5a1cf46c488b8f27f7e7c52a6a"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeMinMax</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a022b9b5a1cf46c488b8f27f7e7c52a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab550da1a3194a043912ad2245e28fadf"><td class="memItemLeft" align="right" valign="top"><a id="ab550da1a3194a043912ad2245e28fadf"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>layerMinMax</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:ab550da1a3194a043912ad2245e28fadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e958eebfae8b0c0733b289327fd5f3a"><td class="memItemLeft" align="right" valign="top"><a id="a2e958eebfae8b0c0733b289327fd5f3a"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bufferMinMax</b> (const <a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> *buffer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a2e958eebfae8b0c0733b289327fd5f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45333385bb88c2c829ca1c624e69f2e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ad45333385bb88c2c829ca1c624e69f2e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad45333385bb88c2c829ca1c624e69f2e">dataMinMax</a> (const ValueType *data, size_t size, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:ad45333385bb88c2c829ca1c624e69f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dfea83005204a1c4beaa3714c38e74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a90dfea83005204a1c4beaa3714c38e74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a90dfea83005204a1c4beaa3714c38e74">layerRAMDistanceTransform</a> (const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 2, U &gt; basis, const size2_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:a90dfea83005204a1c4beaa3714c38e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197ca54aa9430e796e41f223f577635"><td class="memTemplParams" colspan="2"><a id="aa197ca54aa9430e796e41f223f577635"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa197ca54aa9430e796e41f223f577635"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerRAMDistanceTransform</b> (const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 2, U &gt; basis, const size2_t upsample)</td></tr>
<tr class="separator:aa197ca54aa9430e796e41f223f577635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memTemplParams" colspan="2"><a id="a26f9879e82cc4d9c7eb77c2724b2d019"></a>
template&lt;typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae4dea32beba341f6b624c183d07277"><td class="memTemplParams" colspan="2"><a id="aaae4dea32beba341f6b624c183d07277"></a>
template&lt;typename U , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:aaae4dea32beba341f6b624c183d07277"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, double threshold, bool normalize, bool flip, bool square, double scale, ProgressCallback callback)</td></tr>
<tr class="separator:aaae4dea32beba341f6b624c183d07277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf8c62d442b8dd2f6be424f09404859"><td class="memTemplParams" colspan="2"><a id="a6cf8c62d442b8dd2f6be424f09404859"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6cf8c62d442b8dd2f6be424f09404859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, double threshold, bool normalize, bool flip, bool square, double scale)</td></tr>
<tr class="separator:a6cf8c62d442b8dd2f6be424f09404859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc9d791f018bc81c41c404dd173a3cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bc9d791f018bc81c41c404dd173a3cb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a0bc9d791f018bc81c41c404dd173a3cb">haltonSequence</a> (size_t base, size_t numberOfPoints)</td></tr>
<tr class="separator:a0bc9d791f018bc81c41c404dd173a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c7215de9974cbf63e74f28ae4941cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18c7215de9974cbf63e74f28ae4941cc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a18c7215de9974cbf63e74f28ae4941cc">haltonSequence</a> (size2_t dims, size_t numberOfPoints, size_t baseX=2, size_t baseY=3)</td></tr>
<tr class="separator:a18c7215de9974cbf63e74f28ae4941cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad0d2b2ea3ccf4f8f61bde3bc4a3292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abad0d2b2ea3ccf4f8f61bde3bc4a3292"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#abad0d2b2ea3ccf4f8f61bde3bc4a3292">haltonSequence</a> (size3_t dims, size_t numberOfPoints, size_t baseX=2, size_t baseY=3, size_t baseZ=5)</td></tr>
<tr class="separator:abad0d2b2ea3ccf4f8f61bde3bc4a3292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a48b2f672f99a31ee8b19f6f40fa768cb">randomSequence</a> (T *data, size_t numberOfElements, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d29c3a03f733f46621cb8b3dc1f0619"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a8d29c3a03f733f46621cb8b3dc1f0619"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8d29c3a03f733f46621cb8b3dc1f0619">randomImage</a> (size2_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a8d29c3a03f733f46621cb8b3dc1f0619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995a3d89246ce375a3ecc478959a8cea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a995a3d89246ce375a3ecc478959a8cea"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a995a3d89246ce375a3ecc478959a8cea">randomVolume</a> (size3_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a995a3d89246ce375a3ecc478959a8cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e906349979b05c9d0bba6d0a870da72"><td class="memTemplParams" colspan="2">template&lt;typename Rand  = std::mt19937&gt; </td></tr>
<tr class="memitem:a9e906349979b05c9d0bba6d0a870da72"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a9e906349979b05c9d0bba6d0a870da72">perlinNoise</a> (size2_t dims, float persistence, size_t startLevel, size_t endLevel, Rand &amp;randomNumberGenerator=Rand())</td></tr>
<tr class="separator:a9e906349979b05c9d0bba6d0a870da72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf192a88e50a7b6fd57363e4b7f2adfa"><td class="memTemplParams" colspan="2">template&lt;typename Rand  = std::mt19937&gt; </td></tr>
<tr class="memitem:acf192a88e50a7b6fd57363e4b7f2adfa"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#acf192a88e50a7b6fd57363e4b7f2adfa">poissonDisk</a> (size2_t dims, size_t poissonDotsAlongX, size_t maxPoints, Rand &amp;randomNumberGenerator=Rand())</td></tr>
<tr class="separator:acf192a88e50a7b6fd57363e4b7f2adfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcfa6968810037bc39cac05239f3586"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a1fcfa6968810037bc39cac05239f3586">marchingcubes</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback, std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback)</td></tr>
<tr class="separator:a1fcfa6968810037bc39cac05239f3586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859f8da4f45bae2f0ef4a246c9f83d3c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a859f8da4f45bae2f0ef4a246c9f83d3c">marchingCubesOpt</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback, std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback)</td></tr>
<tr class="separator:a859f8da4f45bae2f0ef4a246c9f83d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d16927242ef3ca2f6eb3763bca997c6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8d16927242ef3ca2f6eb3763bca997c6">marchingtetrahedron</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback, std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback)</td></tr>
<tr class="separator:a8d16927242ef3ca2f6eb3763bca997c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a40a272e79f771e627d2865ad5c61d3"><td class="memItemLeft" align="right" valign="top"><a id="a9a40a272e79f771e627d2865ad5c61d3"></a>
std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curlVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume)</td></tr>
<tr class="separator:a9a40a272e79f771e627d2865ad5c61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868dce49fd3bb5fe1e00ae21741e17df"><td class="memItemLeft" align="right" valign="top"><a id="a868dce49fd3bb5fe1e00ae21741e17df"></a>
std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curlVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:a868dce49fd3bb5fe1e00ae21741e17df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060da6b81ba276eccef48950775f5d0"><td class="memItemLeft" align="right" valign="top"><a id="a4060da6b81ba276eccef48950775f5d0"></a>
std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>divergenceVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume)</td></tr>
<tr class="separator:a4060da6b81ba276eccef48950775f5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c2e18ffbb9555e3e09fa311430f8eb"><td class="memItemLeft" align="right" valign="top"><a id="ae2c2e18ffbb9555e3e09fa311430f8eb"></a>
std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>divergenceVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:ae2c2e18ffbb9555e3e09fa311430f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fced04a2ded91e940c80974c559a93"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a10fced04a2ded91e940c80974c559a93"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a10fced04a2ded91e940c80974c559a93">generateVolume</a> (const size3_t &amp;dimensions, const mat3 &amp;basis, Functor &amp;&amp;function)</td></tr>
<tr class="separator:a10fced04a2ded91e940c80974c559a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7f0331189f7bab9a30abcaa2232203"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:afd7f0331189f7bab9a30abcaa2232203"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#afd7f0331189f7bab9a30abcaa2232203">makeSingleVoxelVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:afd7f0331189f7bab9a30abcaa2232203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3624bda720c599cf5ba2b1da294aba93"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a3624bda720c599cf5ba2b1da294aba93"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a3624bda720c599cf5ba2b1da294aba93">makeSphericalVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a3624bda720c599cf5ba2b1da294aba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7601a4221d0a73cbc4fbcf2a6397369"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:af7601a4221d0a73cbc4fbcf2a6397369"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af7601a4221d0a73cbc4fbcf2a6397369">makeRippleVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:af7601a4221d0a73cbc4fbcf2a6397369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ea5db009d3c6ea5afa9305a82d54f6"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a54ea5db009d3c6ea5afa9305a82d54f6"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a54ea5db009d3c6ea5afa9305a82d54f6">makeMarchingCubeVolume</a> (const size_t &amp;index)</td></tr>
<tr class="separator:a54ea5db009d3c6ea5afa9305a82d54f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fdb400eaf78b7f8917d0c208296133"><td class="memItemLeft" align="right" valign="top"><a id="ac4fdb400eaf78b7f8917d0c208296133"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gradientVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, int channel)</td></tr>
<tr class="separator:ac4fdb400eaf78b7f8917d0c208296133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad716fc353e91698e57cadc07a78d120f"><td class="memItemLeft" align="right" valign="top"><a id="ad716fc353e91698e57cadc07a78d120f"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeLaplacian</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, VolumeLaplacianPostProcessing postProcessing, double scale)</td></tr>
<tr class="separator:ad716fc353e91698e57cadc07a78d120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893e468e6145d6106135461cd962371"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:aa893e468e6145d6106135461cd962371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa893e468e6145d6106135461cd962371">volumeRAMDistanceTransform</a> (const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 3, U &gt; basis, const size3_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:aa893e468e6145d6106135461cd962371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1864cbcc93e0134e190ad0e41270c31"><td class="memTemplParams" colspan="2"><a id="ad1864cbcc93e0134e190ad0e41270c31"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad1864cbcc93e0134e190ad0e41270c31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeRAMDistanceTransform</b> (const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 3, U &gt; basis, const size3_t upsample)</td></tr>
<tr class="separator:ad1864cbcc93e0134e190ad0e41270c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51958ead836ffccf0cb9656b1571f9f"><td class="memTemplParams" colspan="2"><a id="ac51958ead836ffccf0cb9656b1571f9f"></a>
template&lt;typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:ac51958ead836ffccf0cb9656b1571f9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:ac51958ead836ffccf0cb9656b1571f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564715e4955caf9d9ab0f29cdbee5f1"><td class="memTemplParams" colspan="2"><a id="a8564715e4955caf9d9ab0f29cdbee5f1"></a>
template&lt;typename U , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a8564715e4955caf9d9ab0f29cdbee5f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t upsample, double threshold, bool normalize, bool flip, bool square, double scale, ProgressCallback callback)</td></tr>
<tr class="separator:a8564715e4955caf9d9ab0f29cdbee5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba56f22abced4929a6f4d668e51ca6b"><td class="memTemplParams" colspan="2"><a id="aeba56f22abced4929a6f4d668e51ca6b"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:aeba56f22abced4929a6f4d668e51ca6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t upsample, double threshold, bool normalize, bool flip, bool square, double scale)</td></tr>
<tr class="separator:aeba56f22abced4929a6f4d668e51ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863047057930049636d4e5c7d1e572e"><td class="memItemLeft" align="right" valign="top"><a id="a2863047057930049636d4e5c7d1e572e"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeSubSample</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *in, size3_t factors)</td></tr>
<tr class="separator:a2863047057930049636d4e5c7d1e572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0e32b44f49d3e4cc3c3893e958c539"><td class="memItemLeft" align="right" valign="top"><a id="a0e0e32b44f49d3e4cc3c3893e958c539"></a>
IVW_MODULE_BASE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>volumeSignificantVoxels</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a0e0e32b44f49d3e4cc3c3893e958c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301f6b6c9149cf18fcbf79a4ee50671f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a301f6b6c9149cf18fcbf79a4ee50671f">writeIvfVolumeSequence</a> (const VolumeSequence &amp;volumes, std::string name, std::string path, std::string reltivePathToElements=&quot;&quot;, bool overwrite=true)</td></tr>
<tr class="memdesc:a301f6b6c9149cf18fcbf79a4ee50671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a volume sequence to disk.  <a href="#a301f6b6c9149cf18fcbf79a4ee50671f">More...</a><br /></td></tr>
<tr class="separator:a301f6b6c9149cf18fcbf79a4ee50671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6460164f5b8a6fb25519c63fa3fbd2"><td class="memItemLeft" align="right" valign="top"><a id="adb6460164f5b8a6fb25519c63fa3fbd2"></a>
MeshDrawerGL::DrawMode&#160;</td><td class="memItemRight" valign="bottom"><b>getDrawMode</b> (LineRenderer::LineDrawMode drawMode, bool useAdjacency)</td></tr>
<tr class="separator:adb6460164f5b8a6fb25519c63fa3fbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1e393c6d76cb9610473161c31af319"><td class="memItemLeft" align="right" valign="top"><a id="a1f1e393c6d76cb9610473161c31af319"></a>
IvwKey&#160;</td><td class="memItemRight" valign="bottom"><b>mapKeyFromQt</b> (const QKeyEvent *keyevent)</td></tr>
<tr class="separator:a1f1e393c6d76cb9610473161c31af319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa788814c50164c72361d1e694439182c"><td class="memTemplParams" colspan="2"><a id="aa788814c50164c72361d1e694439182c"></a>
template&lt;typename T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa788814c50164c72361d1e694439182c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm2eigen</b> (const T &amp;elem) -&gt; Eigen::Matrix&lt; typename T::value_type, <a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T, 0 &gt;::value, 1 &gt;</td></tr>
<tr class="separator:aa788814c50164c72361d1e694439182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a657c60e875cedc887757eed4e19ad7"><td class="memTemplParams" colspan="2"><a id="a8a657c60e875cedc887757eed4e19ad7"></a>
template&lt;typename T , unsigned Rows, unsigned Cols, typename std::enable_if&lt;(Rows &gt;  = 2 &amp;&amp; Rows &lt;= 4 &amp;&amp; Cols &gt;= 2 &amp;&amp; Cols &lt;= 4&gt; </td></tr>
<tr class="memitem:a8a657c60e875cedc887757eed4e19ad7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen2glm</b> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="separator:a8a657c60e875cedc887757eed4e19ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bf79aba70128387f4271031a7d37d9"><td class="memTemplParams" colspan="2"><a id="ab2bf79aba70128387f4271031a7d37d9"></a>
template&lt;typename T , unsigned Rows, unsigned Cols, typename std::enable_if&lt;(Cols &gt;  = 2 &amp;&amp; Cols &lt;= 4 &amp;&amp; Rows == 1&gt; </td></tr>
<tr class="memitem:ab2bf79aba70128387f4271031a7d37d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen2glm</b> (const Eigen::Matrix&lt; T, Cols, Cols &gt; &amp;m)</td></tr>
<tr class="separator:ab2bf79aba70128387f4271031a7d37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9abe61f797f04681affd2c021731b22"><td class="memTemplParams" colspan="2"><a id="aa9abe61f797f04681affd2c021731b22"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9abe61f797f04681affd2c021731b22"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigenMatToImage</b> (const T &amp;m, bool flipY=false, std::string name=&quot;&quot;)</td></tr>
<tr class="separator:aa9abe61f797f04681affd2c021731b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1TextTextureObject.html">TextTextureObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6e1e0f2ae3a7b52b3a951b6fff0411b2">createTextTextureObject</a> (<a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;textRenderer, std::string text, vec4 fontColor, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; tex=nullptr)</td></tr>
<tr class="memdesc:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture with rendered text for a given string including its bounding box.  <a href="#a6e1e0f2ae3a7b52b3a951b6fff0411b2">More...</a><br /></td></tr>
<tr class="separator:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7100edcb0e8721bc861233332b7d2c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4b7100edcb0e8721bc861233332b7d2c">createTextTexture</a> (<a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;textRenderer, std::string text, vec4 fontColor, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; tex=nullptr)</td></tr>
<tr class="memdesc:a4b7100edcb0e8721bc861233332b7d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture with rendered text for a given string.  <a href="#a4b7100edcb0e8721bc861233332b7d2c">More...</a><br /></td></tr>
<tr class="separator:a4b7100edcb0e8721bc861233332b7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7f05f120bd356afe73fa0a26fc3458"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#afa7f05f120bd356afe73fa0a26fc3458">getAvailableFonts</a> (const std::string &amp;fontPath=std::string())</td></tr>
<tr class="memdesc:afa7f05f120bd356afe73fa0a26fc3458"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a list of all fonts found in the given directory, font directory of the fontrendering module  <a href="#afa7f05f120bd356afe73fa0a26fc3458">More...</a><br /></td></tr>
<tr class="separator:afa7f05f120bd356afe73fa0a26fc3458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464128344b2b03d507ac2f33ec41351f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a464128344b2b03d507ac2f33ec41351f">getDefaultFontPath</a> ()</td></tr>
<tr class="memdesc:a464128344b2b03d507ac2f33ec41351f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the default font directory of Inviwo  <a href="#a464128344b2b03d507ac2f33ec41351f">More...</a><br /></td></tr>
<tr class="separator:a464128344b2b03d507ac2f33ec41351f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1587f7d20a684086041c0b7bc6533f"><td class="memItemLeft" align="right" valign="top"><a id="ade1587f7d20a684086041c0b7bc6533f"></a>
<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (const <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:ade1587f7d20a684086041c0b7bc6533f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75398e19046de300d6ea0cb727a87794"><td class="memItemLeft" align="right" valign="top"><a id="a75398e19046de300d6ea0cb727a87794"></a>
<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (const <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:a75398e19046de300d6ea0cb727a87794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976d5326c5647d7a9063209eee9ca75c"><td class="memItemLeft" align="right" valign="top"><a id="a976d5326c5647d7a9063209eee9ca75c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a976d5326c5647d7a9063209eee9ca75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd7dfed95f3b9fcc29d2421e3d69f3"><td class="memItemLeft" align="right" valign="top"><a id="adcbd7dfed95f3b9fcc29d2421e3d69f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:adcbd7dfed95f3b9fcc29d2421e3d69f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5aa12285d95c1792955d4c32de5b29"><td class="memItemLeft" align="right" valign="top"><a id="a6a5aa12285d95c1792955d4c32de5b29"></a>
<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (const <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a6a5aa12285d95c1792955d4c32de5b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d946d516e1f1f4aaf698472e30486c"><td class="memItemLeft" align="right" valign="top"><a id="aa9d946d516e1f1f4aaf698472e30486c"></a>
<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (const <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:aa9d946d516e1f1f4aaf698472e30486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b08c3d3861ad6c1820ef8bda2a11d3"><td class="memItemLeft" align="right" valign="top"><a id="a79b08c3d3861ad6c1820ef8bda2a11d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a79b08c3d3861ad6c1820ef8bda2a11d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8cf4d5c05f1080f751a389346a2ef7"><td class="memItemLeft" align="right" valign="top"><a id="a8b8cf4d5c05f1080f751a389346a2ef7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:a8b8cf4d5c05f1080f751a389346a2ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>util </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ade565d10867e0dc26e164bd60ff9ef6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade565d10867e0dc26e164bd60ff9ef6c">&#9670;&nbsp;</a></span>PrecsionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceinviwo_1_1util.html#ade565d10867e0dc26e164bd60ff9ef6c">inviwo::util::PrecsionType</a> = typedef typename std::remove_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility for retrieving the type of a (Buffer/Layer/Volume)RamPrecision pointer variable. Example usage: </p><div class="fragment"><div class="line">VolumeRam* volumeram = ...; <span class="comment">// of some glm vector type.</span></div><div class="line"><span class="keyword">auto</span> count = volumeram-&gt;dispatch&lt;size_t, dispatching::filter::Vecs&gt;([](<span class="keyword">auto</span> vrprecision) {</div><div class="line">    <span class="keyword">using</span> VolumeType = util::PrecsionType&lt;decltype(vrprecision)&gt;;</div><div class="line">    ....</div></div><!-- fragment --><p> VolumeType will then be for example VolumeRamPrecision&lt;vec3&gt; </p>

</div>
</div>
<a id="accdae1f9f37726cbb9ea49087f03ca79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdae1f9f37726cbb9ea49087f03ca79">&#9670;&nbsp;</a></span>PrecsionValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceinviwo_1_1util.html#accdae1f9f37726cbb9ea49087f03ca79">inviwo::util::PrecsionValueType</a> = typedef typename <a class="el" href="namespaceinviwo_1_1util.html#ade565d10867e0dc26e164bd60ff9ef6c">PrecsionType</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility for retrieving the type of a (Buffer/Layer/Volume)RamPrecision pointer variable. Example usage: </p><div class="fragment"><div class="line">VolumeRam* volumeram = ...; <span class="comment">// of some glm vector type.</span></div><div class="line"><span class="keyword">auto</span> count = volumeram-&gt;dispatch&lt;size_t, dispatching::filter::Vecs&gt;([](<span class="keyword">auto</span> vrprecision) {</div><div class="line">    <span class="keyword">using</span> ValueType = util::PrecsionValueType&lt;decltype(vrprecision)&gt;;</div><div class="line">    ....</div></div><!-- fragment --><p> ValueType will then be for example vec3 </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a91b84870bcc5a9146482efc443d4d58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b84870bcc5a9146482efc443d4d58e">&#9670;&nbsp;</a></span>appendIfNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string inviwo::util::appendIfNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends b to a if a is not empty and returns a. Useful if an empty a is considered an error and we want to propagate that error. </p>

</div>
</div>
<a id="ab6356ee05cfde312881b948335bf689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6356ee05cfde312881b948335bf689b">&#9670;&nbsp;</a></span>convexHull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; inviwo::util::convexHull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the complex hull from a given set of 2D points using the Monotone Chain algorithm, i.e. Andrew's convex hull algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms">https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>set of 2D points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>complex hull of input points </dd></dl>

</div>
</div>
<a id="a4b7100edcb0e8721bc861233332b7d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7100edcb0e8721bc861233332b7d2c">&#9670;&nbsp;</a></span>createTextTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_FONTRENDERING_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; inviwo::util::createTextTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>textRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4&#160;</td>
          <td class="paramname"><em>fontColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td>
          <td class="paramname"><em>tex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture with rendered text for a given string. </p>
<p>Creates a texture with a text string using the specified renderer, fontSize and color. May take an additional variable tex of an existing texture that can be reused to reduce the number of times we need to allocating new textures.</p>
<p>The size of the texture will be the smallest possible for the given text and the pixels containing no text will have zero alpha.</p>
<p>For correct alignment of the baseline, the position of where this texture will be rendered must be adjusted by pos + computeBoundingBox(text).glyphsOrigin. See also <a class="el" href="classinviwo_1_1TextOverlayGL.html#a3b602a8eb4f5a5daf62a77b18a551344">TextOverlayGL::process()</a> as an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textRenderer</td><td>The renderer that will be used to render the text </td></tr>
    <tr><td class="paramname">text</td><td>text to be rendered </td></tr>
    <tr><td class="paramname">fontSize</td><td>size of the text in pt </td></tr>
    <tr><td class="paramname">fontColor</td><td>the final color of the text </td></tr>
    <tr><td class="paramname">tex</td><td>optional cache texture which will be reused if possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>texture containing the text </dd></dl>

</div>
</div>
<a id="a6e1e0f2ae3a7b52b3a951b6fff0411b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1e0f2ae3a7b52b3a951b6fff0411b2">&#9670;&nbsp;</a></span>createTextTextureObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_FONTRENDERING_API <a class="el" href="structinviwo_1_1TextTextureObject.html">TextTextureObject</a> inviwo::util::createTextTextureObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>textRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4&#160;</td>
          <td class="paramname"><em>fontColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td>
          <td class="paramname"><em>tex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture with rendered text for a given string including its bounding box. </p>
<p>Creates a texture with rendered text for a string using the specified renderer, fontSize and color. May take an additional variable tex of an existing texture that can be reused to reduce the number of times we need to allocating new textures. The resulting texture is returned along with the respective bounding box.</p>
<p>The size of the texture will be the smallest possible for the given text. All pixels containing no text will have zero alpha.</p>
<p>For correct alignment of the baseline, the position of where this texture will be rendered must be adjusted by pos + TextTextureObject.glyphsOrigin. See also <a class="el" href="classinviwo_1_1TextOverlayGL.html#a3b602a8eb4f5a5daf62a77b18a551344">TextOverlayGL::process()</a> as an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textRenderer</td><td>The renderer that will be used to render the text </td></tr>
    <tr><td class="paramname">text</td><td>string to be rendered </td></tr>
    <tr><td class="paramname">fontSize</td><td>size of the text in pt </td></tr>
    <tr><td class="paramname">fontColor</td><td>the final color of the text </td></tr>
    <tr><td class="paramname">tex</td><td>optional cache texture which will be reused if possible (same texture will be returned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>text texture object referring to both texture and corresponding bounding box </dd></dl>

</div>
</div>
<a id="ad45333385bb88c2c829ca1c624e69f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45333385bb88c2c829ca1c624e69f2e">&#9670;&nbsp;</a></span>dataMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;dvec4, dvec4&gt; inviwo::util::dataMinMax </td>
          <td>(</td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IgnoreSpecialValues&#160;</td>
          <td class="paramname"><em>ignore</em> = <code>IgnoreSpecialValues::No</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute component-wise minimum and maximum values scalar and glm::vec types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to values </td></tr>
    <tr><td class="paramname">size</td><td>of data </td></tr>
    <tr><td class="paramname">ignore</td><td>infinite and NaN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum and maximum values of each component and zero for non-existing components </dd></dl>

</div>
</div>
<a id="a4344b2477debffad3176a91526179640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4344b2477debffad3176a91526179640">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::enumerate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>conts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerate element in a container. Example use case: std::vector&lt;int&gt; vec(10); for (auto&amp;&amp; item : util::enumerate(vec)) { auto&amp;&amp; ind = get&lt;0&gt;(item); auto&amp;&amp; elem = get&lt;1&gt;(item); }</p>
<p>with C++17 structured bindings for (auto&amp;&amp; [ind, elem] : util::enumerate(vec)) {</p>
<p>} </p>

</div>
</div>
<a id="a731971fbc0202eccf36e24fc48970761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731971fbc0202eccf36e24fc48970761">&#9670;&nbsp;</a></span>expandCompositeProcessorIntoNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::expandCompositeProcessorIntoNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CompositeProcessor.html">CompositeProcessor</a> &amp;&#160;</td>
          <td class="paramname"><em>composite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand a composite processors sub network into its network. Effectively reversing the actions of replaceSelectionWithCompositeProcessor. All processor except for composite sink and composite source processors are moved from the sub network into the network of the composite processor. Connections and links are the reestablished. Sources and sinks are discarded. </p>

</div>
</div>
<a id="a947c6cae56d5239848a9e2fa42cc5d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c6cae56d5239848a9e2fa42cc5d15">&#9670;&nbsp;</a></span>findUniqueIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string inviwo::util::findUniqueIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>isUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility to augment an identifier with a number to make it unique. Will add an increasing number to the end of the given identifier until the isUnique test returns true. Example for a processor identifier: auto uniqueIdentifier = <a class="el" href="namespaceinviwo_1_1util.html#a947c6cae56d5239848a9e2fa42cc5d15">util::findUniqueIdentifier</a>( startIdentifier, [&amp;](const std::string&amp; id) { return processorNetwork-&gt;getProcessorByIdentifier(id) == nullptr; }, "" ); </p>

</div>
</div>
<a id="a6582b2f1b71b3ac6d3e606bc361ab07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582b2f1b71b3ac6d3e606bc361ab07e">&#9670;&nbsp;</a></span>forEachParallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename T  = typename Iterable::value_type, typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::forEachParallel </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>jobs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use multiple threads to iterate over all elements in an iterable data structure (such as std::vector). If the Inviwo pool size is zero it will be executed directly in the same thread as the caller. The function will return once all jobs as has finished processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
    <tr><td class="paramname">jobs</td><td>optional parameter specifying how many jobs to create, if jobs==0 (default) it will create pool size * 4 jobs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e51751558c8e07c5b63cddf28b19f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e51751558c8e07c5b63cddf28b19f8">&#9670;&nbsp;</a></span>forEachParallelAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename T  = typename Iterable::value_type, typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::future&lt;void&gt; &gt; inviwo::util::forEachParallelAsync </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>jobs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use multiple threads to iterate over all elements in an iterable data structure (such as std::vector). If the Inviwo pool size is zero it will be executed directly in the same thread as the caller. The function will return once all jobs as has been created and queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
    <tr><td class="paramname">jobs</td><td>optional parameter specifying how many jobs to create, if jobs==0 (default) it will create pool size * 4 jobs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of futures, one for each job created. </dd></dl>

</div>
</div>
<a id="a10fced04a2ded91e940c80974c559a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fced04a2ded91e940c80974c559a93">&#9670;&nbsp;</a></span>generateVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::generateVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat3 &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for generating volumes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td><a class="el" href="classinviwo_1_1Volume.html">Volume</a> grid dimensions </td></tr>
    <tr><td class="paramname">basis</td><td><a class="el" href="classinviwo_1_1Volume.html">Volume</a> basis, offset automatically set to center the volume around origo </td></tr>
    <tr><td class="paramname">function</td><td>Functor called for each volume voxel. T(const size3_t&amp; ind). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba0bfadae887301565e97b98483268b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba0bfadae887301565e97b98483268b">&#9670;&nbsp;</a></span>getArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double inviwo::util::getArea </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the area of a convex polygon </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>points ordered counter-clockwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>area of polygon </dd></dl>

</div>
</div>
<a id="afa7f05f120bd356afe73fa0a26fc3458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7f05f120bd356afe73fa0a26fc3458">&#9670;&nbsp;</a></span>getAvailableFonts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; IVW_MODULE_FONTRENDERING_API inviwo::util::getAvailableFonts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fontPath</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a list of all fonts found in the given directory, font directory of the fontrendering module </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fontPath</td><td>path to fonts. If empty, the directory returned by getDefaultPath() will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>font list containing pairs for all available fonts. Each pair holds the font name and the full path. Fonts are sorted alphabetically </dd></dl>

</div>
</div>
<a id="aea87cbfeb4336cada908d582d016461a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea87cbfeb4336cada908d582d016461a">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ivec2, ivec2 &gt; inviwo::util::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve bounding box of the processors in the list. The return value is pair of the min x,y and the max x,y </p>

</div>
</div>
<a id="ab17166a30c043e7eb8d64099a5f6fc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17166a30c043e7eb8d64099a5f6fc97">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ivec2, ivec2 &gt; inviwo::util::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve bounding box of the processors in the network. The return value is pair of the min x,y and the max x,y </p>

</div>
</div>
<a id="a9a367e3e6c6c448efab8e00c52de4097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a367e3e6c6c448efab8e00c52de4097">&#9670;&nbsp;</a></span>getBuildInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a> inviwo::util::getBuildInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses build information via an INI file or compile-time definitions. </p>
<dl class="section return"><dt>Returns</dt><dd>build information </dd></dl>

</div>
</div>
<a id="ad8a6c260b4f3557da91b05b08bab802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a6c260b4f3557da91b05b08bab802a">&#9670;&nbsp;</a></span>getCenterPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivec2 inviwo::util::getCenterPosition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the mean position of the processors in the list. </p>

</div>
</div>
<a id="aa4baa486b72f1f0869d5b078273b7479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4baa486b72f1f0869d5b078273b7479">&#9670;&nbsp;</a></span>getCenterPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivec2 inviwo::util::getCenterPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the mean position of the processors in the network. </p>

</div>
</div>
<a id="a464128344b2b03d507ac2f33ec41351f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464128344b2b03d507ac2f33ec41351f">&#9670;&nbsp;</a></span>getDefaultFontPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string IVW_MODULE_FONTRENDERING_API inviwo::util::getDefaultFontPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the default font directory of Inviwo </p>
<dl class="section return"><dt>Returns</dt><dd>default path containing fonts shipped with Inviwo. Corresponds to the font directory located in the font rendering module directory. </dd></dl>

</div>
</div>
<a id="a74142af3631865f4c234289d551ce883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74142af3631865f4c234289d551ce883">&#9670;&nbsp;</a></span>getDefaultTimerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> &amp; inviwo::util::getDefaultTimerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the default <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> from the app. </p>

</div>
</div>
<a id="a0a83c9f2374441d3698563e90c35a115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a83c9f2374441d3698563e90c35a115">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules. ">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> </p>

</div>
</div>
<a id="abf13843c2e4fd0df7921e8c9365b044f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf13843c2e4fd0df7921e8c9365b044f">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules. ">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result. ">Processor</a> </p>

</div>
</div>
<a id="ad9d5b9648bb957bd76d93b52beddfc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d5b9648bb957bd76d93b52beddfc4b">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules. ">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> </p>

</div>
</div>
<a id="a0d55ce422a8f0e6b2d423426246a9871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d55ce422a8f0e6b2d423426246a9871">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules. ">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor. ">Property</a> </p>

</div>
</div>
<a id="af1a8f1d379addc2b0acf5b22775f20ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a8f1d379addc2b0acf5b22775f20ea">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules. ">InviwoApplication</a> </p>

</div>
</div>
<a id="a4a9d8109d75e9f8a6b234bfe6c426af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9d8109d75e9f8a6b234bfe6c426af4">&#9670;&nbsp;</a></span>getLibrarySearchPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; inviwo::util::getLibrarySearchPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns paths to search for module libraries. All platforms: executable directory and application modules directory (AppData/Inviwo/modules on windows). Platform dependent search directories: OSX: DYLD_LIBRARY_PATH UNIX: LD_LIBRARY_PATH/LD_RUN_PATH, RPATH and "executable directory
/../../lib". </p>
<dl class="section return"><dt>Returns</dt><dd>List of paths to directories </dd></dl>

</div>
</div>
<a id="ab99f2c2c49e4d7f23742ee2e0866fa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99f2c2c49e4d7f23742ee2e0866fa3d">&#9670;&nbsp;</a></span>getMetaData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> * inviwo::util::getMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the meta data of the processor. </p>

</div>
</div>
<a id="a8b23c11bea75c804e260490afeec4eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b23c11bea75c804e260490afeec4eef">&#9670;&nbsp;</a></span>getMetaData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> * inviwo::util::getMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the meta data of the processor. </p>

</div>
</div>
<a id="a5bff6779ff52348702ca64e4b2c8cd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bff6779ff52348702ca64e4b2c8cd73">&#9670;&nbsp;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivec2 inviwo::util::getPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the position of the processor. </p>

</div>
</div>
<a id="aaeb2d348f3df4ca917597752612991bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb2d348f3df4ca917597752612991bb">&#9670;&nbsp;</a></span>getPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ivec2 &gt; inviwo::util::getPositions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the positions of the processors in the list. </p>

</div>
</div>
<a id="ad9754915d79c8228216a3969b3ec336c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9754915d79c8228216a3969b3ec336c">&#9670;&nbsp;</a></span>getPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ivec2 &gt; inviwo::util::getPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the positions of the processors in the network. </p>

</div>
</div>
<a id="a95c836cccb8edab48454737dedf4ea04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c836cccb8edab48454737dedf4ea04">&#9670;&nbsp;</a></span>getVolumeDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size3_t inviwo::util::getVolumeDimensions </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the true volume dimensions considering volume margins and bricking </p>
<dl class="section return"><dt>Returns</dt><dd>true volume dimensions </dd></dl>

</div>
</div>
<a id="a8542415328e2816a23607c5cc98c9341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8542415328e2816a23607c5cc98c9341">&#9670;&nbsp;</a></span>getVolumeMargins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; vec3, vec3 &gt; inviwo::util::getVolumeMargins </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the margins of a volume, in normalized texture coordinates [0,1] </p>
<dl class="section return"><dt>Returns</dt><dd>pair of margins from the bottom left corner and the top right corner </dd></dl>

</div>
</div>
<a id="a0bc9d791f018bc81c41c404dd173a3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc9d791f018bc81c41c404dd173a3cb">&#9670;&nbsp;</a></span>haltonSequence() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sequence of length numberOfPoints of pseduo-random numbers on the open range (0 1). </p><dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>what base to use to generate fractions </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>amount of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18c7215de9974cbf63e74f28ae4941cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c7215de9974cbf63e74f28ae4941cc">&#9670;&nbsp;</a></span>haltonSequence() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classinviwo_1_1Image.html">Image</a>&gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseX</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseY</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with sparse noise based on a pair of two Halton Sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceinviwo_1_1util.html#a0bc9d791f018bc81c41c404dd173a3cb">haltonSequence(size_t base, size_t numberOfPoints)</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of the resulting image. </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">baseX</td><td>base used for the fractions to generate the x-values </td></tr>
    <tr><td class="paramname">baseY</td><td>base used for the fractions to generate the y-values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abad0d2b2ea3ccf4f8f61bde3bc4a3292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad0d2b2ea3ccf4f8f61bde3bc4a3292">&#9670;&nbsp;</a></span>haltonSequence() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size3_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseX</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseY</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseZ</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Volume.html">Volume</a> with sparse noise based on a three Halton Sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceinviwo_1_1util.html#a0bc9d791f018bc81c41c404dd173a3cb">haltonSequence(size_t base, size_t numberOfPoints)</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of the resulting <a class="el" href="classinviwo_1_1Volume.html">Volume</a>. </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">baseX</td><td>base used for the fractions to generate the x-values </td></tr>
    <tr><td class="paramname">baseY</td><td>base used for the fractions to generate the y-values </td></tr>
    <tr><td class="paramname">baseZ</td><td>base used for the fractions to generate the z-values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a940aef3565e6c2edd145d6d410087668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940aef3565e6c2edd145d6d410087668">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to combine several hash values <a href="http://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x">http://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x</a> </p>

</div>
</div>
<a id="a120524c5de0bd62f52483f096e0374d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120524c5de0bd62f52483f096e0374d4">&#9670;&nbsp;</a></span>is_callable_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... A, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structinviwo_1_1util_1_1detail_1_1is__callable.html">detail::is_callable</a>&lt;F, A...&gt; inviwo::util::is_callable_with </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type trait to determine if type "callback" cann be called with certain arguments. Example: util::is_callable_with&lt;float&gt;(callback) where callback = [](float){} -&gt; true callback = [](std::string){} -&gt; false </p>

</div>
</div>
<a id="aa048b0cf2e27625499d9ac8e03af03d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa048b0cf2e27625499d9ac8e03af03d6">&#9670;&nbsp;</a></span>isConvex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isConvex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether the given polygon is convex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>polygon consisting of points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the polygon is convex, false otherwise </dd></dl>

</div>
</div>
<a id="a193aac2254d9cc5b5b1029995323d957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193aac2254d9cc5b5b1029995323d957">&#9670;&nbsp;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; util::rank&lt; T &gt;::value==1 &amp;&amp;util::extent&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isInside </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a given point lies within the convex hull </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hull</td><td>convex hull </td></tr>
    <tr><td class="paramname">p</td><td>point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point lies inside the convex hull </dd></dl>

</div>
</div>
<a id="ab0b87c0053e5b3359ec3d4622c804797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b87c0053e5b3359ec3d4622c804797">&#9670;&nbsp;</a></span>isSelected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isSelected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the selection state of processor. </p>

</div>
</div>
<a id="a90dfea83005204a1c4beaa3714c38e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dfea83005204a1c4beaa3714c38e74">&#9670;&nbsp;</a></span>layerRAMDistanceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::layerRAMDistanceTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>inLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *&#160;</td>
          <td class="paramname"><em>outDistanceField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; 2, U &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size2_t&#160;</td>
          <td class="paramname"><em>upsample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTransform&#160;</td>
          <td class="paramname"><em>valueTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProgressCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of Euclidean Distance Transform according to Saito's algorithm: T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance transformations of an n-dimensional digitized picture with applications. Pattern Recognition, 27(11). pp. 1551-1565, 1994. <a href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf</a></p>
<p>Calculates the distance in base mat space</p><ul>
<li>Predicate is a function of type (const T &amp;value) -&gt; bool to deside if a value in the input is a "feature".</li>
<li>ValueTransform is a function of type (const U&amp; squaredDist) -&gt; U that is appiled to all squared distance values at the end of the calculation.</li>
<li>ProcessCallback is a function of type (double progress) -&gt; void that is called with a value from 0 to 1 to indicate the progress of the calculation. </li>
</ul>

</div>
</div>
<a id="a0b4c1a60c4b345a81d28ca29ab9848d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4c1a60c4b345a81d28ca29ab9848d7">&#9670;&nbsp;</a></span>make_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::make_sequence </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a>&lt;T&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenvience function for creating a sequence. Use case example: auto inc = 2; auto end = 3; for (auto&amp;&amp; i : util::make_sequence(0, end, inc)) { // Iterates over 0 and 2 } </p>

</div>
</div>
<a id="af0257287b8cc817dc288c86611672e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0257287b8cc817dc288c86611672e4c">&#9670;&nbsp;</a></span>makeIndirectIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool PropagateConst = true, typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a>&lt;Iter, PropagateConst&gt; inviwo::util::makeIndirectIterator </td>
          <td>(</td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a> </dd></dl>

</div>
</div>
<a id="a54ea5db009d3c6ea5afa9305a82d54f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ea5db009d3c6ea5afa9305a82d54f6">&#9670;&nbsp;</a></span>makeMarchingCubeVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::makeMarchingCubeVolume </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A 2x2x2 volume corresponding to a marching cube case </p>

</div>
</div>
<a id="a6a8de07bc8d6ff42e86554ee40b76b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8de07bc8d6ff42e86554ee40b76b82">&#9670;&nbsp;</a></span>makeProcessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classinviwo_1_1Processor.html">Processor</a>&gt; inviwo::util::makeProcessor </td>
          <td>(</td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A utility function to create a processor and set identifier, display name, and position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Sets the position meta data of the <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result. ">Processor</a> </td></tr>
    <tr><td class="paramname">args</td><td>Any extra arguments to supply to the <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result. ">Processor</a> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7601a4221d0a73cbc4fbcf2a6397369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7601a4221d0a73cbc4fbcf2a6397369">&#9670;&nbsp;</a></span>makeRippleVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::makeRippleVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A quickly oscillating density between 0 and 1 </p>

</div>
</div>
<a id="afd7f0331189f7bab9a30abcaa2232203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7f0331189f7bab9a30abcaa2232203">&#9670;&nbsp;</a></span>makeSingleVoxelVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::makeSingleVoxelVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Center voxel equal to 1 all other 0 </p>

</div>
</div>
<a id="a3624bda720c599cf5ba2b1da294aba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3624bda720c599cf5ba2b1da294aba93">&#9670;&nbsp;</a></span>makeSphericalVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::makeSphericalVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spherically symmetric density centered in the volume decaying radially with the distance from the center </p>

</div>
</div>
<a id="a1fcfa6968810037bc39cac05239f3586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcfa6968810037bc39cac05239f3586">&#9670;&nbsp;</a></span>marchingcubes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingcubes </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enclose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;&#160;</td>
          <td class="paramname"><em>progressCallback</em> = <code>std::function&lt;&#160;void(float)&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>maskingCallback</em> = <code>[](const&#160;size3_t&#160;&amp;)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an isosurface from a volume using the Marching Cubes algorithm</p>
<p>Note: Share interface with <a class="el" href="namespaceinviwo_1_1util.html#a8d16927242ef3ca2f6eb3763bca997c6">util::marchingtetrahedron</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the isosurface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], usefull for progressbars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a859f8da4f45bae2f0ef4a246c9f83d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859f8da4f45bae2f0ef4a246c9f83d3c">&#9670;&nbsp;</a></span>marchingCubesOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingCubesOpt </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enclose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;&#160;</td>
          <td class="paramname"><em>progressCallback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>maskingCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an iso surface from a volume using the Marching Cubes algorithm</p>
<p>Note: Shares interface with util::marchingcbes and <a class="el" href="namespaceinviwo_1_1util.html#a8d16927242ef3ca2f6eb3763bca997c6">util::marchingtetrahedron</a> This is an optimized version of <a class="el" href="namespaceinviwo_1_1util.html#a1fcfa6968810037bc39cac05239f3586">util::marchingcubes</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the iso surface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], useful for progress bars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d16927242ef3ca2f6eb3763bca997c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d16927242ef3ca2f6eb3763bca997c6">&#9670;&nbsp;</a></span>marchingtetrahedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingtetrahedron </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>vec4(1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enclose</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;&#160;</td>
          <td class="paramname"><em>progressCallback</em> = <code>std::function&lt;&#160;void(float)&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>maskingCallback</em> = <code>[](const&#160;size3_t&#160;&amp;)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an isosurface from a volume using the Marching Tetrahedron algorithm</p>
<p>Note: Share interface with <a class="el" href="namespaceinviwo_1_1util.html#a1fcfa6968810037bc39cac05239f3586">util::marchingcubes</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the isosurface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], usefull for progressbars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba424f4f92432dc34daf48c2fd5e2b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba424f4f92432dc34daf48c2fd5e2b7f">&#9670;&nbsp;</a></span>offsetPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::offsetPosition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset all the positions of the processors in the list by offset </p>

</div>
</div>
<a id="a9e906349979b05c9d0bba6d0a870da72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e906349979b05c9d0bba6d0a870da72">&#9670;&nbsp;</a></span>perlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rand  = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classinviwo_1_1Image.html">Image</a>&gt; inviwo::util::perlinNoise </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>persistence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>endLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with perlin noise, a cloud like noise using the sum of several white noise images with different frequencies </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output image </td></tr>
    <tr><td class="paramname">persistence</td><td>controls the amplitude used in the different frequencies </td></tr>
    <tr><td class="paramname">startLevel</td><td>controls the min level used. The level is determining the frequency to use in each white noise image as 2^level </td></tr>
    <tr><td class="paramname">endLevel</td><td>controlsthe max level used. </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf192a88e50a7b6fd57363e4b7f2adfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf192a88e50a7b6fd57363e4b7f2adfa">&#9670;&nbsp;</a></span>poissonDisk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rand  = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classinviwo_1_1Image.html">Image</a>&gt; inviwo::util::poissonDisk </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poissonDotsAlongX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with sparse noise based on the perlin noise algorith. </p><dl class="section see"><dt>See also</dt><dd><a href="http://devmag.org.za/2009/05/03/poisson-disk-sampling/">http://devmag.org.za/2009/05/03/poisson-disk-sampling/</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output image </td></tr>
    <tr><td class="paramname">poissonDotsAlongX</td><td>controlls the amount on points there is on average per line, set the minimum distance between points </td></tr>
    <tr><td class="paramname">maxPoints</td><td>a fallback variable to prevent generating to many points </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d29c3a03f733f46621cb8b3dc1f0619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d29c3a03f733f46621cb8b3dc1f0619">&#9670;&nbsp;</a></span>randomImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classinviwo_1_1Image.html">Image</a>&gt; inviwo::util::randomImage </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>Dist(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with white noise based using C++ a given random number generator and distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output image </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48b2f672f99a31ee8b19f6f40fa768cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2f672f99a31ee8b19f6f40fa768cb">&#9670;&nbsp;</a></span>randomSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::randomSequence </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>Dist(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a data container of type T with numberOfElements random numbers using the given random number generator and distribution </p>

</div>
</div>
<a id="a995a3d89246ce375a3ecc478959a8cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995a3d89246ce375a3ecc478959a8cea">&#9670;&nbsp;</a></span>randomVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classinviwo_1_1Volume.html">Volume</a>&gt; inviwo::util::randomVolume </td>
          <td>(</td>
          <td class="paramtype">size3_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>Dist(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an <a class="el" href="classinviwo_1_1Volume.html">Volume</a> with white noise based using C++ a given random number generator and distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output <a class="el" href="classinviwo_1_1Volume.html">Volume</a> </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2be9fca7a318feb7d7a1d14b79eb976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2be9fca7a318feb7d7a1d14b79eb976">&#9670;&nbsp;</a></span>replaceSelectionWithCompositeProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::replaceSelectionWithCompositeProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classinviwo_1_1CompositeProcessor.html" title="A processor containing a network of processors, i.e. it will act as a sub network within a processor ...">CompositeProcessor</a> out of the currently selected processors and replace them with the composite processors. The selected processors are moved from the current network into the sub network of the composite processor. For each port connection between a selected and unselected processor a composite sink or composite source processor is added to the sub network and connections are made from the selected processor to the sink/source and from the composite processor to the unselected processor. For each link between a selected and unselected processor, a super property is added to the composite processor and the link added to it. </p>

</div>
</div>
<a id="a9cee67b6facc99fd2e7a3ab655d65641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cee67b6facc99fd2e7a3ab655d65641">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to reverse the orders of the elements in a buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the buffer to reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca943f4416953f426313a35674e4d3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca943f4416953f426313a35674e4d3e1">&#9670;&nbsp;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position of processor to pos </p>

</div>
</div>
<a id="a7230aed1f8b9a70db2bd5f6317082c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7230aed1f8b9a70db2bd5f6317082c8e">&#9670;&nbsp;</a></span>setSelected() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::setSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the selection state of processor </p>

</div>
</div>
<a id="a3a51062f4f2e754a047e5bedd9da776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a51062f4f2e754a047e5bedd9da776b">&#9670;&nbsp;</a></span>setSelected() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::setSelected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the listed processors as selected or unSelected. </p>

</div>
</div>
<a id="a45dabd37be130a5a97526c8fbc77f65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dabd37be130a5a97526c8fbc77f65e">&#9670;&nbsp;</a></span>stripModuleFileNameDecoration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string inviwo::util::stripModuleFileNameDecoration </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes inviwo-module from module library file name. Turns "/path/to/inviwo-module-yourmodule.dll" into "yourmodule". Returns filename without extension if inviwo-module was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to module file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the module </dd></dl>

</div>
</div>
<a id="a828ef8f28093e76d6de14668216ca4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828ef8f28093e76d6de14668216ca4ed">&#9670;&nbsp;</a></span>toWstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring inviwo::util::toWstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the given std::string to std::wstring. On Windows, MultiByteToWideChar is used for this conversion assuming utf8 encoding. Otherwise, std::mbsrtowcs is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>multibyte character string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input converted to std::wstring </dd></dl>

</div>
</div>
<a id="aa893e468e6145d6106135461cd962371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa893e468e6145d6106135461cd962371">&#9670;&nbsp;</a></span>volumeRAMDistanceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::volumeRAMDistanceTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>inVolume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *&#160;</td>
          <td class="paramname"><em>outDistanceField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; 3, U &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size3_t&#160;</td>
          <td class="paramname"><em>upsample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTransform&#160;</td>
          <td class="paramname"><em>valueTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProgressCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of Euclidean Distance Transform according to Saito's algorithm: T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance transformations of an n-dimensional digitized picture with applications. Pattern Recognition, 27(11). pp. 1551-1565, 1994. <a href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf</a></p>
<p>Calculates the distance in grid index space</p><ul>
<li>Predicate is a function of type (const T &amp;value) -&gt; bool to deside if a value in the input is a "feature".</li>
<li>ValueTransform is a function of type (const U&amp; squaredDist) -&gt; U that is appiled to all squared distance values at the end of the calculation.</li>
<li>ProcessCallback is a function of type (double progress) -&gt; void that is called with a value from 0 to 1 to indicate the progress of the calculation. </li>
</ul>

</div>
</div>
<a id="af0d36142d9279c614f2d9a0d4503ecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d36142d9279c614f2d9a0d4503ecb8">&#9670;&nbsp;</a></span>voxelVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double inviwo::util::voxelVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the volume of a single voxel, taking the basis and the dimensions into account The units of the result is in the unit as the basis vectors ^3 </p>
<dl class="section return"><dt>Returns</dt><dd>volume of one voxel </dd></dl>

</div>
</div>
<a id="a301f6b6c9149cf18fcbf79a4ee50671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301f6b6c9149cf18fcbf79a4ee50671f">&#9670;&nbsp;</a></span>writeIvfVolumeSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::string inviwo::util::writeIvfVolumeSequence </td>
          <td>(</td>
          <td class="paramtype">const VolumeSequence &amp;&#160;</td>
          <td class="paramname"><em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>reltivePathToElements</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a volume sequence to disk. </p>
<p>Writes a volume sequence to disk. Will create one main file ([name].ivfs) and a series of ivf volumes ([name]xx.ivf), one for each element in the sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumes</td><td>The volume sequence to export </td></tr>
    <tr><td class="paramname">name</td><td>the name of the dataset, will be used for to name the output files [name].ivfs and [name]xx.ivf </td></tr>
    <tr><td class="paramname">path</td><td>path to the folder to put the main file </td></tr>
    <tr><td class="paramname">reltivePathToElements</td><td>relative path (from the path to the main file) to where the sequence elements will be written </td></tr>
    <tr><td class="paramname">overwrite</td><td>whether or not to overwrite existing files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>path to the created main-file </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1IvfSequenceVolumeWriter.html" title="Writter for *.ivfs sequnce files. ">inviwo::IvfSequenceVolumeWriter</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1IvfSequenceVolumeReader.html" title="Reader for *.ivfs sequnce files. ">inviwo::IvfSequenceVolumeReader</a> </dd></dl>

</div>
</div>
<a id="a2ec11e63479fff3c005d159414687d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec11e63479fff3c005d159414687d4e">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::zip </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structinviwo_1_1util_1_1detailzip_1_1zipper.html">detailzip::zipper</a>&lt;T...&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over containers in sync. Example use case 1: std::vector&lt;int&gt; a(10); std::vector&lt;int&gt; b(10); for (auto&amp;&amp; i : util::zip(a, b)) { std::cout &lt;&lt; get&lt;0&gt;(i) &lt;&lt; " " &lt;&lt; get&lt;1&gt;(i) &lt;&lt; std::endl; }</p>
<p>with C++17 structured bindings: for (auto&amp;&amp; [i, j] : util::enumerate(vec)) { std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; std::endl; } </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinviwo.html">inviwo</a></li><li class="navelem"><a class="el" href="namespaceinviwo_1_1util.html">util</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
